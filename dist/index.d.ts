// Generated by dts-bundle-generator v9.5.1

/**
 * Settings for a client connection.
 */
export type ClientConnectionSettings = {
	/**
	 * Identity of the client (e.g., "host", "client1", etc.).
	 */
	identity: string;
};
/**
 * Representation of a connection to a client.
 */
export declare class ClientToken {
	readonly identity: string;
	constructor(identity: string);
}
type PrimitiveValue = {
	value: string | number | boolean | null | undefined;
};
type ObjectReference = {
	objectId: string;
	typeId: string;
};
export type SerializedValue = PrimitiveValue | ObjectReference | undefined;
export declare const CreateMessageType = "create";
export declare const ChangeMessageType = "change";
export declare const DeleteMessageType = "delete";
export declare const ExecuteMessageType = "execute";
export declare const ExecuteFinishedMessageType = "executeFinished";
export type Message = {
	type: string;
	objectId: string;
};
export type CreateObjectMessage<TPayload = any> = Message & {
	type: typeof CreateMessageType;
	typeId: string;
	data: TPayload;
};
export type ChangeObjectMessage<TPayload = any> = Message & {
	type: typeof ChangeMessageType;
	data: TPayload;
};
export type DeleteObjectMessage = Message & {
	type: typeof DeleteMessageType;
};
export type ExecuteObjectMessage<TInstance extends object = any, TMethodName extends string & keyof TInstance = any> = Message & {
	type: typeof ExecuteMessageType;
	invokeId: unknown;
	method: TMethodName;
	parameters: SerializedValue[];
};
export type ExecuteFinishedObjectMessage = Message & {
	type: typeof ExecuteFinishedMessageType;
	invokeId: unknown;
	error?: any;
	result?: any;
};
export declare function isExecuteObjectMessage(message: Message): message is ExecuteObjectMessage;
export declare function isChangeObjectMessage(message: Message): message is ChangeObjectMessage;
export declare function isCreateObjectMessage(message: Message): message is CreateObjectMessage;
export declare function isDeleteObjectMessage(message: Message): message is DeleteObjectMessage;
export declare function isExecuteFinishedObjectMessage(message: Message): message is ExecuteFinishedObjectMessage;
type EventFunction = (...args: any[]) => void;
type EventMap = {
	[key: string]: EventFunction;
};
export type IEventEmitter<Events extends EventMap = EventMap> = {
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event] | undefined): number;
};
export declare class EventEmitter<Events extends EventMap = EventMap> implements IEventEmitter<Events> {
	readonly _events: {
		[key in keyof Events]?: EventFunction[];
	};
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event]): number;
	emit<Event extends keyof Events>(event: Event, ...args: any[]): void;
	protected onEventListenerAdded<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	protected onEventListenerRemoved<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
}
type OneOrMany<T> = T | Iterable<T>;
type Constructor<T = any> = {
	new (...args: any[]): T;
};
interface IDisposable {
	dispose(): void;
	[Symbol.dispose](): void;
}
type ClientTokenFilter = {
	/**
	 * Set of clients to include or exclude
	 */
	clientTokens?: OneOrMany<ClientToken>;
	/**
	 * Set of client identities to include or exclude
	 */
	identities?: OneOrMany<string>;
	/**
	 * If true, only the specified clients are included; if false, they are excluded, default is true
	 */
	isExclusive?: boolean;
};
export type MemoryManagementMode = "weak" | "byClient";
export type ArrayChangeSetMode = "trackSplices" | "compareStates";
type ExchangeMessagesSettings = {
	/**
	 * Optional function to handle errors that occur during message exchange.
	 * @param clientToken The client connection where the error occurred.
	 * @param error The error that occurred.
	 */
	errorHandler?: (clientToken: ClientToken, error: any) => void;
	/**
	 * Optional function to filter messages sent to or received from clients.
	 * Warning: Using this filter may lead to inconsistent states between server and clients if messages are blocked.
	 * You can use it to implement custom logic, such as ignoring certain messages for specific clients.
	 * @param clientToken The client connection involved in the message exchange.
	 * @param message The message being sent or received.
	 * @param isIncoming True if the message is incoming to the server, false if outgoing.
	 * @returns True to allow the message, false to block it.
	 */
	clientMessageFilter?: (clientToken: ClientToken, message: Message, isIncoming: boolean) => boolean;
	/**
	 * Clients to exchange messages with. If not provided, messages will be exchanged with all registered clients.
	 */
	clients?: ClientToken[];
} & ({
	/**
	 * Function to send messages to a single client and receive client messages back as results.
	 * @param clientToken The client connection to send messages to.
	 * @param messages The messages to send to the client.
	 * @returns A promise that resolves to the messages received from the client.
	 */
	sendToClientAsync: (clientToken: ClientToken, messages: Message[]) => Promise<Message[]>;
} | {
	/**
	 * Function to send messages to multiple clients and receive client messages back as results.
	 * @param messagesByClientToken A map of client connections to messages to send.
	 * @returns A promise that resolves to a map of client connections to messages received from the clients.
	 */
	sendToClientsAsync: (messagesByClientToken: Map<ClientToken, Message[]>) => Promise<Map<ClientToken, Message[]>>;
});
export type ObjectIdGeneratorSettings = {
	/**
	 * Function to generate an object ID..
	 * @param value
	 */
	generateId(value?: object): string;
} | {
	/**
	 * Prefix to use for generated object IDs.
	 */
	prefix: string;
};
export type FinalizedObjectSyncSettings = {
	identity: string;
	serializers: TypeSerializerConstructor[];
	intrinsicSerializers: TypeSerializerConstructor[];
	objectIdGeneratorSettings: ObjectIdGeneratorSettings;
	arrayChangeSetMode: ArrayChangeSetMode;
	memoryManagementMode: MemoryManagementMode;
};
export type ObjectSyncSettings = {
	/**
	 * Identity of this ObjectSync instance (e.g., "host" or "client1").
	 */
	identity: string;
	/**
	 * Type serializers to use for serializing and deserializing property values during synchronization.
	 * Can either be provided as an array of type serializers or constructors of SyncObject types.
	 * When constructors are provided, the corresponding internal TypeSerializer will be used.
	 * When not provided, all registered types and serializers will be used.
	 */
	serializers?: (TypeSerializerConstructor | Constructor)[];
	/**
	 * Intrinsic type serializers to use for serializing and deserializing base types (Array, Map, Set, Object) during synchronization.
	 * Can be provided as an array of type serializers.
	 * When not provided, default intrinsic type serializers will be used.
	 */
	intrinsicSerializers?: TypeSerializerConstructor[];
	/**
	 * Settings for generating object IDs.
	 * When not provided, a default generator with the identity as prefix will be used (eg: "host-1").
	 */
	objectIdGeneratorSettings?: ObjectIdGeneratorSettings;
	/**
	 * Defines how array changes are tracked and serialized.
	 * - "trackSplices": Uses splice instructions to record changes. More efficient for small changes. May transfer data which will be removed with a later splice.
	 * - "compareStates": gathers splice data by comparing the old array state to the new array state. More efficient for large changes. (Default)
	 */
	arrayChangeSetMode?: ArrayChangeSetMode;
	/**
	 * Specifies the memory management mode the ObjectSync instance should use.
	 * "weak": Uses WeakRefs to track object lifetimes. Delete messages will be sent when objects are garbage collected.
	 * "byClient" (default): Delete messages will be sent when objects are no longer used by a connected client.
	 */
	memoryManagementMode?: MemoryManagementMode;
};
export type TrackedObjectDisposable<TInstance extends object> = IDisposable & {
	readonly objectId: string;
	readonly instance: TInstance | undefined;
};
type DispatcherType<TInstance> = TInstance extends Array<infer TItem> ? IArrayDispatcher<TItem> : TInstance extends Set<infer TItem> ? ISetDispatcher<TItem> : TInstance extends Map<infer TKey, infer TValue> ? IMapDispatcher<TKey, TValue> : TInstance extends object ? ISyncObjectDispatcher<TInstance> : never;
type DispatcherOrFallback<TDispatcher, TInstance> = TDispatcher extends null ? DispatcherType<TInstance> : TDispatcher;
export declare class ObjectSync {
	private readonly _objectPool;
	private readonly _weakObjectPool;
	private readonly _objectsWithPendingMessages;
	private readonly _clients;
	private readonly _settings;
	private readonly _pendingWeakDeletes;
	private _nextObjectId;
	private _pendingCreateMessageByObjectId;
	private readonly _ownClientToken;
	constructor(settings: ObjectSyncSettings);
	get arrayChangeSetMode(): ArrayChangeSetMode;
	reportPendingMessagesForObject(objectInfo: ObjectInfo): void;
	generateObjectId(value?: object): string;
	/**
	 * Registers a new client connection.
	 * @param identity The identity of the client connection.
	 * @returns The token to the newly registered client connection.
	 */
	registerClient(identity: string): ClientToken;
	/**
	 * Registers a new client connection.
	 * @param settings Settings for the client connection.
	 * @returns The token to the newly registered client connection.
	 */
	registerClient(settings: ClientConnectionSettings): ClientToken;
	get registeredClientTokens(): ClientToken[];
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	removeClient(clientToken: ClientToken): void;
	/**
	 * Gets the identity of this ObjectSync instance.
	 */
	get identity(): string;
	/** Returns all currently tracked objects. */
	get allTrackedObjects(): object[];
	/**
	 * Sets a client restriction filter for a tracked object.
	 * @param obj The tracked object to set the filter for.
	 * @param filter The client restriction filter to apply.
	 */
	setClientRestriction<T extends object>(obj: T, filter: ClientTokenFilter): void;
	/**
	 * Tracks an object for synchronization.
	 * Must be called for root objects you want to track. Tracked root objects will never be automatically deleted.
	 * @param instance The instance to track.
	 * @param objectId Optional object ID to use for the tracked object. If not provided, a new object ID will be generated.
	 * @return A disposable which can be used to untrack the object and access the tracked object's ID and instance (when still tracked).
	 */
	track<T extends object>(instance: T, objectId?: string): TrackedObjectDisposable<T>;
	/**
	 * Gets the object ID of a tracked object.
	 * @param instance The tracked object instance.
	 * @returns The object ID of the tracked object, or null if the object is not tracked.
	 */
	getObjectId(instance: object): string | null;
	trackInternal(instance: object, objectId?: string): ObjectInfo | null;
	/**
	 * Untracks an object from synchronization.
	 * Untracked objects are no longer prevented from being deleted and will be removed from clients when they are no longer used by them.
	 * @param instance The instance to untrack.
	 * @return True if the instance was untracked, false if it was not being tracked as a root object.
	 */
	untrack(instance: object): boolean;
	/**
	 * Internal use only: Called by ObjectInfo.
	 */
	reportInstanceCreated(instance: object, objectId: string): void;
	/**
	 * Internal use only: Called by ObjectInfo.
	 */
	findSerializer(instanceOrTypeId: object | string): TypeSerializerConstructor;
	private handleCreateMessage;
	private handleOtherMessage;
	private handleDeleteMessage;
	serializeValue(value: any, clientToken: ClientToken): SerializedValue;
	deserializeValue(value: SerializedValue, clientToken: ClientToken): string | number | boolean | object | null | undefined;
	/**
	 * Applies messages from multiple clients asynchronously.
	 * That means that serializers can return promises which allows the feature to wait for method execution results for syncObject decorator targets.
	 * Messages are applied in a certain order:
	 * - First all create messages are applied in the order they are received, regardless of the client they come from.
	 *   This is to ensure that all objects are created before any changes are applied to them.
	 *   Some create messages may be used earlier than others if they are needed to create objects which are referenced by other messages,
	 *   but there is no guaranteed order between independent create messages.
	 * - Then change messages are applied in the order they are received.
	 * - Then execute messages are applied in the order they are received.
	 *
	 * @param messagesByClient A map of client connections to messages.
	 */
	applyMessagesAsync(messagesByClient: Map<ClientToken, Message[]>): Promise<void>;
	/**
	 * Applies messages from a client connection.
	 * @param messages The messages to apply.
	 * @param clientToken The client connection the messages are from.
	 */
	applyMessagesAsync(messages: Message[], clientToken: ClientToken): Promise<void>;
	private sortMessages;
	/**
	 * Clears internal states, which are needed to store changes between synchronization cycles. Should be called after messages have been collected for all clients.
	 */
	clearStates(): void;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states.
	 * @returns A map of client connections to messages.
	 */
	getMessages(): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clearNonClientStates: boolean): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states.
	 * @param clientToken The client connection to get messages for.
	 * @returns The messages for the specified client.
	 */
	getMessages(clientToken: ClientToken): Message[];
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clientToken The client connection to get messages for.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns The messages for the specified client.
	 */
	getMessages(clientToken: ClientToken, clearNonClientStates: boolean): Message[];
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states.
	 * @param clientTokens The client connections to get messages for.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clientTokens: ClientToken[]): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clientTokens The client connections to get messages for.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clientTokens: ClientToken[], clearNonClientStates: boolean): Map<ClientToken, Message[]>;
	private getMessagesForClients;
	/**
	 * Finds a tracked object by its object ID.
	 * @param objectId Object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findOne<T extends object>(objectId: string): T | undefined;
	/**
	 * Finds a tracked object by its constructor and optional object ID.
	 * @param constructor The constructor of the object type to find.
	 * @param objectId Optional object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findOne<T extends object>(constructor: Constructor<T>, objectId?: string): T | undefined;
	/**
	 * Finds all tracked objects of a specific type.
	 * @param constructor The constructor of the object type to find.
	 * @returns An array of found objects.
	 */
	findAll<T extends object>(constructor: Constructor<T>): T[];
	/**
	 * Exchanges messages with clients by sending messages and receiving client messages.
	 * @param settings Settings for exchanging messages.
	 */
	exchangeMessagesAsync(settings: ExchangeMessagesSettings): Promise<void>;
	/**
	 * Gets the dispatcher associated with a tracked object instance.
	 * A dispatcher is different for each kind of object and returned by its associated serializer.
	 * USe this to configure ninstance based serializer settings.
	 * @param instance The tracked object instance.
	 * @returns The dispatcher associated with the object instance, or null if none exists.
	 */
	getDispatcher<TDispatcher = null, TInstance extends object = any>(instance: TInstance): DispatcherOrFallback<TDispatcher, typeof instance> | null;
}
export declare class ObjectInfo<TInstance extends object = object> {
	private _owner;
	private _objectId;
	private _isRoot;
	private _serializer;
	private _instance;
	private _clientFilters;
	private _isOwned;
	private _referenceCountByClient;
	constructor(_owner: ObjectSync, _objectId?: string, instanceOrTypeId?: string | TInstance, _isRoot?: boolean);
	initializeSerializer(instanceOrTypeId?: string | TInstance): void;
	get isOwned(): boolean;
	set isOwned(value: boolean);
	get objectId(): string;
	get instance(): TInstance;
	set instance(value: TInstance);
	get isRoot(): boolean;
	set isRoot(value: boolean);
	get serializer(): TypeSerializer;
	get owner(): ObjectSync;
	addReference(clientToken?: ClientToken): IDisposable;
	get isOrphaned(): boolean;
	mustDeleteForClient(clientToken: ClientToken): boolean;
	private removeReference;
	setClientRestriction(filter: ClientTokenFilter): void;
	/**
	 * Determines if this object is visible to a given client based on filters.
	 */
	isForClientToken(clientToken: ClientToken): boolean;
	/**
	 * Removes all client restrictions, making the object visible to all clients.
	 */
	removeClientRestrictions(): void;
}
type ReferenceStorageSettings = {
	/**
	 * The key associated with the stored reference.
	 */
	key?: any;
	/**
	 * The client token for which to store the reference.
	 */
	clientToken?: ClientToken;
} & ({
	/**
	 * The value to store a reference for.
	 */
	value: any;
} | {
	/**
	 * The values to store references for.
	 */
	values: any[];
});
type SerializeAndReferenceStorageSettingsBase = {
	/**
	 * The key associated with the stored reference.
	 */
	key?: any;
	/**
	 * The client token for which to store the reference.
	 */
	clientToken: ClientToken;
};
type SingleSerializeAndReferenceStorageSettings = SerializeAndReferenceStorageSettingsBase & {
	/**
	 * The value to serialize and store a reference for.
	 */
	value: any;
};
type MultipleSerializeAndReferenceStorageSettings = SerializeAndReferenceStorageSettingsBase & {
	/**
	 * The values to serialize and store references for.
	 */
	values: any[];
};
export declare abstract class TypeSerializer<TInstance extends object = object, TCreatePayload = any, TChangePayload = any> {
	protected readonly _objectInfo: ObjectInfo<TInstance>;
	static canSerialize(instanceOrTypeId: object | string): boolean;
	private readonly _clients;
	private readonly _storedReferencesByKey;
	private _hasPendingChanges;
	constructor(_objectInfo: ObjectInfo<TInstance>);
	protected get hasPendingChanges(): boolean;
	protected set hasPendingChanges(value: boolean);
	get objectId(): string;
	/**
	 * The actual instance being serialized/deserialized.
	 * Can be null when not yet created (eg: The serializer has been created for a new object but the create message has not yet been handled).
	 * Must be set when the object is newly created (eg: when handling the create message).
	 */
	get instance(): TInstance;
	set instance(value: TInstance);
	onInstanceSet(createdByCreateObjectMessage: boolean): void;
	/**
	 * The clients this serializer is tracking.
	 */
	get clients(): Set<ClientToken>;
	/**
	 * Gets the type ID for the instance being serialized.
	 * @param clientToken The client token for which the type ID is requested. Can be used to return different type IDs based on the client.
	 */
	abstract getTypeId(clientToken: ClientToken): string | null;
	/**
	 * Called when a client is removed to allow the serializer to clean up any references related to the client.
	 * @param clientToken The client token being removed.
	 */
	onClientRemoved(clientToken: ClientToken): void;
	/**
	 * Clears the states for the serializer.
	 * @param clientToken Optional client token for which to clear the state. If not provided, clears the state not related to any specific client.
	 */
	clearStates(clientToken?: ClientToken): void;
	/**
	 * Reports to the owner that there are pending messages for the object.
	 * This will be implicitly called when setting hasPendingChanges to true. Or when the serializer is created with an existing instance.
	 */
	protected reportPendingMessages(): void;
	/**
	 * Serializes a value.
	 */
	protected serializeValue(value: any, clientToken: ClientToken): SerializedValue;
	/**
	 * Serializes a value and stores a reference if it's an object (basically converts any reference values to ObjectReferences and stores a reference for them).
	 * @param settings The settings for serializing and storing the reference.
	 * @returns The serialized value.
	 */
	protected serializeValue(settings: SingleSerializeAndReferenceStorageSettings): SerializedValue;
	/**
	 * Serializes a list of values and stores a reference if it's an object (basically converts any reference values to ObjectReferences and stores a reference for them).
	 * @param settings The settings for serializing and storing the reference.
	 * @returns The serialized values.
	 */
	protected serializeValue(settings: MultipleSerializeAndReferenceStorageSettings): SerializedValue[];
	/**
	 * Deserializes a value (basically converts any ObjectReferences to actual object references).
	 */
	protected deserializeValue(value: SerializedValue, clientToken: ClientToken): string | number | boolean | object | null | undefined;
	/**
	 * Generates messages to be sent to the client.
	 * @param clientToken The client token for which to generate messages.
	 * @param isNewClient Whether the client is new (ie: just connected).
	 * @returns An array of messages to be sent to the client.
	 */
	abstract generateMessages(clientToken: ClientToken, isNewClient: boolean): Message[];
	/**
	 * Applies a message to the serializer.
	 * Only create messages can never return a Promise.
	 * Only create messages must be handled by the serializer. All other messages can be ignored if not supported.
	 * @param message The message to apply.
	 * @param clientToken The client token identifying the client from which the message was received.
	 */
	abstract applyMessage(message: Message, clientToken: ClientToken): void | Promise<void>;
	/**
	 * Stores a reference to an object which will be used to keep track of references for serialization purposes.
	 * @param settings The settings for storing the reference.
	 * @returns A StoredReference which can be used to dispose the stored reference.
	 */
	protected storeReference(settings: ReferenceStorageSettings): IDisposable;
	/**
	 * Clears the stored references for all keys of a specific client.
	 * @param clientToken The client token for which to clear the stored references.
	 */
	protected clearStoredReferences(clientToken: ClientToken): void;
	/**
	 * Clears the stored references for a specific key of all clients.
	 * @param key The key for which to clear the stored references.
	 */
	protected clearStoredReferences(key: any): void;
	/**
	 * Clears the stored references for a specific key and client.
	 * @param key The key for which to clear the stored references.
	 * @param clientToken The client token for which to clear the stored references.
	 */
	protected clearStoredReferences(key: any, clientToken: ClientToken): void;
	/**
	 * Generates a create message for the instance being serialized, use this inside the generateMessages method when you want to generate a create message.
	 * @param type - "create"
	 * @param payload - The payload for the create message.
	 * @param typeId - The type ID for the create message.
	 * @returns A create message with the specified payload and type ID.
	 */
	protected createMessage(type: "create", payload: TCreatePayload, typeId: string): CreateObjectMessage<TCreatePayload>;
	/**
	 * Generates a create message for the instance being serialized, use this inside the generateMessages method when you want to generate a create message.
	 * @param type - "create"
	 * @param payload - The payload for the create message.
	 * @param clientToken - The client token for which to generate the create message (used to get the type ID).
	 * @return A create message with the specified payload and type ID.
	 */
	protected createMessage(type: "create", payload: TCreatePayload, clientToken: ClientToken): CreateObjectMessage<TCreatePayload>;
	/**
	 * Generates a change message, use this inside the generateMessages method when you want to generate a change message.
	 * @param type - "change"
	 * @param payload - The payload for the change message.
	 * @returns A change message with the specified payload.
	 */
	protected createMessage(type: "change", payload: TChangePayload): ChangeObjectMessage<TChangePayload>;
	/**
	 * Generates a message for the instance being serialized, use this inside the generateMessages method when you want to generate a message.
	 * @param type - The type of the message.
	 * @param payload - The payload for the message.
	 * @returns A message with the specified payload.
	 */
	protected createMessage<TMessage extends Message>(type: string, payload?: Omit<TMessage, "type" | "objectId">): TMessage;
	get dispatcher(): any;
}
export declare abstract class ExtendedTypeSerializer<TInstance extends object = object, TCreatePayload = any, TChangePayload = any> extends TypeSerializer<TInstance, TCreatePayload, TChangePayload> {
	private readonly _messageTypeToHandler;
	constructor(objectInfo: ObjectInfo<TInstance>);
	protected registerMessageHandler<TMessage extends Message>(messageType: string, handler: (message: TMessage, clientToken: ClientToken) => void | Promise<void>): void;
	applyMessage(message: Message, clientToken: ClientToken): void | Promise<void>;
	abstract onCreateMessageReceived(message: CreateObjectMessage<TCreatePayload>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TChangePayload>, clientToken: ClientToken): void;
}
export type TypeSerializerConstructor<TTypeSerializer extends TypeSerializer = TypeSerializer, TInstance extends object = any> = {
	new (objectInfo: ObjectInfo<TInstance>): TTypeSerializer;
	canSerialize(instanceOrTypeId: object | string): boolean;
};
type SimpleTypeSerializerSettings<TInstance extends object, TPayload = any> = {
	type: Constructor<TInstance>;
	typeId: string;
	serialize: (obj: TInstance) => TPayload;
	deserialize: (data: TPayload) => TInstance;
};
export declare function createSimpleTypeSerializerClass<TInstance extends object, TPayload = any>(settings: SimpleTypeSerializerSettings<TInstance, TPayload>): TypeSerializerConstructor;
export declare const nothing: unique symbol;
type CanTrackPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
};
type CanApplyPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	sourceClientToken: ClientToken;
};
type BeforeSendToClientPayload<T extends object, TKey extends keyof T & string, TValue> = {
	instance: T;
	key: TKey;
	value: TValue;
	destinationClientToken: ClientToken;
};
type TrackedPropertySettingsBase<T extends object> = {
	/**
	 * Returns true when the property/method should be tracked.
	 */
	canTrack?<TKey extends keyof T & string>(this: T, payload: CanTrackPayload<T, TKey>): boolean;
	/**
	 *  Returns true when the property/method change should be applied.
	 */
	canApply?<TKey extends keyof T & string>(this: T, payload: CanApplyPayload<T, TKey>): boolean;
	/**
	 * Defines how the property/method should be tracked/applied.
	 * - "trackAndApply": Changes to the property/method are tracked and applied (thats the default).
	 * - "trackOnly": Changes to the property/method are only tracked, not applied.
	 * - "applyOnly": Changes to the property/method are only applied, not tracked.
	 * - "none": Changes to the property/method are neither tracked nor applied.
	 */
	mode?: "trackAndApply" | "trackOnly" | "applyOnly" | "none";
};
type TrackedPropertySettings<T extends object, TValue> = TrackedPropertySettingsBase<T> & {
	/**
	 * Function which is called before sending the property value to the client.
	 * Can be used to modify or filter the value being sent.
	 * When the symbol value "nothing" is returned, the property update will be skipped.
	 */
	beforeSendToClient?<TKey extends keyof T & string>(this: T, payload: BeforeSendToClientPayload<T, TKey, TValue>): TValue | typeof nothing;
};
/**
 * Property accessor decorator for marking a property as trackable.
 * Registers the property and ensures changes are propagated to all TrackableObject instances.
 */
export declare function syncProperty<This extends object, Return>(settings?: TrackedPropertySettings<This, Return>): (target: ClassAccessorDecoratorTarget<This, Return>, context: ClassAccessorDecoratorContext<This, Return>) => ClassAccessorDecoratorResult<This, Return>;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type MethodReturnType<T extends object, K extends keyof T> = T[K] extends (...args: any[]) => infer U ? UnwrapPromise<U> : never;
export interface ISyncObjectDispatcher<TInstance extends object = object> {
	/**
	 * Invokes a method on all currently known clients.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A map of client tokens to promises of the method return values.
	 */
	invoke<TMethodName extends keyof TInstance>(method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Map<ClientToken, Promise<MethodReturnType<TInstance, TMethodName>>>;
	/**
	 * Invokes a method on the specified client.
	 * @param clientToken The client token to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A promise of the method return value.
	 */
	invoke<TMethodName extends keyof TInstance>(clientToken: ClientToken, method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Promise<MethodReturnType<TInstance, TMethodName>>;
	/**
	 * Invokes a method on multiple specified clients.
	 * @param clients Multiple client tokens to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A map of client tokens to promises of the method return values.
	 */
	invoke<TMethodName extends keyof TInstance>(clients: Iterable<ClientToken>, method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Map<ClientToken, Promise<MethodReturnType<TInstance, TMethodName>>>;
}
type BeforeExecuteOnClientPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	args: T[TKey] extends (...args: infer P) => any ? P : never;
	destinationClientToken: ClientToken;
};
type TrackedMethodSettings<T extends object> = TrackedPropertySettingsBase<T> & {
	/**
	 * Defines how method execution should handle returned Promises.
	 * - "await": The method call will be awaited, and the resolved value will be used or the rejection will be sent back to the client.
	 * - "normal": The Promise will be returned as-is without awaiting, once settled the result will be sent back to the client.
	 * If not set, the default behavior is "normal".
	 */
	promiseHandlingType?: "await" | "normal";
	/**
	 * Function which is called before sending the method execution call to the client.
	 * Can be used to prevent the method call from being sent.
	 * When false is returned, the method call will be skipped.
	 */
	beforeExecuteOnClient?<TKey extends keyof T & string>(this: T, payload: BeforeExecuteOnClientPayload<T, TKey>): boolean;
};
/**
 * Method decorator for marking a method as trackable.
 * Ensures method calls are recorded for all TrackableObject instances.
 */
export declare function syncMethod<This extends object, Return>(settings?: TrackedMethodSettings<This>): (target: any, context: ClassMethodDecoratorContext) => void;
type PossibleClientTypeResults = string | typeof nothing | Constructor | null;
type ConstructorArgumentsFunctionPayload<T extends object> = ClientTypeIdFunctionPayload<T>;
type ClientTypeIdFunctionPayload<T extends object> = {
	instance: T;
	constructor: Constructor<T>;
	typeId: string;
	destinationClientToken: ClientToken;
};
type TrackableObjectSettings<T extends object> = {
	typeId?: string;
	properties?: {
		[propertyKey: string]: TrackedPropertySettings<T, any>;
	};
	methods?: {
		[methodKey: string]: TrackedMethodSettings<T>;
	};
	/**
	 * Function which is called before sending the object to the client, or a string typeId.
	 * Can be used to modify or filter the typeId being sent.
	 * When the "nothing" symbol, null or undefined is returned, the object creation will be skipped.
	 */
	clientTypeId?: PossibleClientTypeResults | ((this: T, payload: ClientTypeIdFunctionPayload<T>) => PossibleClientTypeResults);
	/**
	 * Optional list of constructor argument names or a function that returns the constructor arguments for the object.
	 * If provided, this will be used to serialize the constructor arguments when creating the object on the client.
	 * If not provided, the default constructor will be used without arguments.
	 * When a function is provided, it can also return an object with propertiesToOmit to exclude certain properties from being serialized for the creation message.
	 */
	constructorArguments?: string[] | ((this: T, payload: ConstructorArgumentsFunctionPayload<T>) => string[] | {
		propertiesToOmit?: string[];
		arguments: any[];
	});
};
/**
 * Class decorator for marking a class as auto-trackable by the host.
 * Can be used as @syncObject or @syncObject("typeId").
 * Registers the class for automatic tracking and assigns a typeId if provided.
 */
export declare function syncObject<This extends abstract new (...args: any) => any>(settings?: TrackableObjectSettings<InstanceType<This>>): (target: This, context: ClassDecoratorContext<This>) => void;
type SpliceInstructionEx<T = any> = {
	start: number;
	deletedItems: T[];
	items: T[];
};
export declare class SyncableArray<T = any> extends Array<T> {
	constructor(...initialData: T[]);
	setLength(value: number): void;
	setAtIndex(index: number, value: T): boolean;
	splice(start: number, deleteCount?: number, ...items: T[]): T[];
	push(...items: T[]): number;
	pop(): T | undefined;
	shift(): T | undefined;
	unshift(...items: T[]): number;
	reverse(): any;
	sort(compareFn?: ((a: T, b: T) => number) | undefined): any;
	fill(value: T, start?: number, end?: number): any;
	copyWithin(target: number, start: number, end?: number): any;
	protected onSplice(spliceInstruction: SpliceInstructionEx<T>): void;
}
type SyncableObservableArrayEventMap = {
	added: (items: any[], start: number) => void;
	removed: (items: any[], start: number) => void;
};
export declare class SyncableObservableArray<T = any> extends SyncableArray<T> implements IEventEmitter<SyncableObservableArrayEventMap> {
	private readonly _eventEmitter;
	onSplice(spliceInstruction: SpliceInstructionEx<T>): void;
	on<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	once<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	off<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback?: SyncableObservableArrayEventMap[Event] | undefined): number;
}
export interface IArrayDispatcher<TElement = any> {
	/**
	 * Reports a splice operation on the array. Can be used to manually notify about changes (for plain Arrays).
	 * Will throw an error if arrayChangeSetMode is not set to "compareStates".
	 * @param spliceInstruction - The splice instruction describing the change.
	 */
	reportSplice(): void;
	/**
	 * Reports a splice operation on the array. Can be used to manually notify about changes (for plain Arrays).
	 * Will throw an error if arrayChangeSetMode is not set to "trackSplices".
	 * @param start - The start index of the splice.
	 * @param deleteCount - The number of items deleted.
	 * @param items - The items inserted.
	 */
	reportSplice(start: number, deleteCount: number, ...items: TElement[]): void;
	/**
	 * Gets or sets the array change set mode, default value is the value from the ObjectSync settings.
	 */
	changeSetMode: "trackSplices" | "compareStates";
}
export declare const SyncableObservableArraySerializer: TypeSerializerConstructor;
export declare const SyncableArraySerializer: TypeSerializerConstructor;
export declare const ArraySerializer: TypeSerializerConstructor;
export declare class SyncableMap<K = any, V = any> extends Map<K, V> {
	constructor(iterable?: Iterable<readonly [
		K,
		V
	]> | null);
	set(key: K, value: V): this;
	clear(): void;
	delete(key: K): boolean;
}
type SyncableObservableMapEventMap<K = any, V = any> = {
	set: (key: K, value: V) => void;
	cleared: () => void;
	deleted: (key: K) => void;
};
export declare class SyncableObservableMap<K = any, V = any> extends SyncableMap<K, V> implements IEventEmitter<SyncableObservableMapEventMap<K, V>> {
	private readonly _eventEmitter;
	set(key: K, value: V): this;
	clear(): void;
	delete(key: K): boolean;
	on<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback: SyncableObservableMapEventMap[Event]): void;
	once<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback: SyncableObservableMapEventMap[Event]): void;
	off<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback: SyncableObservableMapEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback?: SyncableObservableMapEventMap[Event] | undefined): number;
}
export interface IMapDispatcher<TKey = any, TValue = any> {
	reportClear(): void;
	reportDelete(key: TKey): void;
	reportChange(key: TKey, value: TValue): void;
}
export declare const SyncableObservableMapSerializer: TypeSerializerConstructor;
export declare const SyncableMapSerializer: TypeSerializerConstructor;
export declare const MapSerializer: TypeSerializerConstructor;
export declare class SyncableSet<V> extends Set<V> {
	constructor(iterable?: Iterable<V> | null);
	add(value: V): this;
	clear(): void;
	delete(value: V): boolean;
}
type SyncableObservableSetEventMap<T = any> = {
	added: (value: T) => void;
	cleared: () => void;
	deleted: (value: T) => void;
};
export declare class SyncableObservableSet<T = any> extends SyncableSet<T> implements IEventEmitter<SyncableObservableSetEventMap<T>> {
	private readonly _eventEmitter;
	add(value: T): this;
	clear(): void;
	delete(value: T): boolean;
	on<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback: SyncableObservableSetEventMap[Event]): void;
	once<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback: SyncableObservableSetEventMap[Event]): void;
	off<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback: SyncableObservableSetEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback?: SyncableObservableSetEventMap[Event] | undefined): number;
}
export interface ISetDispatcher<TValue = any> {
	reportClear(): void;
	reportDelete(value: TValue): void;
	reportAdd(value: TValue): void;
}
export declare const SyncableObservableSetSerializer: TypeSerializerConstructor;
export declare const SyncableSetSerializer: TypeSerializerConstructor;
export declare const SetSerializer: TypeSerializerConstructor;
type TInstance = object;
type TPayload = object;
export declare class ObjectSerializer extends ExtendedTypeSerializer<TInstance, TPayload> {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	getTypeId(clientToken: ClientToken): string;
	onInstanceSet(createdByCreateObjectMessage: boolean): void;
	onCreateMessageReceived(message: CreateObjectMessage<TPayload>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TPayload>, clientToken: ClientToken): void;
	generateMessages(clientToken: ClientToken, isNewClient: boolean): Message[];
	private getSerializedData;
}
export declare const defaultIntrinsicSerializers: TypeSerializerConstructor[];
export declare const defaultSerializersOrTypes: (TypeSerializerConstructor | Constructor)[];
type SyncSerializerSettings<TSerializer extends TypeSerializer> = {
	/**
	 * When provided will add a symbol to the type which tells it to use this serializer.
	 * You can then use the type in the ObjectSync creation settings as serializer.
	 */
	type?: Constructor;
} & ({
	/**
	 * Uses this type id then checking whether this serializer can serialize an object.
	 */
	typeId: string;
	/**
	 * Uses the provided type to check whether this serializer can serialize an object.
	 */
	type: Constructor;
} | {
	/**
	 * Custom canSerialize function.
	 * @param instanceOrTypeId An instance of the type or a type id.
	 * @returns Whether this serializer can serialize the provided instance or type id.
	 */
	canSerialize(instanceOrTypeId: object | string): boolean;
}) & ({
	/**
	 * Whether this serializer should be added to the default serializers list. Default is true.
	 */
	defaultSerializer?: boolean;
} | {
	/**
	 * Whether this serializer should be added to the default intrinsic serializers list. Default is false.
	 */
	defaultIntrinsicSerializer?: boolean;
});
export declare function syncSerializer<This extends new (...args: any) => TypeSerializer>(settings: SyncSerializerSettings<InstanceType<This>>): (target: This, context: ClassDecoratorContext<This>) => void;
export type StandaloneSerializationSettings = {
	/**
	 * Identity of the internal ObjectSync instance, defaults to "host".
	 */
	identity?: string;
	/**
	 * Identity of the internal client ObjectSync instance, defaults to "client".
	 */
	clientIdentity?: string;
	/**
	 * Type serializers to use for serializing and deserializing property values during synchronization.
	 * Can either be provided as an array of type serializers or constructors of SyncObject types.
	 * When constructors are provided, the corresponding internal TypeSerializer will be used.
	 * When not provided, all registered types and serializers will be used.
	 */
	serializers?: (TypeSerializerConstructor | Constructor)[];
	/**
	 * Intrinsic type serializers to use for serializing and deserializing base types (Array, Map, Set, Object) during synchronization.
	 * Can be provided as an array of type serializers.
	 * When not provided, default intrinsic type serializers will be used.
	 */
	intrinsicSerializers?: TypeSerializerConstructor[];
	/**
	 * Settings for generating object IDs.
	 * When not provided, a default generator with the identity as prefix will be used (eg: "host-1").
	 */
	objectIdGeneratorSettings?: ObjectIdGeneratorSettings;
};
/**
 * Serializes the given value into a string that can be deserialized later using `deserializeValue`.
 * @param value - The object to serialize.
 * @param settings - Optional settings for serialization.
 * @returns The serialized string representation of the object.
 */
export declare function serializeValue(value: any, settings?: StandaloneSerializationSettings): string;
/**
 * Deserializes the given string back into an object that was previously serialized using `serializeValue`.
 * @param data - The serialized string representation of the object.
 * @param settings - Optional settings for deserialization.
 * @returns The deserialized object.
 */
export declare function deserializeValue<TValue = any>(data: string, settings?: StandaloneSerializationSettings): TValue;

export {};
