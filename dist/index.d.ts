// Generated by dts-bundle-generator v9.5.1

/**
 * Settings for a client connection.
 */
export type ClientConnectionSettings = {
	/**
	 * Identity of the client (e.g., "host", "client1", etc.).
	 */
	identity: string;
};
/**
 * Representation of a connection to a client.
 */
export declare class ClientToken {
	readonly identity: string;
	constructor(identity: string);
}
type PrimitiveValue = {
	value: string | number | boolean | null | undefined;
};
type ObjectReference = {
	objectId: string;
	typeId: string;
};
export type SerializedValue = PrimitiveValue | ObjectReference | undefined;
export declare const CreateMessageType = "create";
export declare const ChangeMessageType = "change";
export declare const DeleteMessageType = "delete";
export declare const ExecuteMessageType = "execute";
export declare const ExecuteFinishedMessageType = "executeFinished";
export type Message = {
	type: string;
	objectId: string;
};
export type CreateObjectMessage<TPayload = any> = Message & {
	type: typeof CreateMessageType;
	typeId: string;
	data: TPayload;
	isRoot?: boolean;
};
export type ChangeObjectMessage<TPayload = any> = Message & {
	type: typeof ChangeMessageType;
	data: TPayload;
};
export type DeleteObjectMessage = Message & {
	type: typeof DeleteMessageType;
};
export type ExecuteObjectMessage<TInstance extends object = any, TMethodName extends string & keyof TInstance = any> = Message & {
	type: typeof ExecuteMessageType;
	invokeId: unknown;
	method: TMethodName;
	parameters: SerializedValue[];
};
export type ExecuteFinishedObjectMessage = Message & {
	type: typeof ExecuteFinishedMessageType;
	invokeId: unknown;
	error?: any;
	result?: any;
};
export declare function isExecuteObjectMessage(message: Message): message is ExecuteObjectMessage;
export declare function isChangeObjectMessage(message: Message): message is ChangeObjectMessage;
export declare function isCreateObjectMessage(message: Message): message is CreateObjectMessage;
export declare function isDeleteObjectMessage(message: Message): message is DeleteObjectMessage;
export declare function isExecuteFinishedObjectMessage(message: Message): message is ExecuteFinishedObjectMessage;
type EventFunction = (...args: any[]) => void;
type EventMap = {
	[key: string]: EventFunction;
};
export type IEventEmitter<Events extends EventMap = EventMap> = {
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event] | undefined): number;
};
export declare class EventEmitter<Events extends EventMap = EventMap> implements IEventEmitter<Events> {
	readonly _events: {
		[key in keyof Events]?: EventFunction[];
	};
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event]): number;
	emit<Event extends keyof Events>(event: Event, ...args: any[]): void;
	protected onEventListenerAdded<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	protected onEventListenerRemoved<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
}
type OneOrMany<T> = T | Iterable<T>;
type Constructor<T = any> = {
	new (...args: any[]): T;
};
interface IDisposable {
	dispose(): void;
	[Symbol.dispose](): void;
}
type ClientTokenFilter = {
	/**
	 * Set of clients to include or exclude
	 */
	clientTokens?: OneOrMany<ClientToken>;
	/**
	 * Set of client identities to include or exclude
	 */
	identities?: OneOrMany<string>;
	/**
	 * If true, only the specified clients are included; if false, they are excluded, default is true
	 */
	isExclusive?: boolean;
};
export type MemoryManagementMode = "weak" | "byClient";
export type ArrayChangeSetMode = "trackSplices" | "compareStates";
type ExchangeMessagesSettings = {
	/**
	 * Optional function to handle errors that occur during message exchange.
	 * @param clientToken The client connection where the error occurred.
	 * @param error The error that occurred.
	 */
	errorHandler?: (clientToken: ClientToken, error: any) => void;
	/**
	 * Optional function to filter messages sent to or received from clients.
	 * Warning: Using this filter may lead to inconsistent states between server and clients if messages are blocked.
	 * You can use it to implement custom logic, such as ignoring certain messages for specific clients.
	 * @param clientToken The client connection involved in the message exchange.
	 * @param message The message being sent or received.
	 * @param isIncoming True if the message is incoming to the server, false if outgoing.
	 * @returns True to allow the message, false to block it.
	 */
	clientMessageFilter?: (clientToken: ClientToken, message: Message, isIncoming: boolean) => boolean;
	/**
	 * Clients to exchange messages with. If not provided, messages will be exchanged with all registered clients.
	 */
	clients?: ClientToken[];
} & ({
	/**
	 * Function to send messages to a single client and receive client messages back as results.
	 * @param clientToken The client connection to send messages to.
	 * @param messages The messages to send to the client.
	 * @returns A promise that resolves to the messages received from the client.
	 */
	sendToClientAsync: (clientToken: ClientToken, messages: Message[]) => Promise<Message[]>;
} | {
	/**
	 * Function to send messages to multiple clients and receive client messages back as results.
	 * @param messagesByClientToken A map of client connections to messages to send.
	 * @returns A promise that resolves to a map of client connections to messages received from the clients.
	 */
	sendToClientsAsync: (messagesByClientToken: Map<ClientToken, Message[]>) => Promise<Map<ClientToken, Message[]>>;
});
export type ObjectIdGeneratorSettings = {
	/**
	 * Function to generate an object ID..
	 * @param value
	 */
	generateId(value?: object): string;
} | {
	/**
	 * Prefix to use for generated object IDs.
	 */
	prefix: string;
};
export type FinalizedObjectSyncSettings = {
	identity: string;
	objectIdGeneratorSettings: ObjectIdGeneratorSettings;
	arrayChangeSetMode: ArrayChangeSetMode;
	memoryManagementMode: MemoryManagementMode;
};
export type ObjectSyncSettings = {
	/**
	 * Identity of this ObjectSync instance (e.g., "host" or "client1").
	 */
	identity: string;
	/**
	 * Type sync agents to use for serializing and deserializing property values during synchronization.
	 * Can either be provided as an array of type sync agents or constructors of SyncObject types.
	 * When constructors are provided, the corresponding internal TypeSyncAgent will be used.
	 * When not provided, all registered types and sync agents will be used.
	 */
	types?: (SyncAgentProvider | Constructor)[];
	/**
	 * Intrinsic type sync agents to use for serializing and deserializing base types (Array, Map, Set, Object) during synchronization.
	 * Can be provided as an array of type sync agents.
	 * When not provided, default intrinsic type sync agents will be used.
	 */
	intrinsics?: (SyncAgentProvider | Constructor)[];
	/**
	 * Settings for generating object IDs.
	 * When not provided, a default generator with the identity as prefix will be used (eg: "host-1").
	 */
	objectIdGeneratorSettings?: ObjectIdGeneratorSettings;
	/**
	 * Defines how array changes are tracked and serialized.
	 * - "trackSplices": Uses splice instructions to record changes. More efficient for small changes. May transfer data which will be removed with a later splice.
	 * - "compareStates": gathers splice data by comparing the old array state to the new array state. More efficient for large changes. (Default)
	 */
	arrayChangeSetMode?: ArrayChangeSetMode;
	/**
	 * Specifies the memory management mode the ObjectSync instance should use.
	 * "weak": Uses WeakRefs to track object lifetimes. Delete messages will be sent when objects are garbage collected.
	 * "byClient" (default): Delete messages will be sent when objects are no longer used by a connected client.
	 */
	memoryManagementMode?: MemoryManagementMode;
	/**
	 * Optional list of types which the sender may send to this ObjectSync instance as root objects. This is a security measure to prevent clients from sending unexpected types which may be used to cause issues on the receiving end (e.g., by sending very large objects or objects with getters that execute expensive code). If not set, all types provided by sync agents will be allowed as root types.
	 */
	allowedRootTypesFromClient?: Constructor[];
};
declare class SyncAgentProviders {
	private readonly commonAgentProviders;
	private readonly intrinsicsAgentProviders;
	constructor(settings: ObjectSyncSettings);
	get all(): SyncAgentProvider[];
	get common(): SyncAgentProvider[];
	get intrinsics(): SyncAgentProvider[];
	findOrThrow(instanceOrTypeId: object | string): SyncAgentProvider;
	find(instanceOrTypeId: object | string): SyncAgentProvider | null;
}
declare class ObjectsView {
	private readonly _core;
	private readonly _predicate?;
	constructor(_core: ObjectSyncCore, _predicate?: ((info: ObjectInfo) => boolean) | undefined);
	protected get core(): ObjectSyncCore;
	/**
	 * Finds a tracked object by its object ID.
	 * @param objectId Object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findOne<T extends object>(objectId: string): T | undefined;
	/**
	 * Finds a tracked object by its constructor and optional object ID.
	 * @param constructor The constructor of the object type to find.
	 * @param objectId Optional object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findOne<T extends object>(constructor: Constructor<T>, objectId?: string): T | undefined;
	/**
	 * Finds all tracked objects of a specific type.
	 * @param constructor The constructor of the object type to find.
	 * @returns An array of found objects.
	 */
	findAll<T extends object>(constructor: Constructor<T>): T[];
	/**
	 * Finds all tracked objects.
	 */
	get all(): object[];
}
declare class RootObjectsView extends ObjectsView {
	private _allowedRootTypes;
	constructor(core: ObjectSyncCore);
	/**
	 * Gets or sets the allowed root types that can be transmitted by a client. If not set, all types provided by sync agents will be allowed as root types.
	 */
	get allowedRootTypesFromClient(): Constructor[] | undefined;
	set allowedRootTypesFromClient(types: Constructor[] | undefined);
	/**
	 * Checks if a type is allowed to be tracked as a root object when transmitted by a client. This checks if there is a sync agent provider for the type and if the type is included in the allowed root types (if specified).
	 */
	isTypeFromClientAllowed(constructorOrTypeId: Constructor | string): boolean;
}
export type TrackedObjectDisposable<TInstance extends object> = IDisposable & {
	readonly objectId: string;
	readonly instance: TInstance | undefined;
};
type SyncAgentType<TInstance> = TInstance extends Array<infer TItem> ? IArraySyncAgent<TItem> : TInstance extends Set<infer TItem> ? ISetSyncAgent<TItem> : TInstance extends Map<infer TKey, infer TValue> ? IMapSyncAgent<TKey, TValue> : TInstance extends object ? ISyncObjectSyncAgent<TInstance> : never;
type SyncAgentOrFallback<TDispatcher extends ISyncAgent | null, TInstance> = TDispatcher extends null ? SyncAgentType<TInstance> : TDispatcher;
type ObjectSyncEventMap = {
	tracked(instance: object, syncAgent: ISyncAgent): void;
};
declare class ObjectSyncCore extends EventEmitter<ObjectSyncEventMap> {
	private readonly _objectPool;
	private readonly _weakObjectPool;
	private readonly _objectsWithPendingMessages;
	private readonly _clients;
	private readonly _settings;
	private readonly _pendingWeakDeletes;
	private _nextObjectId;
	private _pendingCreateMessageByObjectId;
	private readonly _ownClientToken;
	private readonly _syncAgentProviders;
	private readonly _allObjects;
	private readonly _rootObjects;
	private readonly _pendingPromise;
	constructor(settings: ObjectSyncSettings);
	get allObjects(): ObjectsView;
	get rootObjects(): RootObjectsView;
	get settings(): FinalizedObjectSyncSettings;
	get arrayChangeSetMode(): ArrayChangeSetMode;
	reportPendingMessagesForObject(objectInfo: ObjectInfo): void;
	generateObjectId(value?: object): string;
	registerClient(settingsOrIdentity: ClientConnectionSettings | string): ClientToken;
	get registeredClientTokens(): ClientToken[];
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	unregisterClient(clientToken: ClientToken): void;
	/**
	 * Gets the identity of this ObjectSync instance.
	 */
	get identity(): string;
	get syncAgentProviders(): SyncAgentProviders;
	/**
	 * Tracks an object for synchronization.
	 * Must be called for root objects you want to track. Tracked root objects will never be automatically deleted.
	 * @param instance The instance to track.
	 * @param objectId Optional object ID to use for the tracked object. If not provided, a new object ID will be generated.
	 * @return A disposable which can be used to untrack the object and access the tracked object's ID and instance (when still tracked).
	 */
	track<T extends object>(instance: T, objectId?: string): TrackedObjectDisposable<T>;
	trackInternal(instance: object, objectId?: string): ObjectInfo | null;
	/**
	 * Untracks an object from synchronization.
	 * Untracked objects are no longer prevented from being deleted and will be removed from clients when they are no longer used by them.
	 * @param instance The instance to untrack.
	 * @return True if the instance was untracked, false if it was not being tracked as a root object.
	 */
	untrack(instance: object): boolean;
	/**
	 * Internal use only: Called by ObjectInfo.
	 */
	reportInstanceCreated(instance: object, objectId: string): void;
	private handleCreateMessage;
	private handleOtherMessage;
	private handleDeleteMessage;
	serializeValue(value: any, clientToken: ClientToken): SerializedValue;
	private checkIsTypeAllowed;
	deserializeValue(value: SerializedValue, clientToken: ClientToken, allowedTypes?: (Constructor | undefined | null)[]): string | number | boolean | object | null | undefined;
	applyMessagesAsync(messagesOrMessagesByClient: Message[] | Map<ClientToken, Message[]>, clientToken?: ClientToken): Promise<void>;
	applyMessages(messagesOrMessagesByClient: Message[] | Map<ClientToken, Message[]>, clientToken?: ClientToken): Promise<any>[];
	private sortMessages;
	/**
	 * Clears internal states, which are needed to store changes between synchronization cycles. Should be called after messages have been collected for all clients.
	 */
	clearStates(): void;
	getMessages(clientOrClientsOrCallTick?: boolean | OneOrMany<ClientToken>, clearNonClientStates?: boolean): Map<ClientToken, Message[]> | Message[];
	private getMessagesForClients;
	findOne<T extends object>(constructorOrObjectId: Constructor<T> | string, objectId?: string, predicate?: (info: ObjectInfo) => boolean): T | undefined;
	/**
	 * Finds all tracked objects of a specific type.
	 * @param constructor The constructor of the object type to find.
	 * @returns An array of found objects.
	 */
	findAll<T extends object>(constructor?: Constructor<T>, predicate?: (info: ObjectInfo) => boolean): T[];
	/**
	 * Exchanges messages with clients by sending messages and receiving client messages.
	 * @param settings Settings for exchanging messages.
	 */
	exchangeMessagesAsync(settings: ExchangeMessagesSettings): Promise<void>;
	/**
	 * Gets the dispatcher associated with a tracked object instance.
	 * A dispatcher is different for each kind of object and returned by its associated serializer.
	 * USe this to configure ninstance based serializer settings.
	 * @param instance The tracked object instance.
	 * @returns The dispatcher associated with the object instance, or null if none exists.
	 */
	getSyncAgent<TDispatcher extends ISyncAgent | null = null, TInstance extends object = any>(instance: TInstance): SyncAgentOrFallback<TDispatcher, typeof instance>;
	getSyncAgentOrNull(instance: any): ISyncAgent | null;
	registerPendingPromise(promise: Promise<any>): void;
	private awaitPendingPromises;
}
export declare class ObjectInfo<TInstance extends object = object> {
	private _owner;
	private _objectId;
	private _isRoot;
	private _syncAgent;
	private _instance;
	private _isOwned;
	private _referenceCountByClient;
	constructor(_owner: ObjectSyncCore, _objectId?: string, instanceOrTypeId?: string | TInstance, _isRoot?: boolean);
	initializeSyncAgent(instanceOrTypeId?: string | TInstance): void;
	get isOwned(): boolean;
	set isOwned(value: boolean);
	get objectId(): string;
	get instance(): TInstance;
	set instance(value: TInstance);
	get isRoot(): boolean;
	set isRoot(value: boolean);
	get syncAgent(): SyncAgent;
	get owner(): ObjectSyncCore;
	addReference(clientToken?: ClientToken): IDisposable;
	get isOrphaned(): boolean;
	mustDeleteForClient(clientToken: ClientToken): boolean;
	private removeReference;
}
type ReferenceStorageSettings = {
	/**
	 * The key associated with the stored reference.
	 */
	key?: any;
	/**
	 * The client token for which to store the reference.
	 */
	clientToken?: ClientToken;
} & ({
	/**
	 * The value to store a reference for.
	 */
	value: any;
} | {
	/**
	 * The values to store references for.
	 */
	values: any[];
});
type SerializeAndReferenceStorageSettingsBase = {
	/**
	 * The key associated with the stored reference.
	 */
	key?: any;
	/**
	 * The client token for which to store the reference.
	 */
	clientToken: ClientToken;
};
type SingleSerializeAndReferenceStorageSettings = SerializeAndReferenceStorageSettingsBase & {
	/**
	 * The value to serialize and store a reference for.
	 */
	value: any;
};
type MultipleSerializeAndReferenceStorageSettings = SerializeAndReferenceStorageSettingsBase & {
	/**
	 * The values to serialize and store references for.
	 */
	values: any[];
};
type ISyncAgent<TInstance extends object = any> = {
	/**
	 * The ID of the object being synchronized.
	 */
	get objectId(): string;
	/**
	 * The actual instance being synchronized.
	 */
	get instance(): TInstance;
	/**
	 * The clients for which this agent is tracking the object.
	 */
	get clients(): Set<ClientToken>;
	/**
	 * Gets or sets a client restriction filter.
	 * With this you can remove an object from beeing tracked for a specific client or group of clients, or make it only tracked for a specific client or group of clients.
	 */
	clientRestriction: ClientTokenFilter | null;
};
export declare abstract class SyncAgent<TInstance extends object = object, TCreatePayload = any, TChangePayload = any> implements ISyncAgent {
	protected readonly _objectInfo: ObjectInfo<TInstance>;
	private readonly _clients;
	private readonly _storedReferencesByKey;
	private _hasPendingChanges;
	private _clientFilters;
	constructor(_objectInfo: ObjectInfo<TInstance>);
	protected get hasPendingChanges(): boolean;
	protected set hasPendingChanges(value: boolean);
	get objectId(): string;
	/**
	 * The actual instance being serialized/deserialized.
	 * Can be null when not yet created (eg: The serializer has been created for a new object but the create message has not yet been handled).
	 * Must be set when the object is newly created (eg: when handling the create message).
	 */
	get instance(): TInstance;
	set instance(value: TInstance);
	onInstanceSet(createdByCreateObjectMessage: boolean): void;
	/**
	 * The clients this serializer is tracking.
	 */
	get clients(): Set<ClientToken>;
	/**
	 * Gets the type ID for the instance being serialized.
	 * @param clientToken The client token for which the type ID is requested. Can be used to return different type IDs based on the client.
	 */
	abstract getTypeId(clientToken: ClientToken): string | null;
	/**
	 * Called when a client is removed to allow the serializer to clean up any references related to the client.
	 * @param clientToken The client token being removed.
	 */
	onClientUnregistered(clientToken: ClientToken): void;
	/**
	 * Clears the states for the serializer.
	 * @param clientToken Optional client token for which to clear the state. If not provided, clears the state not related to any specific client.
	 */
	clearStates(clientToken?: ClientToken): void;
	/**
	 * Reports to the owner that there are pending messages for the object.
	 * This will be implicitly called when setting hasPendingChanges to true. Or when the serializer is created with an existing instance.
	 */
	protected reportPendingMessages(): void;
	/**
	 * Serializes a value.
	 */
	protected serializeValue(value: any, clientToken: ClientToken): SerializedValue;
	/**
	 * Serializes a value and stores a reference if it's an object (basically converts any reference values to ObjectReferences and stores a reference for them).
	 * @param settings The settings for serializing and storing the reference.
	 * @returns The serialized value.
	 */
	protected serializeValue(settings: SingleSerializeAndReferenceStorageSettings): SerializedValue;
	/**
	 * Serializes a list of values and stores a reference if it's an object (basically converts any reference values to ObjectReferences and stores a reference for them).
	 * @param settings The settings for serializing and storing the reference.
	 * @returns The serialized values.
	 */
	protected serializeValue(settings: MultipleSerializeAndReferenceStorageSettings): SerializedValue[];
	/**
	 * Deserializes a value (basically converts any ObjectReferences to actual object references).
	 */
	protected deserializeValue(value: SerializedValue, clientToken: ClientToken, allowedTypes?: (Constructor | undefined | null)[]): string | number | boolean | object | null | undefined;
	/**
	 * Generates messages to be sent to the client.
	 * @param clientToken The client token for which to generate messages.
	 * @param isNewClient Whether the client is new (ie: just connected).
	 * @returns An array of messages to be sent to the client.
	 */
	abstract generateMessages(clientToken: ClientToken, isNewClient: boolean): Message[];
	/**
	 * Applies a message to the serializer.
	 * Only create messages can never return a Promise.
	 * Only create messages must be handled by the serializer. All other messages can be ignored if not supported.
	 * @param message The message to apply.
	 * @param clientToken The client token identifying the client from which the message was received.
	 */
	abstract applyMessage(message: Message, clientToken: ClientToken): void | Promise<void>;
	/**
	 * Stores a reference to an object which will be used to keep track of references for serialization purposes.
	 * @param settings The settings for storing the reference.
	 * @returns A StoredReference which can be used to dispose the stored reference.
	 */
	protected storeReference(settings: ReferenceStorageSettings): IDisposable;
	/**
	 * Clears the stored references for all keys of a specific client.
	 * @param clientToken The client token for which to clear the stored references.
	 */
	protected clearStoredReferences(clientToken: ClientToken): void;
	/**
	 * Clears the stored references for a specific key of all clients.
	 * @param key The key for which to clear the stored references.
	 */
	protected clearStoredReferences(key: any): void;
	/**
	 * Clears the stored references for a specific key and client.
	 * @param key The key for which to clear the stored references.
	 * @param clientToken The client token for which to clear the stored references.
	 */
	protected clearStoredReferences(key: any, clientToken: ClientToken): void;
	/**
	 * Generates a create message for the instance being serialized, use this inside the generateMessages method when you want to generate a create message.
	 * @param type - "create"
	 * @param payload - The payload for the create message.
	 * @param typeId - The type ID for the create message.
	 * @returns A create message with the specified payload and type ID.
	 */
	protected createMessage(type: "create", payload: TCreatePayload, typeId: string): CreateObjectMessage<TCreatePayload>;
	/**
	 * Generates a create message for the instance being serialized, use this inside the generateMessages method when you want to generate a create message.
	 * @param type - "create"
	 * @param payload - The payload for the create message.
	 * @param clientToken - The client token for which to generate the create message (used to get the type ID).
	 * @return A create message with the specified payload and type ID.
	 */
	protected createMessage(type: "create", payload: TCreatePayload, clientToken: ClientToken): CreateObjectMessage<TCreatePayload>;
	/**
	 * Generates a change message, use this inside the generateMessages method when you want to generate a change message.
	 * @param type - "change"
	 * @param payload - The payload for the change message.
	 * @returns A change message with the specified payload.
	 */
	protected createMessage(type: "change", payload: TChangePayload): ChangeObjectMessage<TChangePayload>;
	/**
	 * Generates a message for the instance being serialized, use this inside the generateMessages method when you want to generate a message.
	 * @param type - The type of the message.
	 * @param payload - The payload for the message.
	 * @returns A message with the specified payload.
	 */
	protected createMessage<TMessage extends Message>(type: string, payload?: Omit<TMessage, "type" | "objectId">): TMessage;
	set clientRestriction(filter: ClientTokenFilter | null);
	get clientRestriction(): ClientTokenFilter | null;
	isForClientToken(clientToken: ClientToken): boolean;
}
export declare const defaultSyncAgentProviders: SyncAgentProvider[];
export declare const defaultIntrinsicSyncAgentProviders: SyncAgentProvider[];
type SyncAgentConstructor = new (objectInfo: ObjectInfo<any>) => SyncAgent;
type SyncAgentProviderSettings = {
	/**
	 * The type of the SyncAgent that should be instanciated for the given syncType. This is used to determine which SyncAgent to use when creating a new SyncAgent for an object of the given syncType.
	 */
	syncAgentType: SyncAgentConstructor;
	/**
	 * The type that this SyncAgent can be used for. When creating a new SyncAgent for an object, the SyncAgentProvider will be asked if it can provide a SyncAgent for the object's type (or one of its base types). The first SyncAgentProvider that returns true will be used to create the SyncAgent for the object.
	 */
	syncType: Constructor;
	/**
	 * The typeId that this SyncAgent can be used for. This is used to determine which SyncAgent to use when deserializing an object from a message that contains a typeId. The first SyncAgentProvider that returns true for the typeId will be used to create the SyncAgent for the object.
	 */
	typeId: string;
	/**
	 * If true, the SyncAgentProvider will only be used for objects that are exactly of the syncType. If false or undefined, the SyncAgentProvider will be used for objects that are of the syncType or any of its subtypes. The default is false.
	 */
	matchExactType?: boolean;
	/**
	 * Whether this SyncAgentProvider should be added to the default intrinsic SyncAgentProviders list. Default is false. Intrinsic SyncAgentProviders are used by default when creating SyncAgents for objects, and are checked after non-intrinsic SyncAgentProviders.
	 */
	isIntrinsic?: boolean;
	/**
	 * The priority of the SyncAgentProvider. When multiple SyncAgentProviders can provide a SyncAgent for a given type or typeId, the one with the highest priority will be used. The default priority is 0.
	 */
	priority?: number;
};
declare class SyncAgentProvider {
	private readonly _settings;
	constructor(_settings: SyncAgentProviderSettings);
	get priority(): number;
	get syncType(): Constructor;
	canProvideAgentFor(typeOrTypeId: object | string): boolean;
	createAgent(objectInfo: ObjectInfo): SyncAgent;
}
export declare abstract class ExtendedSyncAgent<TInstance extends object = object, TCreatePayload = any, TChangePayload = any> extends SyncAgent<TInstance, TCreatePayload, TChangePayload> {
	private readonly _messageTypeToHandler;
	private _isApplyingMessages;
	constructor(objectInfo: ObjectInfo<TInstance>);
	protected get isApplyingMessages(): boolean;
	protected registerMessageHandler<TMessage extends Message>(messageType: string, handler: (message: TMessage, clientToken: ClientToken) => void): void;
	applyMessage(message: Message, clientToken: ClientToken): void;
	abstract onCreateMessageReceived(message: CreateObjectMessage<TCreatePayload>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TChangePayload>, clientToken: ClientToken): void;
}
type SimpleTypeSyncAgentSettings<TInstance extends object, TPayload = any> = {
	type: Constructor<TInstance>;
	typeId: string;
	serialize: (obj: TInstance) => TPayload;
	deserialize: (data: TPayload) => TInstance;
};
export declare function createSimpleSyncAgentProvider<TInstance extends object, TPayload = any>(settings: SimpleTypeSyncAgentSettings<TInstance, TPayload>): SyncAgentProvider;
export declare const nothing: unique symbol;
type CanTrackPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
};
type CanApplyPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	sourceClientToken: ClientToken;
};
type BeforeSendToClientPayload<T extends object, TKey extends keyof T & string, TValue> = {
	instance: T;
	key: TKey;
	value: TValue;
	destinationClientToken: ClientToken;
};
type AfterValueChangedPayload<T extends object, TKey extends keyof T & string, TValue> = {
	instance: T;
	key: TKey;
	value: TValue;
	sourceClientToken: ClientToken | null;
	syncAgent: ISyncAgent | null;
};
type TrackedPropertySettingsBase<T extends object> = {
	/**
	 * Returns true when the property/method should be tracked.
	 */
	canTrack?<TKey extends keyof T & string>(this: T, payload: CanTrackPayload<T, TKey>): boolean;
	/**
	 *  Returns true when the property/method change should be applied.
	 */
	canApply?<TKey extends keyof T & string>(this: T, payload: CanApplyPayload<T, TKey>): boolean;
	/**
	 * Defines how the property/method should be tracked/applied.
	 * - "trackAndApply": Changes to the property/method are tracked and applied (thats the default).
	 * - "trackOnly": Changes to the property/method are only tracked, not applied.
	 * - "applyOnly": Changes to the property/method are only applied, not tracked.
	 * - "none": Changes to the property/method are neither tracked nor applied.
	 */
	mode?: "trackAndApply" | "trackOnly" | "applyOnly" | "none";
};
type TrackedPropertySettings<T extends object, TValue> = TrackedPropertySettingsBase<T> & {
	/**
	 * Function which is called before sending the property value to the client.
	 * Can be used to modify or filter the value being sent.
	 * When the symbol value "nothing" is returned, the property update will be skipped.
	 */
	beforeSendToClient?<TKey extends keyof T & string>(this: T, payload: BeforeSendToClientPayload<T, TKey, TValue>): TValue | typeof nothing;
	/**
	 * List of allowed types which can be assigned from the sender.
	 * When a value of a different type is assigned from the sender, the application will throw an error.
	 * When not provided, all types are allowed.
	 */
	allowedTypesFromSender?: Array<Constructor | null | undefined>;
	/**
	 * Function which is called after the property value has been applied from a client.
	 */
	afterValueChanged?<TKey extends keyof T & string>(this: T, payload: AfterValueChangedPayload<T, TKey, TValue>): void;
};
/**
 * Property accessor decorator for marking a property as trackable.
 * Registers the property and ensures changes are propagated to all TrackableObject instances.
 */
export declare function syncProperty<This extends object, Return>(settings?: TrackedPropertySettings<This, Return>): (target: ClassAccessorDecoratorTarget<This, Return>, context: ClassAccessorDecoratorContext<This, Return>) => ClassAccessorDecoratorResult<This, Return>;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type MethodReturnType<T extends object, K extends keyof T> = T[K] extends (...args: any[]) => infer U ? UnwrapPromise<U> : never;
export interface ISyncObjectSyncAgent<TInstance extends object = object> extends ISyncAgent<TInstance> {
	/**
	 * Invokes a method on all currently known clients.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A map of client tokens to promises of the method return values.
	 */
	invoke<TMethodName extends keyof TInstance>(method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Map<ClientToken, Promise<MethodReturnType<TInstance, TMethodName>>>;
	/**
	 * Invokes a method on the specified client.
	 * @param clientToken The client token to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A promise of the method return value.
	 */
	invoke<TMethodName extends keyof TInstance>(clientToken: ClientToken, method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Promise<MethodReturnType<TInstance, TMethodName>>;
	/**
	 * Invokes a method on multiple specified clients.
	 * @param clients Multiple client tokens to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A map of client tokens to promises of the method return values.
	 */
	invoke<TMethodName extends keyof TInstance>(clients: Iterable<ClientToken>, method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Map<ClientToken, Promise<MethodReturnType<TInstance, TMethodName>>>;
}
type BeforeExecuteOnClientPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	args: T[TKey] extends (...args: infer P) => any ? P : never;
	destinationClientToken: ClientToken;
};
type TrackedMethodSettings<T extends object> = TrackedPropertySettingsBase<T> & {
	/**
	 * Defines how method execution should handle returned Promises.
	 * - "await": The method call will be awaited, and the resolved value will be used or the rejection will be sent back to the client.
	 * - "normal": The Promise will be returned as-is without awaiting, once settled the result will be sent back to the client.
	 * If not set, the default behavior is "normal".
	 */
	promiseHandlingType?: "await" | "normal";
	/**
	 * Function which is called before sending the method execution call to the client.
	 * Can be used to prevent the method call from being sent.
	 * When false is returned, the method call will be skipped.
	 */
	beforeExecuteOnClient?<TKey extends keyof T & string>(this: T, payload: BeforeExecuteOnClientPayload<T, TKey>): boolean;
	/**
	 * List of allowed types which can be returned from the sender to the receiver.
	 * When a value of a different type is returned from the sender, the application will throw an error.
	 * When not provided, all types are allowed.
	 */
	allowedReturnTypesFromSender?: Array<Constructor | null | undefined>;
	/**
	 * List of allowed types which can be returned from the sender to the receiver as a rejection reason.
	 * When a value of a different type is returned from the sender, the application will throw an error.
	 * When not provided, all types are allowed.
	 */
	allowedRejectionTypesFromSender?: Array<Constructor | null | undefined>;
	/**
	 * List of allowed types which can be assigned to the method parameters from the sender.
	 * When a value of a different type is assigned from the sender, the method invocation will return an error.
	 * When not provided, all types are allowed.
	 * The array index corresponds to the method parameter index. If a parameter index is missing, no types are allowed for that parameter.
	 */
	allowedParameterTypesFromSender?: Array<Array<Constructor | null | undefined>>;
};
/**
 * Method decorator for marking a method as trackable.
 * Ensures method calls are recorded for all TrackableObject instances.
 */
export declare function syncMethod<This extends object, Return>(settings?: TrackedMethodSettings<This>): (target: any, context: ClassMethodDecoratorContext) => void;
export declare class ObjectSync implements IEventEmitter<ObjectSyncEventMap> {
	private readonly _core;
	constructor(settings: ObjectSyncSettings);
	on<Event extends keyof ObjectSyncEventMap>(event: Event, callback: ObjectSyncEventMap[Event]): void;
	once<Event extends keyof ObjectSyncEventMap>(event: Event, callback: ObjectSyncEventMap[Event]): void;
	off<Event extends keyof ObjectSyncEventMap>(event: Event, callback: ObjectSyncEventMap[Event]): void;
	listenerCount<Event extends keyof ObjectSyncEventMap>(event: Event, callback?: ObjectSyncEventMap[Event] | undefined): number;
	/**
	 * Gets a view of all tracked objects. This includes all objects which are currently tracked, including root objects and objects which are only used by clients but not explicitly tracked.
	 */
	get allObjects(): ObjectsView;
	/**
	 * Gets a view of all tracked root objects. Root objects are objects which are explicitly tracked and will never be automatically deleted.
	 */
	get rootObjects(): RootObjectsView;
	/**
	 * Registers a new client connection.
	 * @param identity The identity of the client connection.
	 * @returns The token to the newly registered client connection.
	 */
	registerClient(identity: string): ClientToken;
	/**
	 * Registers a new client connection.
	 * @param settings Settings for the client connection.
	 * @returns The token to the newly registered client connection.
	 */
	registerClient(settings: ClientConnectionSettings): ClientToken;
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	unregisterClient(clientToken: ClientToken): void;
	/**
	 * Gets the identity of this ObjectSync instance.
	 */
	get identity(): string;
	/**
	 * Tracks an object for synchronization.
	 * Must be called for root objects you want to track. Tracked root objects will never be automatically deleted.
	 * @param instance The instance to track.
	 * @param objectId Optional object ID to use for the tracked object. If not provided, a new object ID will be generated.
	 * @return A disposable which can be used to untrack the object and access the tracked object's ID and instance (when still tracked).
	 */
	track<T extends object>(instance: T, objectId?: string): TrackedObjectDisposable<T>;
	/**
	 * Untracks an object from synchronization.
	 * Untracked objects are no longer prevented from being deleted and will be removed from clients when they are no longer used by them.
	 * @param instance The instance to untrack.
	 * @return True if the instance was untracked, false if it was not being tracked as a root object.
	 */
	untrack(instance: object): boolean;
	/**
	 * Applies messages from multiple clients asynchronously.
	 * That means that serializers can return promises which allows the feature to wait for method execution results for syncObject decorator targets.
	 * Messages are applied in a certain order:
	 * - First all create messages are applied in the order they are received, regardless of the client they come from.
	 *   This is to ensure that all objects are created before any changes are applied to them.
	 *   Some create messages may be used earlier than others if they are needed to create objects which are referenced by other messages,
	 *   but there is no guaranteed order between independent create messages.
	 * - Then change messages are applied in the order they are received.
	 * - Then execute messages are applied in the order they are received.
	 *
	 * @param messagesByClient A map of client connections to messages.
	 */
	applyMessagesAsync(messagesByClient: Map<ClientToken, Message[]>): Promise<void>;
	/**
	 * Applies messages from a client connection.
	 * @param messages The messages to apply.
	 * @param clientToken The client connection the messages are from.
	 */
	applyMessagesAsync(messages: Message[], clientToken: ClientToken): Promise<void>;
	/**
	 * Applies messages from multiple clients synchronously.
	 * Messages are applied in a certain order:
	 * - First all create messages are applied in the order they are received, regardless of the client they come from.
	 *   This is to ensure that all objects are created before any changes are applied to them.
	 *   Some create messages may be used earlier than others if they are needed to create objects which are referenced by other messages,
	 *   but there is no guaranteed order between independent create messages.
	 * - Then change messages are applied in the order they are received.
	 * - Then execute messages are applied in the order they are received.
	 *
	 * @param messagesByClient A map of client connections to messages.
	 */
	applyMessages(messagesByClient: Map<ClientToken, Message[]>): Promise<any>[];
	/**
	 * Applies messages from a client connection.
	 * @param messages The messages to apply.
	 * @param clientToken The client connection the messages are from.
	 */
	applyMessages(messages: Message[], clientToken: ClientToken): Promise<any>[];
	/**
	 * Clears internal states, which are needed to store changes between synchronization cycles. Should be called after messages have been collected for all clients.
	 */
	clearStates(): void;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states.
	 * @returns A map of client connections to messages.
	 */
	getMessages(): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clearNonClientStates: boolean): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states.
	 * @param clientToken The client connection to get messages for.
	 * @returns The messages for the specified client.
	 */
	getMessages(clientToken: ClientToken): Message[];
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clientToken The client connection to get messages for.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns The messages for the specified client.
	 */
	getMessages(clientToken: ClientToken, clearNonClientStates: boolean): Message[];
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states.
	 * @param clientTokens The client connections to get messages for.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clientTokens: ClientToken[]): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clientTokens The client connections to get messages for.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clientTokens: ClientToken[], clearNonClientStates: boolean): Map<ClientToken, Message[]>;
	/**
	 * Exchanges messages with clients by sending messages and receiving client messages.
	 * @param settings Settings for exchanging messages.
	 */
	exchangeMessagesAsync(settings: ExchangeMessagesSettings): Promise<void>;
	/**
	 * Gets the dispatcher associated with a tracked object instance.
	 * A dispatcher is different for each kind of object and returned by its associated serializer.
	 * USe this to configure ninstance based serializer settings.
	 * @param instance The tracked object instance.
	 * @returns The dispatcher associated with the object instance, or null if none exists.
	 */
	getSyncAgent<TDispatcher extends ISyncAgent | null = null, TInstance extends object = any>(instance: TInstance): SyncAgentOrFallback<TDispatcher, typeof instance>;
}
type PossibleClientTypeResults = string | typeof nothing | Constructor | null;
type ConstructorArgumentsFunctionPayload<T extends object> = ClientTypeIdFunctionPayload<T>;
type ClientTypeIdFunctionPayload<T extends object> = {
	instance: T;
	constructor: Constructor<T>;
	typeId: string;
	destinationClientToken: ClientToken;
};
type TrackableObjectSettings<T extends object> = {
	typeId?: string;
	properties?: {
		[propertyKey: string]: TrackedPropertySettings<T, any>;
	};
	methods?: {
		[methodKey: string]: TrackedMethodSettings<T>;
	};
	/**
	 * Function which is called before sending the object to the client, or a string typeId.
	 * Can be used to modify or filter the typeId being sent.
	 * When the "nothing" symbol, null or undefined is returned, the object creation will be skipped.
	 */
	clientTypeId?: PossibleClientTypeResults | ((this: T, payload: ClientTypeIdFunctionPayload<T>) => PossibleClientTypeResults);
	/**
	 * Optional list of constructor argument names or a function that returns the constructor arguments for the object.
	 * If provided, this will be used to serialize the constructor arguments when creating the object on the client.
	 * If not provided, the default constructor will be used without arguments.
	 * When a function is provided, it can also return an object with propertiesToOmit to exclude certain properties from being serialized for the creation message.
	 */
	constructorArguments?: string[] | ((this: T, payload: ConstructorArgumentsFunctionPayload<T>) => string[] | {
		propertiesToOmit?: string[];
		arguments: any[];
	});
	/**
	 * List of allowed types which can be assigned to the constructor parameters from the sender.
	 * When a value of a different type is assigned from the sender, the application will throw an error.
	 * When not provided, all types are allowed.
	 * The array index corresponds to the constructor parameter index. If a parameter index is missing, no types are allowed for that parameter.
	 */
	allowedConstructorParameterTypesFromSender?: Array<Array<Constructor | null | undefined>>;
};
/**
 * Class decorator for marking a class as auto-trackable by the host.
 * Can be used as @syncObject or @syncObject("typeId").
 * Registers the class for automatic tracking and assigns a typeId if provided.
 */
export declare function syncObject<This extends abstract new (...args: any) => any>(settings?: TrackableObjectSettings<InstanceType<This>>): (target: This, context: ClassDecoratorContext<This>) => void;
type SpliceInstructionEx<T = any> = {
	start: number;
	deletedItems: T[];
	items: T[];
};
export declare class SyncableArray<T = any> extends Array<T> {
	constructor(...initialData: T[]);
	setLength(value: number): void;
	setAtIndex(index: number, value: T): boolean;
	splice(start: number, deleteCount?: number, ...items: T[]): T[];
	push(...items: T[]): number;
	pop(): T | undefined;
	shift(): T | undefined;
	unshift(...items: T[]): number;
	reverse(): any;
	sort(compareFn?: ((a: T, b: T) => number) | undefined): any;
	fill(value: T, start?: number, end?: number): any;
	copyWithin(target: number, start: number, end?: number): any;
	protected onSplice(spliceInstruction: SpliceInstructionEx<T>): void;
}
type SyncableObservableArrayEventMap = {
	added: (items: any[], start: number) => void;
	removed: (items: any[], start: number) => void;
};
export declare class SyncableObservableArray<T = any> extends SyncableArray<T> implements IEventEmitter<SyncableObservableArrayEventMap> {
	private readonly _eventEmitter;
	onSplice(spliceInstruction: SpliceInstructionEx<T>): void;
	on<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	once<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	off<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback?: SyncableObservableArrayEventMap[Event] | undefined): number;
}
export interface IArraySyncAgent<TElement = any> extends ISyncAgent<Array<TElement>> {
	/**
	 * Reports a splice operation on the array. Can be used to manually notify about changes (for plain Arrays).
	 * Will throw an error if arrayChangeSetMode is not set to "compareStates".
	 * @param spliceInstruction - The splice instruction describing the change.
	 */
	reportSplice(): void;
	/**
	 * Reports a splice operation on the array. Can be used to manually notify about changes (for plain Arrays).
	 * Will throw an error if arrayChangeSetMode is not set to "trackSplices".
	 * @param start - The start index of the splice.
	 * @param deleteCount - The number of items deleted.
	 * @param items - The items inserted.
	 */
	reportSplice(start: number, deleteCount: number, ...items: TElement[]): void;
	/**
	 * Gets or sets the array change set mode, default value is the value from the ObjectSync settings.
	 */
	changeSetMode: "trackSplices" | "compareStates";
	/**
	 * Gets or sets the allowed types which can be sent from the sender for this array. This is a security measure to prevent clients from sending unexpected types which may be used to cause issues on the receiving end (e.g., by sending very large objects or objects with getters that execute expensive code). If not set, all types provided by sync agents will be allowed.
	 */
	allowedTypesFromSender: Constructor[] | undefined;
}
export declare const SyncableObservableArraySyncAgentProvider: SyncAgentProvider;
export declare const SyncableArraySyncAgentProvider: SyncAgentProvider;
export declare const ArraySyncAgentProvider: SyncAgentProvider;
export declare class SyncableMap<K = any, V = any> extends Map<K, V> {
	constructor(iterable?: Iterable<readonly [
		K,
		V
	]> | null);
	set(key: K, value: V): this;
	clear(): void;
	delete(key: K): boolean;
}
type SyncableObservableMapEventMap<K = any, V = any> = {
	set: (key: K, value: V) => void;
	cleared: () => void;
	deleted: (key: K) => void;
};
export declare class SyncableObservableMap<K = any, V = any> extends SyncableMap<K, V> implements IEventEmitter<SyncableObservableMapEventMap<K, V>> {
	private readonly _eventEmitter;
	set(key: K, value: V): this;
	clear(): void;
	delete(key: K): boolean;
	on<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback: SyncableObservableMapEventMap[Event]): void;
	once<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback: SyncableObservableMapEventMap[Event]): void;
	off<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback: SyncableObservableMapEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableMapEventMap>(event: Event, callback?: SyncableObservableMapEventMap[Event] | undefined): number;
}
export interface IMapSyncAgent<TKey = any, TValue = any> extends ISyncAgent<Map<TKey, TValue>> {
	reportClear(): void;
	reportDelete(key: TKey): void;
	reportChange(key: TKey, value: TValue): void;
	/**
	 * Gets or sets the allowed types which can be sent from the sender. This is a security measure to prevent clients from sending unexpected types which may be used to cause issues on the receiving end (e.g., by sending very large objects or objects with getters that execute expensive code). If not set, all types provided by sync agents will be allowed.
	 */
	allowedKeyTypesFromSender: Constructor[] | undefined;
	/**
	 * Gets or sets the allowed types which can be sent from the sender. This is a security measure to prevent clients from sending unexpected types which may be used to cause issues on the receiving end (e.g., by sending very large objects or objects with getters that execute expensive code). If not set, all types provided by sync agents will be allowed.
	 */
	allowedValueTypesFromSender: Constructor[] | undefined;
}
export declare const SyncableObservableMapSyncAgentProvider: SyncAgentProvider;
export declare const SyncableMapSyncAgentProvider: SyncAgentProvider;
export declare const MapSyncAgentProvider: SyncAgentProvider;
export declare class SyncableSet<V> extends Set<V> {
	constructor(iterable?: Iterable<V> | null);
	add(value: V): this;
	clear(): void;
	delete(value: V): boolean;
}
type SyncableObservableSetEventMap<T = any> = {
	added: (value: T) => void;
	cleared: () => void;
	deleted: (value: T) => void;
};
export declare class SyncableObservableSet<T = any> extends SyncableSet<T> implements IEventEmitter<SyncableObservableSetEventMap<T>> {
	private readonly _eventEmitter;
	add(value: T): this;
	clear(): void;
	delete(value: T): boolean;
	on<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback: SyncableObservableSetEventMap[Event]): void;
	once<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback: SyncableObservableSetEventMap[Event]): void;
	off<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback: SyncableObservableSetEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableSetEventMap>(event: Event, callback?: SyncableObservableSetEventMap[Event] | undefined): number;
}
export interface ISetSyncAgent<TValue = any> extends ISyncAgent<Set<TValue>> {
	reportClear(): void;
	reportDelete(value: TValue): void;
	reportAdd(value: TValue): void;
	/**
	 * Gets or sets the allowed types which can be sent from the sender. This is a security measure to prevent clients from sending unexpected types which may be used to cause issues on the receiving end (e.g., by sending very large objects or objects with getters that execute expensive code). If not set, all types provided by sync agents will be allowed.
	 */
	allowedTypesFromSender: Constructor[] | undefined;
}
export declare const SyncableObservableSetSyncAgentProvider: SyncAgentProvider;
export declare const SyncableSetSyncAgentProvider: SyncAgentProvider;
export declare const SetSyncAgentProvider: SyncAgentProvider;
type SyncAgentSettings<TSyncAgent extends SyncAgent> = {
	/**
	 * When provided will add a symbol to the type which tells it to use this serializer.
	 * You can then use the type in the ObjectSync creation settings as serializer.
	 */
	type: Constructor;
	/**
	 * The typeId to use for this sync agent. If not provided, the name of the type will be used.
	 */
	typeId?: string;
} & {
	/**
	 * Whether this sync agent should be added to the default intrinsic sync agents list. Default is false.
	 */
	defaultIntrinsicSyncAgentProvider?: boolean;
};
export declare function syncAgent<This extends new (...args: any) => SyncAgent>(settings: SyncAgentSettings<InstanceType<This>>): (target: This, context: ClassDecoratorContext<This>) => void;
export type StandaloneSerializationSettings = Pick<ObjectSyncSettings, "objectIdGeneratorSettings" | "intrinsics" | "types"> & {
	/**
	 * Identity of the internal ObjectSync instance, defaults to "host".
	 */
	identity?: string;
	/**
	 * Identity of the internal client ObjectSync instance, defaults to "client".
	 */
	clientIdentity?: string;
};
/**
 * Serializes the given value into a string that can be deserialized later using `deserializeValue`.
 * @param value - The object to serialize.
 * @param settings - Optional settings for serialization.
 * @returns The serialized string representation of the object.
 */
export declare function serializeValue(value: any, settings?: StandaloneSerializationSettings): string;
/**
 * Deserializes the given string back into an object that was previously serialized using `serializeValue`.
 * @param data - The serialized string representation of the object.
 * @param settings - Optional settings for deserialization.
 * @returns The deserialized object.
 */
export declare function deserializeValue<TValue = any>(data: string, settings?: StandaloneSerializationSettings): TValue;

export {};
