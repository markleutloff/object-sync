// Generated by dts-bundle-generator v9.5.1

export declare const CreateMessageType = "create";
export declare const ChangeMessageType = "change";
export declare const DeleteMessageType = "delete";
export declare const ExecuteMessageType = "execute";
export declare const ExecuteFinishedMessageType = "executeFinished";
export type Message = {
	type: string;
	objectId: string;
};
export type CreateObjectMessage<TPayload = any> = Message & {
	type: typeof CreateMessageType;
	typeId: string;
	data: TPayload;
};
export type ChangeObjectMessage<TPayload = any> = Message & {
	type: typeof ChangeMessageType;
	data: TPayload;
};
export type DeleteObjectMessage = Message & {
	type: typeof DeleteMessageType;
};
export type ExecuteObjectMessage<TInstance extends object = any, TMethodName extends string & keyof TInstance = any> = Message & {
	type: typeof ExecuteMessageType;
	id: unknown;
	method: TMethodName;
	parameters: TInstance[TMethodName] extends (...args: infer TArguments) => any ? TArguments : never;
};
export type ExecuteFinishedObjectMessage = Message & {
	type: typeof ExecuteFinishedMessageType;
	invokeId: unknown;
	error?: any;
	result?: any;
};
export declare function isExecuteObjectMessage(message: Message): message is ExecuteObjectMessage;
export declare function isChangeObjectMessage(message: Message): message is ChangeObjectMessage;
export declare function isCreateObjectMessage(message: Message): message is CreateObjectMessage;
export declare function isDeleteObjectMessage(message: Message): message is DeleteObjectMessage;
export declare function isExecuteFinishedObjectMessage(message: Message): message is ExecuteFinishedObjectMessage;
type OneOrMany<T> = T | Iterable<T>;
type Constructor<T = any> = {
	new (...args: any[]): T;
};
/**
 * Settings for a client connection.
 */
export type ClientConnectionSettings = {
	/**
	 * Identity of the client (e.g., "host", "client1", etc.).
	 */
	identity: string;
};
/**
 * Representation of a connection to a client.
 */
export type ClientToken = {
	/**
	 * Identity of the client (e.g., "host", "client1", etc.).
	 */
	identity: string;
};
type ClientTokenFilter = {
	/**
	 * Set of clients to include or exclude
	 */
	clientTokens?: OneOrMany<ClientToken>;
	/**
	 * Set of client identities to include or exclude
	 */
	identities?: OneOrMany<string>;
	/**
	 * If true, only the specified clients are included; if false, they are excluded, default is true
	 */
	isExclusive?: boolean;
};
declare class PrimitiveValue {
	readonly value: any;
	constructor(value: any);
}
declare class ObjectReference {
	readonly objectId: string;
	readonly typeId: string;
	static from(objectInfo: ObjectInfo, clientToken: ClientToken): ObjectReference | undefined;
	private constructor();
}
export type TypeSerializerConstructor<TTypeSerializer extends TypeSerializer = TypeSerializer, TInstance extends object = any> = {
	new (objectInfo: ObjectInfo<TInstance>): TTypeSerializer;
	canSerialize(instanceOrTypeId: object | string): boolean;
};
export declare abstract class TypeSerializer<TInstance extends object = object> {
	protected readonly _objectInfo: ObjectInfo<TInstance>;
	static canSerialize(instanceOrTypeId: object | string): boolean;
	private readonly _clients;
	private readonly _storedReferencesByKey;
	private _hasPendingChanges;
	constructor(_objectInfo: ObjectInfo<TInstance>);
	protected get hasPendingChanges(): boolean;
	protected set hasPendingChanges(value: boolean);
	get objectId(): string;
	/**
	 * The actual instance being serialized/deserialized.
	 * Can be null when not yet created (eg: The serializer has been created for a new object but the create message has not yet been handled).
	 * Must be set when the object is newly created (eg: when handling the create message).
	 */
	get instance(): TInstance;
	set instance(value: TInstance);
	onInstanceSet(createdByCreateObjectMessage: boolean): void;
	/**
	 * The clients this serializer is tracking.
	 */
	get clients(): Set<ClientToken>;
	/**
	 * Gets the type ID for the instance being serialized.
	 * @param clientToken The client connection for which the type ID is requested. Can be used to return different type IDs based on the client.
	 */
	abstract getTypeId(clientToken: ClientToken): string | null;
	/**
	 * Called when a client connection is removed to allow the serializer to clean up any references related to the client connection.
	 * @param clientToken The client connection being removed.
	 */
	onClientConnectionRemoved(clientToken: ClientToken): void;
	/**
	 * Clears the states for the serializer.
	 * @param clientToken Optional client connection for which to clear the state. If not provided, clears the state not related to any specific client connection.
	 */
	clearStates(clientToken?: ClientToken): void;
	/**
	 * Reports to the owner that there are pending messages for the object.
	 * This will be implicitly called when setting hasPendingChanges to true. Or when the serializer is created with an existing instance.
	 */
	protected reportPendingMessages(): void;
	/**
	 * Serializes a value (basically converts any reference values to ObjectReferences).
	 */
	protected serializeValue(value: any, clientToken: ClientToken): PrimitiveValue | ObjectReference | undefined;
	/**
	 * Deserializes a value (basically converts any ObjectReferences to actual object references).
	 */
	protected deserializeValue(value: any, clientToken: ClientToken): any;
	/**
	 * Generates messages to be sent to the client connection.
	 * @param clientToken The client connection for which to generate messages.
	 * @param isNewClientConnection Whether the client connection is new (ie: just connected).
	 * @returns An array of messages to be sent to the client connection.
	 */
	abstract generateMessages(clientToken: ClientToken, isNewClientConnection: boolean): Message[];
	/**
	 * Applies a message to the serializer.
	 * Only create messages can never return a Promise.
	 * Only create messages must be handled by the serializer. All other messages can be ignored if not supported.
	 * @param message The message to apply.
	 * @param clientToken The client connection from which the message was received.
	 */
	abstract applyMessage(message: Message, clientToken: ClientToken): void | Promise<void>;
	/**
	 * Stores a reference to an object which will be used to keep track of references for serialization purposes.
	 * @param value The reference to store. When a primitive value is provided, no reference is stored but a dummy StoredReference is returned.
	 * @returns A StoredReference which can be used to dispose the stored reference.
	 */
	protected storeReference(value: any): StoredReference;
	/**
	 * Stores a reference to an object which will be used to keep track of references for serialization purposes.
	 * @param value The reference to store. When a primitive value is provided, no reference is stored but a dummy StoredReference is returned.
	 * @param clientToken The client connection for which the reference is stored.
	 * @returns A StoredReference which can be used to dispose the stored reference.
	 */
	protected storeReference(value: any, clientToken: ClientToken): StoredReference;
	/**
	 * Stores a reference to an object which will be used to keep track of references for serialization purposes.
	 * @param value The reference to store. When a primitive value is provided, no reference is stored but a dummy StoredReference is returned.
	 * @param key The key associated with the stored reference.
	 * @returns A StoredReference which can be used to dispose the stored reference.
	 */
	protected storeReference(value: any, key: number | string | symbol): StoredReference;
	/**
	 * Stores a reference to an object which will be used to keep track of references for serialization purposes.
	 * @param value The reference to store. When a primitive value is provided, no reference is stored but a dummy StoredReference is returned.
	 * @param key The key associated with the stored reference.
	 * @param clientToken The client connection for which the reference is stored.
	 * @returns A StoredReference which can be used to dispose the stored reference.
	 */
	protected storeReference(value: any, key: number | string | symbol, clientToken: ClientToken): StoredReference;
	protected clearAllStoredReferencesWithKey(key: number | string | symbol): void;
	protected clearAllStoredReferencesWithClientConnection(clientToken: ClientToken): void;
	private storeReferenceInternal;
	get dispatcher(): any;
}
export declare abstract class ExtendedTypeSerializer<TInstance extends object = object, TPayload extends object = any> extends TypeSerializer<TInstance> {
	private readonly _messageTypeToHandler;
	constructor(objectInfo: ObjectInfo<TInstance>);
	protected registerMessageHandler<TMessage extends Message>(messageType: string, handler: (message: TMessage, clientToken: ClientToken) => void | Promise<void>): void;
	applyMessage(message: Message, clientToken: ClientToken): Promise<void>;
	abstract onCreateMessageReceived(message: CreateObjectMessage<TPayload>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TPayload>, clientToken: ClientToken): void;
}
type SimpleTypeSerializerSettings<TInstance extends object, TPayload = any> = {
	type: Constructor<TInstance>;
	typeId: string;
	serialize: (obj: TInstance) => TPayload;
	deserialize: (data: TPayload) => TInstance;
};
export declare function MakeSimpleTypeSerializer<TInstance extends object, TPayload = any>(settings: SimpleTypeSerializerSettings<TInstance, TPayload>): TypeSerializerConstructor;
type StoredReference = {
	dispose(): void;
};
export declare class ObjectInfo<TInstance extends object = object> {
	private _owner;
	private _objectId;
	private _isRoot;
	private _serializer;
	private _instance;
	private _clientFilters;
	private _isOwned;
	private _referenceCountByClient;
	constructor(_owner: ObjectSync, _objectId?: string, instanceOrTypeId?: string | TInstance, _isRoot?: boolean);
	initializeSerializer(instanceOrTypeId?: string | TInstance): void;
	get isOwned(): boolean;
	set isOwned(value: boolean);
	get objectId(): string;
	get instance(): TInstance;
	set instance(value: TInstance);
	get isRoot(): boolean;
	set isRoot(value: boolean);
	get serializer(): TypeSerializer;
	get owner(): ObjectSync;
	addReference(clientToken?: ClientToken): StoredReference;
	get isOrphaned(): boolean;
	mustDeleteForClient(clientToken: ClientToken): boolean;
	private removeReference;
	setClientRestriction(filter: ClientTokenFilter): void;
	/**
	 * Determines if this object is visible to a given client based on filters.
	 */
	isForClientToken(clientToken: ClientToken): boolean;
	/**
	 * Removes all client restrictions, making the object visible to all clients.
	 */
	removeClientRestrictions(): void;
}
type EventFunction = (...args: any[]) => void;
type EventMap = {
	[key: string]: EventFunction;
};
export type IEventEmitter<Events extends EventMap = EventMap> = {
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event] | undefined): number;
};
export declare class EventEmitter<Events extends EventMap = EventMap> implements IEventEmitter<Events> {
	readonly _events: {
		[key in keyof Events]?: EventFunction[];
	};
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event]): number;
	emit<Event extends keyof Events>(event: Event, ...args: any[]): void;
	protected onEventListenerAdded<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	protected onEventListenerRemoved<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
}
export declare const nothing: unique symbol;
type CanTrackPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
};
type CanApplyPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	sourceClientConnection: ClientToken;
};
type BeforeSendToClientPayload<T extends object, TKey extends keyof T & string, TValue> = {
	instance: T;
	key: TKey;
	value: TValue;
	destinationClientConnection: ClientToken;
};
type TrackedPropertySettingsBase<T extends object> = {
	/**
	 * Returns true when the property/method should be tracked.
	 */
	canTrack?<TKey extends keyof T & string>(this: T, payload: CanTrackPayload<T, TKey>): boolean;
	/**
	 *  Returns true when the property/method change should be applied.
	 */
	canApply?<TKey extends keyof T & string>(this: T, payload: CanApplyPayload<T, TKey>): boolean;
	/**
	 * Defines how the property/method should be tracked/applied.
	 * - "trackAndApply": Changes to the property/method are tracked and applied (thats the default).
	 * - "trackOnly": Changes to the property/method are only tracked, not applied.
	 * - "applyOnly": Changes to the property/method are only applied, not tracked.
	 * - "none": Changes to the property/method are neither tracked nor applied.
	 */
	mode?: "trackAndApply" | "trackOnly" | "applyOnly" | "none";
};
type TrackedPropertySettings<T extends object, TValue> = TrackedPropertySettingsBase<T> & {
	/**
	 * Function which is called before sending the property value to the client.
	 * Can be used to modify or filter the value being sent.
	 * When the symbol value "nothing" is returned, the property update will be skipped.
	 */
	beforeSendToClient?<TKey extends keyof T & string>(this: T, payload: BeforeSendToClientPayload<T, TKey, TValue>): TValue | typeof nothing;
};
type TrackedPropertyInfo<T extends object, TValue> = TrackedPropertySettings<T, TValue> & {};
/**
 * Property accessor decorator for marking a property as trackable.
 * Registers the property and ensures changes are propagated to all TrackableObject instances.
 */
export declare function syncProperty<This extends object, Return>(settings?: TrackedPropertySettings<This, Return>): (target: ClassAccessorDecoratorTarget<This, Return>, context: ClassAccessorDecoratorContext<This, Return>) => ClassAccessorDecoratorResult<This, Return>;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type MethodReturnType<T extends object, K extends keyof T> = T[K] extends (...args: any[]) => infer U ? UnwrapPromise<U> : never;
export interface ISyncObjectDispatcher<TInstance extends object = object> {
	/**
	 * Invokes a method on all currently known clients.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A map of client tokens to promises of the method return values.
	 */
	invoke<TMethodName extends keyof TInstance>(method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Map<ClientToken, Promise<MethodReturnType<TInstance, TMethodName>>>;
	/**
	 * Invokes a method on the specified client.
	 * @param clientToken The client token to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A promise of the method return value.
	 */
	invoke<TMethodName extends keyof TInstance>(clientToken: ClientToken, method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Promise<MethodReturnType<TInstance, TMethodName>>;
	/**
	 * Invokes a method on multiple specified clients.
	 * @param clients Multiple client tokens to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The method arguments.
	 * @return A map of client tokens to promises of the method return values.
	 */
	invoke<TMethodName extends keyof TInstance>(clients: Iterable<ClientToken>, method: TMethodName, ...args: TInstance[TMethodName] extends (...a: infer P) => any ? P : never): Map<ClientToken, Promise<MethodReturnType<TInstance, TMethodName>>>;
}
type SpliceInstruction<T = any> = {
	start: number;
	deleteCount: number;
	items: T[];
};
type SpliceInstructionEx<T = any> = {
	start: number;
	deletedItems: T[];
	items: T[];
};
type TInstance = Array<any>;
type TCreatePayload = any[];
export interface ISyncArrayDispatcher<TElement = any> {
	/**
	 * Reports a splice operation on the array. Can be used to manually notify about changes (for plain Arrays).
	 * Will throw an error if arrayChangeSetMode is not set to "compareStates".
	 * @param spliceInstruction - The splice instruction describing the change.
	 */
	reportSplice(): void;
	/**
	 * Reports a splice operation on the array. Can be used to manually notify about changes (for plain Arrays).
	 * Will throw an error if arrayChangeSetMode is not set to "trackSplices".
	 * @param start - The start index of the splice.
	 * @param deleteCount - The number of items deleted.
	 * @param items - The items inserted.
	 */
	reportSplice(start: number, deleteCount: number, ...items: TElement[]): void;
	/**
	 * Gets or sets the array change set mode, default value is the value from the ObjectSync settings.
	 */
	changeSetMode: "trackSplices" | "compareStates";
}
declare abstract class SyncArraySerializerBase extends ExtendedTypeSerializer<TInstance> {
	private _oldArrayContent;
	private _temporaryChanges;
	private _dispatcher;
	private _changeSetMode?;
	onInstanceSet(createdByCreateObjectMessage: boolean): void;
	private reportSplice;
	private get changeSetMode();
	private set changeSetMode(value);
	onCreateMessageReceived(message: CreateObjectMessage<TCreatePayload>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<SpliceInstruction<any>[]>, clientToken: ClientToken): void;
	generateMessages(clientToken: ClientToken, isNewClientConnection: boolean): Message[];
	clearStates(clientToken: ClientToken): void;
	get dispatcher(): ISyncArrayDispatcher;
	private createDispatcher;
}
export declare class ArraySerializer extends SyncArraySerializerBase {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	getTypeId(clientToken: ClientToken): string;
}
export declare class SyncArraySerializer extends SyncArraySerializerBase {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	getTypeId(clientToken: ClientToken): string;
}
export declare class SyncObservableArraySerializer extends SyncArraySerializerBase {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	getTypeId(clientToken: ClientToken): string;
}
type ExchangeMessagesSettings = {
	/**
	 * Optional function to handle errors that occur during message exchange.
	 * @param clientToken The client connection where the error occurred.
	 * @param error The error that occurred.
	 */
	errorHandler?: (clientToken: ClientToken, error: any) => void;
	/**
	 * Optional function to filter messages sent to or received from clients.
	 * Warning: Using this filter may lead to inconsistent states between server and clients if messages are blocked.
	 * You can use it to implement custom logic, such as ignoring certain messages for specific clients.
	 * @param clientToken The client connection involved in the message exchange.
	 * @param message The message being sent or received.
	 * @param isIncoming True if the message is incoming to the server, false if outgoing.
	 * @returns True to allow the message, false to block it.
	 */
	clientMessageFilter?: (clientToken: ClientToken, message: Message, isIncoming: boolean) => boolean;
	/**
	 * Clients to exchange messages with. If not provided, messages will be exchanged with all registered clients.
	 */
	clients?: ClientToken[];
} & ({
	/**
	 * Function to send messages to a single client and receive client messages back as results.
	 * @param clientToken The client connection to send messages to.
	 * @param messages The messages to send to the client.
	 * @returns A promise that resolves to the messages received from the client.
	 */
	sendToClientAsync: (clientToken: ClientToken, messages: Message[]) => Promise<Message[]>;
} | {
	/**
	 * Function to send messages to multiple clients and receive client messages back as results.
	 * @param messagesByClientToken A map of client connections to messages to send.
	 * @returns A promise that resolves to a map of client connections to messages received from the clients.
	 */
	sendToClientsAsync: (messagesByClientToken: Map<ClientToken, Message[]>) => Promise<Map<ClientToken, Message[]>>;
});
export type ObjectIdGeneratorSettings = {
	/**
	 * Function to generate an object ID..
	 * @param value
	 */
	generateId(value?: object): string;
} | {
	/**
	 * Prefix to use for generated object IDs.
	 */
	prefix: string;
};
export type FinalizedObjectSyncSettings = {
	identity: string;
	serializers: TypeSerializerConstructor[];
	intrinsicSerializers: TypeSerializerConstructor[];
	objectIdGeneratorSettings: ObjectIdGeneratorSettings;
	arrayChangeSetMode: "trackSplices" | "compareStates";
};
export type ObjectSyncSettings = {
	/**
	 * Identity of this ObjectSync instance (e.g., "host" or "client1").
	 */
	identity: string;
	/**
	 * Type serializers to use for serializing and deserializing property values during synchronization.
	 * Can either be provided as an array of type serializers or constructors of SyncObject types.
	 * When constructors are provided, the corresponding internal SyncObjectSerializer will be used.
	 * When not provided, all registered SyncObject types will be used.
	 */
	serializers?: (TypeSerializerConstructor | Constructor)[];
	/**
	 * Intrinsic type serializers to use for serializing and deserializing base types (Array, Map, Set, Object) during synchronization.
	 * Can be provided as an array of type serializers.
	 * When not provided, default intrinsic type serializers will be used.
	 */
	intrinsicSerializers?: TypeSerializerConstructor[];
	/**
	 * Settings for generating object IDs.
	 * When not provided, a default generator with the identity as prefix will be used (eg: "host-1").
	 */
	objectIdGeneratorSettings?: ObjectIdGeneratorSettings;
	/**
	 * Defines how array changes are tracked and serialized.
	 * - "trackSplices": Uses splice instructions to record changes. More efficient for small changes. May transfer data which will be removed with a later splice.
	 * - "compareStates": gathers splice data by comparing the old array state to the new array state. More efficient for large changes. (Default)
	 */
	arrayChangeSetMode?: "trackSplices" | "compareStates";
};
export declare class ObjectSync {
	private readonly _objectPool;
	private readonly _objectsWithPendingMessages;
	private readonly _clients;
	private readonly _settings;
	private _nextObjectId;
	private _pendingCreateMessageByObjectId;
	private readonly _ownClientConnection;
	constructor(settings: ObjectSyncSettings);
	get arrayChangeSetMode(): "trackSplices" | "compareStates";
	reportPendingMessagesForObject(objectInfo: ObjectInfo): void;
	generateObjectId(value?: object): string;
	/**
	 * Registers a new client connection.
	 * @param settings Settings for the client connection.
	 * @returns The token to the newly registered client connection.
	 */
	registerClient(settings: ClientConnectionSettings): ClientToken;
	get registeredClientTokens(): ClientToken[];
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	removeClient(clientToken: ClientToken): void;
	/**
	 * Gets the identity of this ObjectSync instance.
	 */
	get identity(): string;
	/** Returns all currently tracked objects. */
	get allTrackedObjects(): object[];
	/**
	 * Sets a client restriction filter for a tracked object.
	 * @param obj The tracked object to set the filter for.
	 * @param filter The client restriction filter to apply.
	 */
	setClientRestriction<T extends object>(obj: T, filter: ClientTokenFilter): void;
	/**
	 * Tracks an object for synchronization.
	 * Must be called for root objects you want to track.
	 * TypeSerializers must call this with non-root objects they encounter.
	 * @param instance The instance to track.
	 */
	track(instance: object, objectId?: string): void;
	trackInternal(instance: object, objectId?: string): ObjectInfo | null;
	/**
	 * Untracks an object from synchronization.
	 * A delete message will be sent to clients during the next message generation, after which the object will be fully removed.
	 * @param instance The instance to untrack.
	 * @return True if the instance was untracked, false if it was not being tracked as a root object.
	 */
	untrack(instance: object): boolean;
	/**
	 * Internal use only: Called by ObjectInfo.
	 */
	reportInstanceCreated(instance: object, objectId: string): void;
	/**
	 * Internal use only: Called by ObjectInfo.
	 */
	findSerializer(instanceOrTypeId: object | string): TypeSerializerConstructor;
	private handleCreateMessage;
	private handleOtherMessage;
	private handleDeleteMessage;
	serializeValue(value: any, clientToken: ClientToken): PrimitiveValue | ObjectReference | undefined;
	deserializeValue(value: PrimitiveValue | ObjectReference | undefined, clientToken: ClientToken): any;
	/**
	 * Applies messages from multiple clients.
	 * @param messagesByClient A map of client connections to messages.
	 */
	applyMessagesAsync(messagesByClient: Map<ClientToken, Message[]>): Promise<void>;
	/**
	 * Applies messages from a client connection.
	 * @param messages The messages to apply.
	 * @param clientToken The client connection the messages are from.
	 */
	applyMessagesAsync(messages: Message[], clientToken: ClientToken): Promise<void>;
	/**
	 * Clears internal states, which are needed to store changes between synchronization cycles. Should be called after messages have been collected for all clients.
	 */
	clearStates(): void;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states.
	 * @returns A map of client connections to messages.
	 */
	getMessages(): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clearNonClientStates: boolean): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states.
	 * @param clientToken The client connection to get messages for.
	 * @returns The messages for the specified client.
	 */
	getMessages(clientToken: ClientToken): Message[];
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clientToken The client connection to get messages for.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns The messages for the specified client.
	 */
	getMessages(clientToken: ClientToken, clearNonClientStates: boolean): Message[];
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states.
	 * @param clientTokens The client connections to get messages for.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clientTokens: ClientToken[]): Map<ClientToken, Message[]>;
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states when clearNonClientStates is true.
	 * @param clientTokens The client connections to get messages for.
	 * @param clearNonClientStates Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clientTokens: ClientToken[], clearNonClientStates: boolean): Map<ClientToken, Message[]>;
	private getMessagesForClients;
	/**
	 * Finds a tracked object by its object ID.
	 * @param objectId Object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findOne<T extends object>(objectId: string): T | undefined;
	/**
	 * Finds a tracked object by its constructor and optional object ID.
	 * @param constructor The constructor of the object type to find.
	 * @param objectId Optional object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findOne<T extends object>(constructor: Constructor<T>, objectId?: string): T | undefined;
	/**
	 * Finds all tracked objects of a specific type.
	 * @param constructor The constructor of the object type to find.
	 * @returns An array of found objects.
	 */
	findAll<T extends object>(constructor: Constructor<T>): T[];
	/**
	 * Exchanges messages with clients by sending messages and receiving client messages.
	 * @param settings Settings for exchanging messages.
	 */
	exchangeMessagesAsync(settings: ExchangeMessagesSettings): Promise<void>;
	/**
	 * Gets the dispatcher associated with a tracked object instance.
	 * A dispatcher is different for each kind of object and returned by its associated serializer.
	 * USe this to configure ninstance based serializer settings.
	 * @param instance The tracked object instance.
	 * @returns The dispatcher associated with the object instance, or null if none exists.
	 */
	getDispatcher<TDispatcher = null, TInstance extends object = any>(instance: TInstance): DispatcherOrFallback<TDispatcher, typeof instance> | null;
}
type DispatcherType<TInstance> = TInstance extends Array<infer TArrayItem> ? ISyncArrayDispatcher<TArrayItem> : TInstance extends object ? ISyncObjectDispatcher<TInstance> : never;
type DispatcherOrFallback<TDispatcher, TInstance> = TDispatcher extends null ? DispatcherType<TInstance> : TDispatcher;
export type StandaloneSerializationSettings = {
	/**
	 * Identity of the internal ObjectSync instance, defaults to "host".
	 */
	identity?: string;
	/**
	 * Identity of the internal client ObjectSync instance, defaults to "client".
	 */
	clientIdentity?: string;
	/**
	 * Type serializers to use for serializing and deserializing property values during synchronization.
	 * Can either be provided as an array of type serializers or constructors of SyncObject types.
	 * When constructors are provided, the corresponding internal SyncObjectSerializer will be used.
	 * When not provided, all registered SyncObject types will be used.
	 */
	serializers?: (TypeSerializerConstructor | Constructor)[];
	/**
	 * Intrinsic type serializers to use for serializing and deserializing base types (Array, Map, Set, Object) during synchronization.
	 * Can be provided as an array of type serializers.
	 * When not provided, default intrinsic type serializers will be used.
	 */
	intrinsicSerializers?: TypeSerializerConstructor[];
	/**
	 * Settings for generating object IDs.
	 * When not provided, a default generator with the identity as prefix will be used (eg: "host-1").
	 */
	objectIdGeneratorSettings?: ObjectIdGeneratorSettings;
};
/**
 * Serializes the given value into a string that can be deserialized later using `deserializeValue`.
 * @param value - The object to serialize.
 * @param settings - Optional settings for serialization.
 * @returns The serialized string representation of the object.
 */
export declare function serializeValue(value: any, settings?: StandaloneSerializationSettings): string;
/**
 * Deserializes the given string back into an object that was previously serialized using `serializeValue`.
 * @param data - The serialized string representation of the object.
 * @param settings - Optional settings for deserialization.
 * @returns The deserialized object.
 */
export declare function deserializeValue<TValue = any>(data: string, settings?: StandaloneSerializationSettings): TValue;
/**
 * Asynchronously deserializes the given string back into an object that was previously serialized using `serializeValue`.
 * Useful when custom asynchronous type serializers are involved.
 * @param data - The serialized string representation of the object.
 * @param settings - Optional settings for deserialization.
 * @returns A promise that resolves to the deserialized object.
 */
export declare function deserializeValueAsync<TValue extends object = any>(data: string, settings?: StandaloneSerializationSettings): Promise<TValue>;
type BeforeExecuteOnClientPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	args: T[TKey] extends (...args: infer P) => any ? P : never;
	destinationClientConnection: ClientToken;
};
type TrackedMethodSettings<T extends object> = TrackedPropertySettingsBase<T> & {
	/**
	 * Defines how method execution should handle returned Promises.
	 * - "await": The method call will be awaited, and the resolved value will be used or the rejection will be sent back to the client.
	 * - "normal": The Promise will be returned as-is without awaiting, once settled the result will be sent back to the client.
	 * If not set, the default behavior is "normal".
	 */
	promiseHandlingType?: "await" | "normal";
	/**
	 * Function which is called before sending the method execution call to the client.
	 * Can be used to prevent the method call from being sent.
	 * When false is returned, the method call will be skipped.
	 */
	beforeExecuteOnClient?<TKey extends keyof T & string>(this: T, payload: BeforeExecuteOnClientPayload<T, TKey>): boolean;
};
type TrackedMethodInfo<T extends object> = TrackedMethodSettings<T> & {};
/**
 * Method decorator for marking a method as trackable.
 * Ensures method calls are recorded for all TrackableObject instances.
 */
export declare function syncMethod<This extends object, Return>(settings?: TrackedMethodSettings<This>): (target: any, context: ClassMethodDecoratorContext) => void;
export declare const allSyncObjectTypes: Set<Constructor>;
type PossibleClientTypeResults = string | typeof nothing | Constructor | null;
type TrackableConstructorInfo<T extends object> = {
	trackedProperties: Map<string, TrackedPropertyInfo<T, any>>;
	trackedMethods: Map<string, TrackedMethodInfo<T>>;
	typeId: string;
	/**
	 * Function which is called before sending the object to the client, or a string typeId.
	 * Can be used to modify or filter the typeId being sent.
	 * When the "nothing" symbol, null or undefined is returned, the object creation will be skipped.
	 */
	clientTypeId?: PossibleClientTypeResults | ((this: T, payload: ClientTypeIdFunctionPayload<T>) => PossibleClientTypeResults);
	/**
	 * Optional ordered list of properties to use for the constructor arguments or a function that returns the constructor arguments for the object.
	 * If provided, this will be used to serialize the constructor arguments when creating the object on the client.
	 * If not provided, the default constructor will be used without arguments.
	 * When a function is provided, it can also return an object with propertiesToOmit to exclude certain properties from being serialized for the creation message.
	 */
	constructorArguments?: string[] | ((this: T, payload: ConstructorArgumentsFunctionPayload<T>) => string[] | {
		propertiesToOmit?: string[];
		arguments: any[];
	});
};
type ConstructorArgumentsFunctionPayload<T extends object> = ClientTypeIdFunctionPayload<T>;
type ClientTypeIdFunctionPayload<T extends object> = {
	instance: T;
	constructor: Constructor<T>;
	typeId: string;
	destinationClientConnection: ClientToken;
};
type TrackableObjectSettings<T extends object> = {
	typeId?: string;
	properties?: {
		[propertyKey: string]: TrackedPropertySettings<T, any>;
	};
	methods?: {
		[methodKey: string]: TrackedMethodSettings<T>;
	};
	/**
	 * Function which is called before sending the object to the client, or a string typeId.
	 * Can be used to modify or filter the typeId being sent.
	 * When the "nothing" symbol, null or undefined is returned, the object creation will be skipped.
	 */
	clientTypeId?: PossibleClientTypeResults | ((this: T, payload: ClientTypeIdFunctionPayload<T>) => PossibleClientTypeResults);
	/**
	 * Optional list of constructor argument names or a function that returns the constructor arguments for the object.
	 * If provided, this will be used to serialize the constructor arguments when creating the object on the client.
	 * If not provided, the default constructor will be used without arguments.
	 * When a function is provided, it can also return an object with propertiesToOmit to exclude certain properties from being serialized for the creation message.
	 */
	constructorArguments?: string[] | ((this: T, payload: ConstructorArgumentsFunctionPayload<T>) => string[] | {
		propertiesToOmit?: string[];
		arguments: any[];
	});
};
/**
 * Class decorator for marking a class as auto-trackable by the host.
 * Can be used as @syncObject or @syncObject("typeId").
 * Registers the class for automatic tracking and assigns a typeId if provided.
 */
export declare function syncObject<This extends abstract new (...args: any) => any>(settings?: TrackableObjectSettings<InstanceType<This>>): (target: This, context: ClassDecoratorContext<This>) => void;
export declare function getTrackableTypeInfo<T extends object = any>(ctor: Constructor<T>): TrackableConstructorInfo<T> | null;
export declare class SyncableArray<T = any> extends Array<T> {
	constructor(...initialData: T[]);
	setLength(value: number): void;
	setAtIndex(index: number, value: T): boolean;
	splice(start: number, deleteCount?: number, ...items: T[]): T[];
	push(...items: T[]): number;
	pop(): T | undefined;
	shift(): T | undefined;
	unshift(...items: T[]): number;
	reverse(): any;
	sort(compareFn?: ((a: T, b: T) => number) | undefined): any;
	fill(value: T, start?: number, end?: number): any;
	copyWithin(target: number, start: number, end?: number): any;
	protected onSplice(spliceInstruction: SpliceInstructionEx<T>): void;
}
type SyncableObservableArrayEventMap = {
	added: (items: any[], start: number) => void;
	removed: (items: any[], start: number) => void;
};
export declare class SyncableObservableArray<T = any> extends SyncableArray<T> implements IEventEmitter<SyncableObservableArrayEventMap> {
	private readonly _eventEmitter;
	onSplice(spliceInstruction: SpliceInstructionEx<T>): void;
	on<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	once<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	off<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback?: SyncableObservableArrayEventMap[Event] | undefined): number;
}
type TInstance$1 = Set<any>;
type TPayload = any[];
export declare class SetSerializer extends ExtendedTypeSerializer<TInstance$1, TPayload> {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	constructor(objectInfo: ObjectInfo<TInstance$1>);
	getTypeId(clientToken: ClientToken): string;
	onCreateMessageReceived(message: CreateObjectMessage<TPayload>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TPayload>, clientToken: ClientToken): void;
	generateMessages(clientToken: ClientToken, isNewClientConnection: boolean): Message[];
	private getSerializedData;
}
type TInstance$2 = Map<any, any>;
type TPayload$1 = {
	key: any;
	value: any;
}[];
export declare class MapSerializer extends ExtendedTypeSerializer<TInstance$2, TPayload$1> {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	constructor(objectInfo: ObjectInfo<TInstance$2>);
	getTypeId(clientToken: ClientToken): string;
	onCreateMessageReceived(message: CreateObjectMessage<TPayload$1>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TPayload$1>, clientToken: ClientToken): void;
	generateMessages(clientToken: ClientToken, isNewClientConnection: boolean): Message[];
	private getSerializedData;
}
type TInstance$3 = object;
type TPayload$2 = object;
export declare class ObjectSerializer extends ExtendedTypeSerializer<TInstance$3, TPayload$2> {
	static canSerialize(instanceOrTypeId: object | string): boolean;
	constructor(objectInfo: ObjectInfo<TInstance$3>);
	getTypeId(clientToken: ClientToken): string;
	onCreateMessageReceived(message: CreateObjectMessage<TPayload$2>, clientToken: ClientToken): void;
	onChangeMessageReceived(message: ChangeObjectMessage<TPayload$2>, clientToken: ClientToken): void;
	generateMessages(clientToken: ClientToken, isNewClientConnection: boolean): Message[];
	private getSerializedData;
}

export {};
