// Generated by dts-bundle-generator v9.5.1

export declare const isPropertyInfoSymbol: unique symbol;
export type PropertyInfo<T extends object, TKey extends keyof T> = {
	value?: T[TKey];
	objectId?: unknown;
	[isPropertyInfoSymbol]?: true;
};
export type PropertyInfos<T extends object, TAdditionalPropertyInfo extends object = object> = {
	[K in keyof T]?: PropertyInfo<T, K> & TAdditionalPropertyInfo;
};
export type ResolvablePropertyInfos<T extends object> = {
	deleteProperty(key: keyof T & string): void;
	get deletedProperties(): (keyof T & string)[];
} & {
	[K in keyof T]?: T[K];
};
export type MessageBase = {
	type: string;
	objectId: unknown;
};
export type DeleteObjectMessage = MessageBase & {
	type: "delete";
};
export type CreateObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {
	type: "create";
	typeId: string;
	properties: PropertyInfos<T, TAdditionalPropertyInfo>;
};
export type ChangeObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {
	type: "change";
	properties: PropertyInfos<T, TAdditionalPropertyInfo>;
};
export type ExecuteObjectMessage<T extends object> = MessageBase & {
	type: "execute";
	id: unknown;
	method: keyof T & string;
	parameters: PropertyInfo<any, any>[];
};
export type Message<T extends object = object, TAdditionalPropertyInfo extends object = object> = DeleteObjectMessage | CreateObjectMessage<T, TAdditionalPropertyInfo> | ChangeObjectMessage<T, TAdditionalPropertyInfo> | ExecuteObjectMessage<T>;
export declare function isPropertyInfo(value: any): value is PropertyInfo<any, any>;
export type MethodExecuteResult = {
	id: unknown;
	result: any;
	status: "resolved" | "rejected" | "sync";
	error: string | null;
};
export declare class ClientObjectInfo<T extends object> extends ObjectInfoBase {
	constructor(objectSyncMetaInfo: ObjectSyncMetaInfo);
}
export type OneOrMany<T> = T | Iterable<T>;
export type TrackSettings = {
	/**
	 * Optional unique identifier for the object; if not provided, one will be generated.
	 */
	objectId?: unknown;
	/**
	 * If true, the object is considered a root object. Defaults to true.
	 */
	isRoot?: boolean;
	/**
	 * Settings for restricting client visibility of the object.
	 */
	clientVisibility?: ClientFilter;
	/**
	 * If true, tracking an already tracked object will be ignored instead of throwing an error.
	 * Defaults to false.
	 */
	ignoreAlreadyTracked?: boolean;
	knownClients?: OneOrMany<ClientConnection>;
};
export type ObjectSyncHostSettings = {
	objectIdPrefix?: string;
	objectPool?: TrackedObjectPool;
	designation?: string;
};
export type ClientConnectionSettings = {
	designation?: string;
};
export type ClientConnection = ClientConnectionSettings;
/**
 * The ChangeTrackerHost manages the lifecycle and visibility of trackable objects on the host/server side.
 * It tracks which objects are visible to which clients, manages object creation/deletion, and generates messages for clients.
 */
export declare class ObjectSyncHost {
	private readonly _settings;
	/** Pool of all currently tracked objects and their info. */
	private _trackedObjectPool;
	/** Maps client IDs to lists of delete messages for objects that have been untracked. */
	private _untrackedObjectInfosByClient;
	private _clients;
	constructor(_settings?: ObjectSyncHostSettings);
	/** Returns all currently tracked objects. */
	get allTrackedObjects(): object[];
	registerClient(settings?: ClientConnectionSettings): ClientConnection;
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	removeClient(client: ClientConnection): void;
	/**
	 * Restricts the visibility of a tracked object to a set of clients.
	 * @param obj The object to restrict.
	 * @param clients The client(s) allowed or excluded.
	 * @param isExclusive If true, only the given clients can see the object; otherwise, all except these clients can see it.
	 */
	setClientRestriction<T extends object>(obj: T, filter: ClientFilter): void;
	/**
	 * Adds a client-specific view to a tracked object.
	 */
	addView<T extends object>(obj: T, view: ClientSpecificView<T>): void;
	/**
	 * Removes a client-specific view from a tracked object.
	 * @returns true if the view was removed, false otherwise.
	 */
	removeView<T extends object>(obj: T, view: ClientSpecificView<T>): boolean;
	/**
	 * Begins tracking an object, optionally with settings for object ID and client visibility.
	 * Throws if objectId is specified for an already-trackable object.
	 */
	track<T extends object>(target: T, trackSettings?: TrackSettings): void;
	private trackInternal;
	/**
	 * Stops tracking an object and queues delete messages for all clients that could see it.
	 * If an object is passed instead of a TrackableObject, it will first be looked up.
	 */
	untrack<T extends object>(target: T): void;
	private untrackInternal;
	/**
	 * For a given message, finds and tracks any nested objects referenced by objectId/value pairs.
	 * Removes the value from the property after tracking.
	 * @returns Array of HostTrackableObjectInfo for any new objects tracked.
	 */
	private gatherUntrackedObjectInfos;
	private gatherUntrackedObjectInfosFromRaw;
	getMessages(tick?: boolean): Map<ClientConnection, Message[]>;
	/**
	 * Internal: Gathers all messages for a client.
	 */
	private getMessagesForClientInternal;
	/**
	 * Internal: Adds create/change/execute messages for a tracked object to the outgoing message list for a client.
	 * Also tracks any nested objects referenced in the message.
	 */
	private getMessagesForTrackableObjectInfo;
	private tick;
	/**
	 * Removes all tracked objects that are not reachable from any of the provided root objects.
	 * Traverses the object graph starting from the roots and untracks all unreachable objects.
	 */
	private removeUnusedObjects;
}
export type AdditionalHostPropertyInfo = {
	hasPendingChanges: boolean;
};
export type HostChangeObjectMessage<T extends object = object> = ChangeObjectMessage<T, AdditionalHostPropertyInfo>;
export type HostMessage<T extends object = object> = Message<T, AdditionalHostPropertyInfo>;
export type ClientFilter = {
	/**
	 * Set of clients to include or exclude
	 */
	clients?: OneOrMany<ClientConnection>;
	/**
	 * Set of client designations to include or exclude
	 */
	designations?: OneOrMany<string>;
	/**
	 * If true, only the specified clients are included; if false, they are excluded, default is true
	 */
	isExclusive?: boolean;
};
export type ClientSpecificView<T extends object> = {
	/**
	 * Optional filter to restrict the view to specific clients
	 */
	filter?: ClientFilter;
	/**
	 * Callback to modify property info before sending to the client; return null to exclude the property
	 * @param client The client requesting the property info
	 * @param key The property key
	 * @param propertyInfo The current property info
	 */
	onProperty?<TKey extends keyof T>(client: ClientConnection, key: TKey, propertyInfo: PropertyInfo<T, TKey>): PropertyInfo<T, TKey> | null;
	/**
	 * Callback to modify the typeId before sending to the client; return null to exclude the object from beeing sent to the client
	 * @param client The client requesting the typeId
	 * @param typeId The current typeId of the object
	 */
	onTypeId?(client: ClientConnection, typeId: string): string | null;
};
export type ServerObjectSyncMetaInfoCreateSettings<T extends object> = ObjectSyncMetaInfoCreateSettings<T> & {
	isRoot: boolean;
	objectIdPrefix: string;
};
/**
 * TrackableObject wraps an object for change tracking and client synchronization on the host side.
 * It manages property changes, client-specific views, and message generation for create, change, delete, and execute operations.
 */
export declare class HostObjectInfo<T extends object> extends ObjectInfoBase {
	private _isRootObject;
	private readonly _objectIdPrefix;
	/**
	 * Creates a TrackableObject from a plain object, optionally specifying typeId and objectId.
	 * Registers tracked properties and initializes their values.
	 */
	static createFromObject<T extends object>(settings: ServerObjectSyncMetaInfoCreateSettings<T>): HostObjectInfo<T>;
	/**
	 * Ensures an object is auto-trackable, returning a TrackableObject if possible.
	 * If the object is already trackable, returns the existing wrapper.
	 */
	static tryEnsureAutoTrackable<T extends object>(settings: ServerObjectSyncMetaInfoCreateSettings<T>): HostObjectInfo<T> | null;
	/** Holds the current set of property changes for this object. */
	private readonly _changeSet;
	/** Holds pending method invocation messages for this object. */
	private readonly _methodInvokeCalls;
	/** Holds client filter settings for restricting visibility. */
	private _clientFilters;
	/** Holds all registered client-specific views for this object. */
	private _views;
	/** Holds the set of clients which know about this. */
	private _clients;
	/**
	 * Constructs a TrackableObject with a typeId and optional objectId.
	 */
	private constructor();
	get clients(): Set<ClientConnection>;
	get isRootObject(): boolean;
	set isRootObject(value: boolean);
	get properties(): PropertyInfos<T, AdditionalHostPropertyInfo>;
	/**
	 * Determines if this object is visible to a given client based on filters.
	 */
	isForClient(client: ClientConnection): boolean;
	/**
	 * Adds a client-specific view to this object.
	 */
	addView(view: ClientSpecificView<T>): void;
	/**
	 * Removes a client-specific view from this object.
	 * @returns true if the view was removed, false otherwise.
	 */
	removeView(view: ClientSpecificView<T>): boolean;
	/**
	 * Returns all registered client-specific views for this object.
	 */
	get allRegisteredViews(): readonly ClientSpecificView<T>[];
	/**
	 * Returns all views that apply to a given client.
	 */
	getViewsForClient(client: ClientConnection): ClientSpecificView<T>[];
	/**
	 * Removes all client restrictions, making the object visible to all clients.
	 */
	removeClientRestrictions(): void;
	/**
	 * Restricts the object to a set of clients (inclusive or exclusive).
	 */
	setClientRestriction(filter: ClientFilter): void;
	/**
	 * Records a property change, converting values to trackable references if needed.
	 */
	onPropertyChanged(key: keyof T, value: T[keyof T]): void;
	/**
	 * Records a method execution for this object, converting arguments to trackable references if needed.
	 */
	onMethodExecute(method: keyof T, ...args: any[]): void;
	/**
	 * Converts a value to a trackable object reference if possible.
	 */
	convertToTrackableObjectReference(target: object): HostObjectInfo<object> | null;
	/**
	 * Generates a create message for this object for a given client, applying any view-based typeId overrides.
	 * Returns null if the object should not be sent to the client.
	 */
	getCreateMessage(client: ClientConnection): CreateObjectMessage<T> | null;
	/**
	 * Generates a delete message for this object.
	 */
	getDeleteMessage(): DeleteObjectMessage;
	/**
	 * Generates a change message for this object for a given client, including only changed properties.
	 * Returns null if there are no changes.
	 */
	getChangeMessage(client: ClientConnection): ChangeObjectMessage<T> | null;
	/**
	 * Returns all pending execute messages for this object.
	 */
	getExecuteMessages(client: ClientConnection): ExecuteObjectMessage<T>[];
	/**
	 * Gathers property info for this object for a given client, applying any view-based property overrides.
	 * If includeChangedOnly is true, only changed properties are included.
	 */
	private getProperties;
	/**
	 * Resets the hasPendingChanges flag for all properties and clears pending method calls.
	 */
	tick(): void;
}
export declare const objectSyncSymbol: unique symbol;
export type ObjectSyncMetaInfo = {
	objectId: unknown;
	typeId: string;
	object: object;
	client?: ClientObjectInfo<any>;
	host?: HostObjectInfo<any>;
};
export declare class ObjectInfoBase {
	private readonly _objectSyncMetaInfo;
	constructor(_objectSyncMetaInfo: ObjectSyncMetaInfo);
	get objectId(): unknown;
	get typeId(): string;
	get object(): object;
	get objectSyncMetaInfo(): ObjectSyncMetaInfo;
}
export declare function getObjectSyncMetaInfo(target: object): ObjectSyncMetaInfo | undefined;
export declare function createObjectId(objectIdPrefix: string): string;
export type ObjectSyncMetaInfoCreateSettings<T extends object = object> = {
	object: T;
	objectIdPrefix: string;
	typeId?: string;
	objectId?: unknown;
} | {
	object: T;
	typeId: string;
	objectId: unknown;
};
export declare function ensureObjectSyncMetaInfo(settings: ObjectSyncMetaInfoCreateSettings): ObjectSyncMetaInfo;
export declare function getHostObjectInfo<T extends object>(obj: T): HostObjectInfo<T> | null;
export declare function getClientObjectInfo<T extends object>(obj: T): ClientObjectInfo<T> | null;
export declare class TrackedObjectPool {
	private _trackedObjectInfos;
	add(object: object): void;
	delete(object: object): boolean;
	deleteById(objectId: unknown): boolean;
	get(objectId: unknown): object | null;
	has(object: object): boolean;
	hasById(objectId: unknown): boolean;
	get allMetaInfos(): ObjectSyncMetaInfo[];
	get all(): object[];
}
export type Constructor<T = any> = {
	new (...args: any[]): T;
};
export type TrackableTargetGenerator<T extends object = any> = {
	getType(client: ObjectSyncClient, properties: ResolvablePropertyInfos<T>, objectId: unknown, typeId: string): Constructor;
	create(client: ObjectSyncClient, properties: ResolvablePropertyInfos<T>, objectId: unknown, typeId: string): T;
};
export declare const defaultConstructorsByTypeId: Map<string, Constructor<any>>;
export declare const defaultGeneratorsByTypeId: Map<string, TrackableTargetGenerator<any>>;
export type ObjectSyncClientSettings = {
	clientId?: unknown;
	objectPool?: TrackedObjectPool;
	designation?: string;
};
export type ClientApplyResult = {
	newTrackedObjects: object[];
	methodExecuteResults: MethodExecuteResult[];
};
export declare class ObjectSyncClient {
	private readonly _settings;
	private _trackedObjectPool;
	private _typeIdToConstructor;
	private _typeIdToGenerator;
	private _pendingCreationMessages;
	private _currentClientApplyResult;
	private readonly _clientId;
	constructor(_settings?: ObjectSyncClientSettings);
	get clientId(): unknown;
	registerConstructorOrGenerator(typeId: string, constructorOrGenerator: Constructor | TrackableTargetGenerator): void;
	registerConstructor(typeId: string, constructor: Constructor): void;
	registerGenerator(typeId: string, generator: TrackableTargetGenerator): void;
	apply(messages: Message<any>[]): ClientApplyResult;
	/**
	 * Resolves a property value, returning the tracked object if objectId is present, or the value otherwise.
	 * If the object is not yet tracked, attempts to create it from pending messages.
	 */
	getPropertyValue(property: {
		objectId?: unknown;
		value?: any;
	}): any;
	findObjectOfType<T extends object>(constructor: Constructor<T>, objectId?: unknown): T | null;
	findObjectsOfType<T extends object>(constructor: Constructor<T>): number | T[];
	get allTrackedObjects(): object[];
	private deleteTrackedObject;
	private constructObject;
	private createResolvablePropertyInfos;
	private createNewTrackedObject;
	private handleChanges;
	private executeMethod;
}
export declare const onCreated: unique symbol;
export declare const onUpdated: unique symbol;
export declare const onUpdateProperty: unique symbol;
export declare const onDeleted: unique symbol;
export interface ITrackableOnCreated<T extends object> {
	[onCreated](changes: CreateObjectMessage<T>): void;
}
export interface ITrackableOnUpdated<T extends object> {
	[onUpdated](changes: ChangeObjectMessage<T>): void;
}
export interface ITrackableOnDeleted {
	[onDeleted](): void;
}
export interface ITrackableOnUpdateProperty<T extends object> {
	[onUpdateProperty](key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectSyncClient): boolean;
}
export declare function invokeOnCreated<T extends object>(obj: T, changes: CreateObjectMessage<T>): void;
export declare function invokeOnUpdated<T extends object>(obj: T, changes: ChangeObjectMessage<T>): void;
export declare function invokeOnDeleted<T extends object>(obj: T): void;
export declare function invokeOnUpdateProperty<T extends object>(obj: T, key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectSyncClient): boolean;
declare const onConvertedToTrackable: unique symbol;
declare const onTick: unique symbol;
export interface ITrackedOnConvertedToTrackable<T extends object> {
	[onConvertedToTrackable](info: HostObjectInfo<T>): void;
}
export interface ITrackedOnTick<T extends object> {
	[onTick](): void;
}
export type SyncableArrayChange<T> = {
	start: number;
	deleteCount: number;
	items: PropertyInfo<any, any>[];
};
export declare class SyncableArray<T> implements ITrackableOnUpdateProperty<any>, ITrackedOnConvertedToTrackable<SyncableArray<T>>, ITrackedOnTick<SyncableArray<T>> {
	private _values;
	private _changes;
	private _creation;
	constructor(initial?: T[]);
	get value(): T[];
	set value(value: T[]);
	clear(): void;
	changeAt(index: number, value: T): void;
	get length(): number;
	set length(value: number);
	push(...items: T[]): number;
	private convertPropertyInfosToItems;
	splice(start: number, deleteCount?: number, ...items: T[]): T[];
	private addChange;
	private convertItemsToPropertyInfos;
	private convertItemToPropertyInfo;
	[Symbol.iterator](): ArrayIterator<T>;
	private onPropertyChanged;
	[onTick](): void;
	[onConvertedToTrackable](hostObjectInfo: HostObjectInfo<SyncableArray<T>>): void;
	[onUpdateProperty](key: string | number | symbol, value: any, isForCreate: boolean, client: ObjectSyncClient): boolean;
	private applyTrackableArrayChanges;
	toJSON(): T[];
	toValue(): T[];
	protected onRemoved(start: number, items: T[]): void;
	protected onAdded(start: number, items: T[]): void;
}
export type ObjectSyncSettings = {
	objectIdPrefix?: string;
	designation?: string;
};
export declare class ObjectSync {
	private _settings;
	private readonly _host;
	private readonly _client;
	constructor(_settings: ObjectSyncSettings);
	get host(): ObjectSyncHost;
	get client(): ObjectSyncClient;
	getMessages(): Map<ClientConnection, Message[]>;
	applyMessages(messagesByClient: Map<ClientConnection, Message[]>): void;
}
type Constructor$1<T = any> = {
	new (...args: any[]): T;
};
export type TrackedPropertySettings = {
	designations?: string;
};
export type TrackableConstructorInfo = {
	trackedProperties: Map<string, TrackedPropertySettings>;
	trackedMethods: Map<string, TrackedPropertySettings>;
	isAutoTrackable: boolean;
	typeId?: string;
	designations?: OneOrMany<string>;
};
export type TrackableObjectSettings<T extends object = any> = {
	typeId?: string;
	generator?: TrackableTargetGenerator<T>;
	designations?: OneOrMany<string>;
	properties?: {
		[propertyKey: string]: TrackedPropertySettings;
	};
	methods?: {
		[methodKey: string]: TrackedPropertySettings;
	};
};
/**
 * Property accessor decorator for marking a property as trackable.
 * Registers the property and ensures changes are propagated to all TrackableObject instances.
 */
export declare function syncProperty<This, Return>(settings?: TrackedPropertySettings): <This_1, Return_1>(target: ClassAccessorDecoratorTarget<This_1, Return_1>, context: ClassAccessorDecoratorContext<This_1, Return_1>) => ClassAccessorDecoratorResult<This_1, Return_1>;
/**
 * Method decorator for marking a method as trackable.
 * Ensures method calls are recorded for all TrackableObject instances.
 */
export declare function syncMethod<This, Return>(settings?: TrackedPropertySettings): (target: any, context: ClassMethodDecoratorContext) => (this: any, ...args: any[]) => any;
/**
 * Retrieves the TrackableConstructorInfo metadata for a class constructor, if present.
 */
export declare function getTrackableTypeInfo(ctor: Constructor$1): TrackableConstructorInfo | null;
/**
 * Class decorator for marking a class as auto-trackable by the host.
 * Can be used as @syncObject or @syncObject("typeId").
 * Registers the class for automatic tracking and assigns a typeId if provided.
 */
export declare function syncObject<T extends object = any>(settings?: TrackableObjectSettings<T>): any;
export declare function checkCanUseProperty(constructor: Constructor$1, propertyKey: string, designation: string | undefined): boolean;
export declare function checkCanUseMethod(constructor: Constructor$1, propertyKey: string, designation: string | undefined): boolean;
export declare function checkCanUseObject(obj: object, designation: string | undefined): boolean;
export declare function checkCanUseConstructor(constructor: Constructor$1, designation: string | undefined): boolean;

export {};
