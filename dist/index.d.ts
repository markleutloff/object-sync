// Generated by dts-bundle-generator v9.5.1

declare const isPropertyInfoSymbol: unique symbol;
export type PropertyInfo<T extends object, TKey extends keyof T> = {
	value?: T[TKey];
	objectId?: unknown;
	typeId?: string;
	[isPropertyInfoSymbol]?: true;
};
export type PropertyInfos<T extends object, TAdditionalPropertyInfo extends object = object> = {
	[K in keyof T]?: PropertyInfo<T, K> & TAdditionalPropertyInfo;
};
export type ResolvablePropertyInfos<T> = {
	deleteProperty(key: keyof T & string): void;
	get deletedProperties(): (keyof T & string)[];
} & {
	[K in keyof T]?: T[K];
};
export type MessageBase = {
	type: string;
	objectId: unknown;
};
export type DeleteObjectMessage = MessageBase & {
	type: "delete";
};
export type CreateObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {
	type: "create";
	typeId: string;
	properties: PropertyInfos<T, TAdditionalPropertyInfo>;
};
export type ChangeObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {
	type: "change";
	properties: PropertyInfos<T, TAdditionalPropertyInfo>;
};
export type ExecuteObjectMessage<T extends object> = MessageBase & {
	type: "execute";
	id: unknown;
	method: keyof T & string;
	parameters: PropertyInfos<any, any>[];
};
export type Message<T extends object = object, TAdditionalPropertyInfo extends object = object> = DeleteObjectMessage | CreateObjectMessage<T, TAdditionalPropertyInfo> | ChangeObjectMessage<T, TAdditionalPropertyInfo> | ExecuteObjectMessage<T>;
export type MethodExecuteResult = {
	id: unknown;
	objectId: unknown;
	result: any;
	status: "resolved" | "rejected";
	error: any;
};
declare class ObjectInfoBase {
	private readonly _objectSyncMetaInfo;
	constructor(_objectSyncMetaInfo: ObjectSyncMetaInfo);
	get objectId(): unknown;
	get typeId(): string;
	get object(): object;
	get objectSyncMetaInfo(): ObjectSyncMetaInfo;
}
export type OneOrMany<T> = T | Iterable<T>;
export type Constructor<T = any> = {
	new (...args: any[]): T;
};
export type NativeTypeSerializer = TypeSerializer<any> & {
	typeId: string;
};
declare const nativeArraySerializer: NativeTypeSerializer;
declare const nativeMapSerializer: NativeTypeSerializer;
declare const nativeSetSerializer: NativeTypeSerializer;
declare const nativeObjectSerializer: NativeTypeSerializer;
declare const nativeTypeSerializers: NativeTypeSerializer[];
export type PropertyChanges<T> = {
	[K in keyof T]?: {
		value: T[K];
		hasPendingChanges: boolean;
	};
};
export type TResult<T, K extends keyof T> = T[K] extends (...args: any[]) => any ? ReturnType<T[K]> : never;
export type SyncMethodInvokeResult<T, K extends keyof T> = {
	clientResults: MethodCallResult<TResult<T, K>>;
	hostResult: TResult<T, K>;
};
export type SyncCallProxy<T> = {
	[P in keyof T & string as T[P] extends (...args: any[]) => any ? P : never]: T[P] extends (...args: infer A) => any ? (...args: A) => SyncMethodInvokeResult<T, P> : never;
};
export type ClientFilter = {
	/**
	 * Set of clients to include or exclude
	 */
	clients?: OneOrMany<ClientConnection>;
	/**
	 * Set of client designations to include or exclude
	 */
	designations?: OneOrMany<string>;
	/**
	 * If true, only the specified clients are included; if false, they are excluded, default is true
	 */
	isExclusive?: boolean;
};
export type ChangeTrackerObjectSyncMetaInfoCreateSettings<T extends object> = ObjectSyncMetaInfoCreateSettings<T> & {
	isRoot: boolean;
	objectIdPrefix: string;
	owner: ObjectChangeTracker;
};
export type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
export type MethodCallResultByClient<T> = Map<ClientConnection, Promise<UnwrapPromise<T>>>;
export type MethodCallResult<T> = Promise<MethodCallResultByClient<T>>;
/**
 * Wraps an object for change tracking and client synchronization on the host side.
 * It manages property changes, client-specific views, and message generation for create, change, delete, and execute operations.
 */
export declare class ChangeTrackerObjectInfo<T extends object> extends ObjectInfoBase {
	private readonly _tracker;
	private _isRootObject;
	private readonly _objectIdPrefix;
	/**
	 * Ensures an object is auto-trackable, returning a TrackableObject if possible.
	 * If the object is already trackable, returns the existing wrapper.
	 */
	static create<T extends object>(settings: ChangeTrackerObjectSyncMetaInfoCreateSettings<T>): ChangeTrackerObjectInfo<T> | null;
	/** Holds the current set of property changes for this object. */
	private readonly _changeSet;
	/** Holds pending method invocation messages for this object. */
	private readonly _methodInvokeCalls;
	private readonly _pendingMethodInvokeCalls;
	/** Holds client filter settings for restricting visibility. */
	private _clientFilters;
	/** Holds the set of clients which know about this. */
	private _clients;
	private _invokeProxy;
	private _lastMethodCallResult;
	/**
	 * Constructs a TrackableObject with a typeId and optional objectId.
	 */
	private constructor();
	get tracker(): ObjectChangeTracker;
	get clients(): Set<ClientConnection>;
	get isRootObject(): boolean;
	set isRootObject(value: boolean);
	get properties(): PropertyChanges<T>;
	get invokeProxy(): SyncCallProxy<T>;
	/**
	 * Determines if this object is visible to a given client based on filters.
	 */
	isForClient(client: ClientConnection): boolean;
	/**
	 * Removes all client restrictions, making the object visible to all clients.
	 */
	removeClientRestrictions(): void;
	/**
	 * Restricts the object to a set of clients (inclusive or exclusive).
	 */
	setClientRestriction(filter: ClientFilter): void;
	/**
	 * Records a property change, converting values to trackable references if needed.
	 */
	onPropertyChanged(key: keyof T, value: T[keyof T]): void;
	createPropertyInfo(value: any): PropertyInfo<T, keyof T>;
	/**
	 * Records a method execution for this object, converting arguments to trackable references if needed.
	 */
	onMethodExecute(method: keyof T, parameters: any[]): Promise<Map<ClientConnection, Promise<T>>>;
	getInvokeResults<K extends keyof T = any>(method?: K): MethodCallResult<TResult<T, K>> | null;
	invoke<K extends keyof T>(method: K, ...args: T[K] extends (...a: infer P) => any ? P : never): SyncMethodInvokeResult<T, K>;
	onClientMethodExecuteResultReceived(methodExecuteResult: MethodExecuteResult, client: ClientConnection): void;
	/**
	 * Converts a value to a trackable object reference if possible.
	 */
	convertToTrackableObjectReference(target: object): ChangeTrackerObjectInfo<object> | null;
	/**
	 * Generates a create message for this object for a given client, applying any view-based typeId overrides.
	 * Returns null if the object should not be sent to the client.
	 */
	getCreateMessage(client: ClientConnection): CreateObjectMessage<T> | null;
	/**
	 * Generates a delete message for this object.
	 */
	getDeleteMessage(): DeleteObjectMessage;
	onClientRemoved(clientConnection: ClientConnection): void;
	cancelPendingMethodCalls(clientConnection?: ClientConnection): void;
	/**
	 * Generates a change message for this object for a given client, including only changed properties.
	 * Returns null if there are no changes.
	 */
	getChangeMessage(client: ClientConnection): ChangeObjectMessage<T> | null;
	/**
	 * Returns all pending execute messages for this object.
	 */
	getExecuteMessages(client: ClientConnection): ExecuteObjectMessage<T>[];
	/**
	 * Gathers property info for this object for a given client, applying any view-based property overrides.
	 * If includeChangedOnly is true, only changed properties are included.
	 */
	private getProperties;
	private serializePropertyInfo;
	private serializeValue;
	/**
	 * Resets the hasPendingChanges flag for all properties and clears pending method calls.
	 */
	tick(): void;
}
export type TrackSettings = {
	/**
	 * Optional unique identifier for the object; if not provided, one will be generated.
	 */
	objectId?: unknown;
	/**
	 * If true, the object is considered a root object. Defaults to true.
	 */
	isRoot?: boolean;
	/**
	 * Settings for restricting client visibility of the object.
	 */
	clientVisibility?: ClientFilter;
	knownClients?: OneOrMany<ClientConnection>;
};
export type ObjectChangeTrackerSettings = {
	objectIdPrefix: string;
	objectPool: TrackedObjectPool;
	identity: string;
	typeSerializers: Map<string, TypeSerializer<any>>;
	nativeTypeSerializers: NativeTypeSerializer[];
};
export type FinalObjectChangeTrackerSettings = {
	objectIdPrefix: string;
	identity: string;
};
/**
 * Settings for a client connection.
 */
export type ClientConnectionSettings = {
	/**
	 * Identity of the client (e.g., "host", "client1", etc.).
	 */
	identity: string;
};
/**
 * Representation of a connection to a client.
 */
export type ClientConnection = {
	/**
	 * Identity of the client (e.g., "host", "client1", etc.).
	 */
	identity: string;
};
/**
 * The ChangeTrackerHost manages the lifecycle and visibility of trackable objects on the host/server side.
 * It tracks which objects are visible to which clients, manages object creation/deletion, and generates messages for clients.
 */
export declare class ObjectChangeTracker {
	/** Pool of all currently tracked objects and their info. */
	private _trackedObjectPool;
	private _clients;
	private _serializers;
	private _nativeTypeSerializers;
	private readonly _settings;
	constructor(settings: ObjectChangeTrackerSettings);
	get settings(): FinalObjectChangeTrackerSettings;
	registerSerializer(serializer: TypeSerializer<any> & {
		typeId: string;
	}): void;
	get identity(): string;
	/** Returns all currently tracked objects. */
	get allTrackedObjects(): object[];
	registerClient(settings: ClientConnectionSettings): ClientConnection;
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	removeClient(client: ClientConnection): void;
	/**
	 * Restricts the visibility of a tracked object to a set of clients.
	 * @param obj The object to restrict.
	 * @param clients The client(s) allowed or excluded.
	 * @param isExclusive If true, only the given clients can see the object; otherwise, all except these clients can see it.
	 */
	setClientRestriction<T extends object>(obj: T, filter: ClientFilter): void;
	/**
	 * Begins tracking an object, optionally with settings for object ID and client visibility.
	 * Throws if objectId is specified for an already-trackable object.
	 */
	track<T extends object>(target: T, trackSettings?: TrackSettings): void;
	private trackInternal;
	/**
	 * Stops tracking an object and queues delete messages for all clients that could see it.
	 * If an object is passed instead of a TrackableObject, it will first be looked up.
	 */
	untrack<T extends object>(target: T): void;
	private untrackInternal;
	getMessages(clientOrClients?: OneOrMany<ClientConnection>): Map<ClientConnection, Message[]>;
	private gatherMessagesForObjectGraph;
	private gatherSubTrackablesForGraphFromMessage;
	private gatherSubTrackablesForGraphFromValue;
	applyClientMethodInvokeResults(client: ClientConnection, methodExecuteResults: MethodExecuteResult[]): void;
	tick(): void;
	serializeValue(value: object, trackerInfo: ChangeTrackerObjectInfo<any>): {
		value: any;
		typeId: string;
	} | null;
}
export type CanTrackPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	info: ChangeTrackerObjectInfo<T>;
};
export type CanApplyPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	sourceClientConnection: ClientConnection;
};
export type TrackedPropertySettingsBase<T extends object> = {
	/**
	 * Returns true when the property/method should be tracked.
	 */
	canTrack?<TKey extends keyof T & string>(this: T, payload: CanTrackPayload<T, TKey>): boolean;
	/**
	 *  Returns true when the property/method change should be applied.
	 */
	canApply?<TKey extends keyof T & string>(this: T, payload: CanApplyPayload<T, TKey>): boolean;
	/**
	 * Defines how the property/method should be tracked/applied.
	 * - "trackAndApply": Changes to the property/method are tracked and applied (thats the default).
	 * - "trackOnly": Changes to the property/method are only tracked, not applied.
	 * - "applyOnly": Changes to the property/method are only applied, not tracked.
	 * - "none": Changes to the property/method are neither tracked nor applied.
	 */
	mode?: "trackAndApply" | "trackOnly" | "applyOnly" | "none";
};
export type BeforeSendToClientPayload<T extends object, TKey extends keyof T & string, TValue> = {
	instance: T;
	key: TKey;
	value: TValue;
	destinationClientConnection: ClientConnection;
};
export type TrackedPropertySettings<T extends object, TValue> = TrackedPropertySettingsBase<T> & {
	/**
	 * Function which is called before sending the property value to the client.
	 * Can be used to modify or filter the value being sent.
	 * When the symbol value "nothing" is returned, the property update will be skipped.
	 */
	beforeSendToClient?<TKey extends keyof T & string>(this: T, payload: BeforeSendToClientPayload<T, TKey, TValue>): TValue | typeof nothing;
};
/**
 * A unique symbol used to indicate that no value should be sent or processed.
 */
export declare const nothing: unique symbol;
export type BeforeExecuteOnClientPayload<T extends object, TKey extends keyof T & string> = {
	instance: T;
	key: TKey;
	args: T[TKey] extends (...args: infer P) => any ? P : never;
	destinationClientConnection: ClientConnection;
};
export type TrackedMethodSettings<T extends object> = TrackedPropertySettingsBase<T> & {
	/**
	 * Defines how method execution should handle returned Promises.
	 * - "await": The method call will be awaited, and the resolved value will be used or the rejection will be sent back to the client.
	 * - "normal": The Promise will be returned as-is without awaiting, once settled the result will be sent back to the client.
	 * If not set, the default behavior is "normal".
	 */
	promiseHandlingType?: "await" | "normal";
	/**
	 * Function which is called before sending the method execution call to the client.
	 * Can be used to prevent the method call from being sent.
	 * When false is returned, the method call will be skipped.
	 */
	beforeExecuteOnClient?<TKey extends keyof T & string>(this: T, payload: BeforeExecuteOnClientPayload<T, TKey>): boolean;
};
export type BeforeSendTypeToClientPayload<T extends object> = {
	instance: T;
	constructor: Constructor<T>;
	typeId: string;
	destinationClientConnection: ClientConnection;
};
export type TrackableObjectSettings<T extends object> = {
	typeId?: string;
	generator?: TrackableTargetGenerator<T>;
	properties?: {
		[propertyKey: string]: TrackedPropertySettings<T, any>;
	};
	methods?: {
		[methodKey: string]: TrackedMethodSettings<T>;
	};
	/**
	 * Function which is called before sending the object to the client.
	 * Can be used to modify or filter the typeId being sent.
	 * When the "nothing" symbol, null or undefined is returned, the object creation will be skipped.
	 */
	beforeSendToClient?(this: T, payload: BeforeSendTypeToClientPayload<T>): string | typeof nothing | Constructor | null | undefined;
};
/**
 * Property accessor decorator for marking a property as trackable.
 * Registers the property and ensures changes are propagated to all TrackableObject instances.
 */
export declare function syncProperty<This extends object, Return>(settings?: TrackedPropertySettings<This, Return>): (target: ClassAccessorDecoratorTarget<This, Return>, context: ClassAccessorDecoratorContext<This, Return>) => ClassAccessorDecoratorResult<This, Return>;
/**
 * Method decorator for marking a method as trackable.
 * Ensures method calls are recorded for all TrackableObject instances.
 */
export declare function syncMethod<This extends object, Return>(settings?: TrackedMethodSettings<This>): (target: any, context: ClassMethodDecoratorContext) => (this: any, ...args: any[]) => any;
/**
 * Class decorator for marking a class as auto-trackable by the host.
 * Can be used as @syncObject or @syncObject("typeId").
 * Registers the class for automatic tracking and assigns a typeId if provided.
 */
export declare function syncObject<This extends abstract new (...args: any) => any>(settings?: TrackableObjectSettings<InstanceType<This>>): (target: This, context: ClassDecoratorContext<This>) => void;
export type TypeGenerator = Constructor | TrackableTargetGenerator;
export type TrackableTargetGenerator<T = any> = (client: ObjectChangeApplicator, properties: ResolvablePropertyInfos<T>, objectId: unknown, typeId: string) => T;
export type TypeSerializer<T> = {
	/**
	 * The type ID of the type being serialized/deserialized.
	 * When not provided, the type ID will be inferred from the name of the constructor.
	 */
	typeId?: string;
	/**
	 * The constructor of the type being serialized/deserialized.
	 * When no function to serialize/deserialize is provided, this constructor will be used for deserialization and instance.toJSON()/toValue() for serialization.
	 */
	type: Constructor<T>;
} & ({
	/**
	 * Function to deserialize a value.
	 */
	deserialize: undefined;
	/**
	 * Function to serialize a value.
	 */
	serialize: undefined;
} | {
	/**
	 * Function to deserialize a value.
	 */
	deserialize(value: any, applicator: ObjectChangeApplicator, clientConnection: ClientConnection): T;
	/**
	 * Function to serialize an instance.
	 */
	serialize(instance: T, trackerInfo: ChangeTrackerObjectInfo<any>): any;
});
export declare const allTypeGenerators: Map<string, TypeGenerator>;
export type ObjectChangeApplicatorSettings = {
	objectPool: TrackedObjectPool;
	identity: string;
	typeGenerators: Map<string, TypeGenerator>;
	typeSerializers: Map<string, TypeSerializer<any>>;
	nativeTypeSerializers: NativeTypeSerializer[];
};
export type FinalObjectChangeApplicatorSettings = {
	identity: string;
};
export type ClientApplyResult = {
	newTrackedObjects: object[];
	methodExecuteResults: MethodExecuteResult[];
};
export declare class ObjectChangeApplicator {
	private _trackedObjectPool;
	private _pendingCreationMessages;
	private _currentClientApplyResult;
	private readonly _settings;
	private readonly _typeGenerators;
	private readonly _typeSerializers;
	private readonly _nativeTypeSerializers;
	constructor(settings: ObjectChangeApplicatorSettings);
	get settings(): FinalObjectChangeApplicatorSettings;
	get identity(): string;
	registerGenerator(typeId: string, generator: TypeGenerator): void;
	applyAsync(messages: Message<any>[], clientConnection: ClientConnection): Promise<ClientApplyResult>;
	/**
	 * Resolves a property value, returning the tracked object if objectId is present, or the value otherwise.
	 * If the object is not yet tracked, attempts to create it from pending messages.
	 */
	getPropertyValue(property: PropertyInfo<any, any>, clientConnection: ClientConnection): any;
	findObjectOfType<T extends object>(constructor: Constructor<T>, objectId?: unknown): T | null;
	findObjectsOfType<T extends object>(constructor: Constructor<T>): T[];
	get allTrackedObjects(): object[];
	private deleteTrackedObject;
	private constructObject;
	private createResolvablePropertyInfos;
	private createNewTrackedObject;
	private handleChanges;
	private executeMethodAsync;
	private deserializeValue;
}
export declare class ApplicatorObjectInfo<T extends object> extends ObjectInfoBase {
	private readonly _applicator;
	constructor(objectSyncMetaInfo: ObjectSyncMetaInfo, _applicator: ObjectChangeApplicator);
	get applicator(): ObjectChangeApplicator;
}
export type ObjectSyncMetaInfo = {
	/**
	 * The unique identifier for the object.
	 */
	objectId: unknown;
	/**
	 * The type identifier for the object.
	 */
	typeId: string;
	/**
	 * The actual object being tracked.
	 */
	object: object;
	/**
	 * The ApplicatorObjectInfo associated with the object, if any.
	 */
	applicatorInfo?: ApplicatorObjectInfo<any>;
	/**
	 * The ChangeTrackerObjectInfo associated with the object, if any.
	 */
	trackerInfo?: ChangeTrackerObjectInfo<any>;
};
export declare function getObjectSyncMetaInfo(target: object): ObjectSyncMetaInfo | undefined;
export type ObjectSyncMetaInfoCreateSettings<T extends object = object> = {
	object: T;
} & ({
	objectIdPrefix: string;
	typeId?: string;
	objectId?: unknown;
} | {
	typeId: string;
	objectId: unknown;
});
export declare function getTrackerObjectInfo<T extends object>(obj: T): ChangeTrackerObjectInfo<T> | null;
export declare function getApplicatorObjectInfo<T extends object>(obj: T): ApplicatorObjectInfo<T> | null;
export declare class TrackedObjectPool {
	private _trackedObjectInfos;
	add(object: object): void;
	delete(object: object): boolean;
	deleteById(objectId: unknown): boolean;
	get(objectId: unknown): object | null;
	has(object: object): boolean;
	hasById(objectId: unknown): boolean;
	get allMetaInfos(): ObjectSyncMetaInfo[];
	get all(): object[];
}
export declare const onCreated: unique symbol;
export declare const onUpdated: unique symbol;
export declare const onUpdateProperty: unique symbol;
export declare const onDelete: unique symbol;
export declare const onDeleted: unique symbol;
/**
 * Interface for objects that need to manually handle creation events.
 */
export interface ITrackableOnCreated<T extends object> {
	[onCreated](changes: CreateObjectMessage<T>, client: ObjectChangeApplicator, clientConnection?: ClientConnection): void;
}
/**
 * Interface for objects that need to manually handle update events.
 * This is called after an object has been updated.
 */
export interface ITrackableOnUpdated<T extends object> {
	[onUpdated](changes: ChangeObjectMessage<T>, client: ObjectChangeApplicator, clientConnection?: ClientConnection): void;
}
/**
 * Interface for objects that need to handle deletion events.
 * This is called after an object has been deleted.
 */
export interface ITrackableOnDeleted {
	[onDeleted](client: ObjectChangeApplicator, clientConnection?: ClientConnection): void;
}
/**
 * Interface for objects that need to handle deletion requests.
 * This is called before an object is deleted, allowing for cleanup or vetoing the deletion.
 */
export interface ITrackableOnDelete {
	[onDelete](client: ObjectChangeApplicator, clientConnection?: ClientConnection): boolean;
}
/**
 * Interface for objects that need to manually handle property updates.
 * This is called when a specific property of the object is updated.
 */
export interface ITrackableOnUpdateProperty<T extends object> {
	[onUpdateProperty](key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectChangeApplicator, clientConnection: ClientConnection): boolean;
}
declare const onConvertedToTrackable: unique symbol;
declare const onTick: unique symbol;
export interface ITrackedOnConvertedToTrackable<T extends object> {
	[onConvertedToTrackable](info: ChangeTrackerObjectInfo<T>): void;
}
export interface ITrackedOnTick<T extends object> {
	[onTick](): void;
}
/**
 * A SyncableArray is an array-like structure that tracks changes made to its contents.
 * It allows for efficient synchronization of array data across different clients or systems.
 */
export declare class SyncableArray<T> implements ITrackableOnUpdateProperty<any>, ITrackedOnConvertedToTrackable<SyncableArray<T>>, ITrackedOnTick<SyncableArray<T>> {
	private _values;
	private _changes;
	private _creation;
	constructor(initial?: T[]);
	get value(): T[];
	set value(value: T[]);
	clear(): void;
	changeAt(index: number, value: T): void;
	get length(): number;
	set length(value: number);
	push(...items: T[]): number;
	private convertPropertyInfosToItems;
	splice(start: number, deleteCount?: number, ...items: T[]): T[];
	private addChange;
	private convertItemsToPropertyInfos;
	private convertItemToPropertyInfo;
	[Symbol.iterator](): ArrayIterator<T>;
	private onPropertyChanged;
	[onTick](): void;
	[onConvertedToTrackable](hostObjectInfo: ChangeTrackerObjectInfo<SyncableArray<T>>): void;
	[onUpdateProperty](key: string | number | symbol, value: any, isForCreate: boolean, client: ObjectChangeApplicator, clientConnection: ClientConnection): boolean;
	private applyTrackableArrayChanges;
	toJSON(): T[];
	toValue(): T[];
	protected onRemoved(start: number, items: T[]): void;
	protected onAdded(start: number, items: T[]): void;
}
export type EventFunction = (...args: any[]) => void;
export type EventMap = {
	[key: string]: EventFunction;
};
export type IEventEmitter<Events extends EventMap = EventMap> = {
	on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;
	listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event] | undefined): number;
};
export type SyncableObservableArrayEventMap = {
	added: (items: any[], start: number) => void;
	removed: (items: any[], start: number) => void;
};
/**
 * A SyncableObservableArray is a SyncableArray that emits events when items are added or removed.
 * This allows observers to react to changes in the array's contents.
 */
export declare class SyncableObservableArray<T> extends SyncableArray<T> implements IEventEmitter<SyncableObservableArrayEventMap> {
	private readonly _eventEmitter;
	constructor(initial?: T[]);
	protected onRemoved(start: number, items: T[]): void;
	protected onAdded(start: number, items: T[]): void;
	on<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	once<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	off<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void;
	listenerCount<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback?: SyncableObservableArrayEventMap[Event] | undefined): number;
}
export type ObjectSyncSettings = {
	/**
	 * Prefix for generated object IDs. When not provided, a default prefix based on identity and timestamp will be used.
	 */
	objectIdPrefix?: string;
	/**
	 * Identity of this ObjectSync instance (e.g., "host" or "client1").
	 */
	identity: string;
	/**
	 * Type generators to use for creating objects during synchronization.
	 * Can be provided as a Map of type IDs to generators or as an array of constructor functions.
	 * If not provided, all globally registered type generators will be used.
	 */
	typeGenerators?: Map<string, TypeGenerator> | Constructor[];
	/**
	 * Type serializers to use for serializing and deserializing property values during synchronization.
	 * Can be provided as a Map of type IDs to serializers or as an array of serializers.
	 */
	typeSerializers?: Map<string, TypeSerializer<any>> | TypeSerializer<any>[];
	/**
	 * Native type serializers to use for serializing and deserializing native types during synchronization.
	 * Can be provided as an array of native type serializers.
	 * When not provided, default native type serializers will be used.
	 */
	nativeTypeSerializers?: NativeTypeSerializer[];
};
/**
 * Main class for synchronizing objects between a host and clients.
 */
export declare class ObjectSync {
	private readonly _tracker;
	private readonly _applicator;
	private readonly _settings;
	private readonly _objectPool;
	constructor(settings: ObjectSyncSettings);
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states.
	 * @returns A map of client connections to messages.
	 */
	getMessages(): Map<ClientConnection, Message[]>;
	/**
	 * Gets all messages to be sent to clients.
	 * Will also reset internal tracking states when callTick is true.
	 * @param callTick Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(callTick: boolean): Map<ClientConnection, Message[]>;
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states.
	 * @param client The client connection to get messages for.
	 * @returns The messages for the specified client.
	 */
	getMessages(client: ClientConnection): Message[];
	/**
	 * Gets all messages to be sent to a single client.
	 * Will also reset internal tracking states when callTick is true.
	 * @param client The client connection to get messages for.
	 * @param callTick Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns The messages for the specified client.
	 */
	getMessages(client: ClientConnection, callTick: boolean): Message[];
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states.
	 * @param clients The client connections to get messages for.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clients: Iterable<ClientConnection>): Map<ClientConnection, Message[]>;
	/**
	 * Gets all messages to be sent to multiple clients.
	 * Will also reset internal tracking states when callTick is true.
	 * @param clients The client connections to get messages for.
	 * @param callTick Whether to advance the internal state of the tracker after gathering messages. Defaults to true.
	 * @returns A map of client connections to messages.
	 */
	getMessages(clients: Iterable<ClientConnection>, callTick: boolean): Map<ClientConnection, Message[]>;
	/**
	 * Advances the internal state of the tracker, preparing it for the next synchronization cycle.
	 */
	tick(): void;
	/**
	 * Applies messages from a client connection.
	 * @param messages The messages to apply.
	 * @param clientConnection The client connection the messages are from.
	 * @returns The results of method executions.
	 */
	applyAsync(messages: Message<any>[], clientConnection: ClientConnection): Promise<{
		newTrackedObjects: object[];
		methodExecuteResults: MethodExecuteResult[];
	}>;
	/**
	 * Applies method invoke results from clients to update tracked object invoke call states.
	 * @param resultsByClient A map of client connections to method invoke results.
	 */
	applyClientMethodInvokeResults(resultsByClient: Map<ClientConnection, MethodExecuteResult[]>): void;
	applyClientMethodInvokeResultsFromClient(clientConnection: ClientConnection, results: MethodExecuteResult[]): void;
	/**
	 * Applies messages from multiple clients.
	 * @param messagesByClient A map of client connections to messages.
	 * @returns A map of client connections to method execution results.
	 */
	applyMessagesAsync(messagesByClient: Map<ClientConnection, Message[]>): Promise<Map<ClientConnection, MethodExecuteResult[]>>;
	/**
	 * Applies messages from a single client.
	 * @param clientConnection The client connection the messages are from.
	 * @param messages The messages to apply.
	 * @returns The results of method executions.
	 */
	applyMessagesFromClientAsync(clientConnection: ClientConnection, messages: Message[]): Promise<MethodExecuteResult[]>;
	/**
	 * Exchanges messages with clients by sending messages and receiving method invoke results.
	 * @param sendToClientAsync Function to send messages to a client and receive method invoke results.
	 * @param errorHandler Optional function to handle errors.
	 */
	exchangeMessagesAsync(sendToClientAsync: (client: ClientConnection, messages: Message[]) => Promise<MethodExecuteResult[]>, errorHandler?: (client: ClientConnection, error: any) => void): Promise<void>;
	/**
	 * Exchanges messages in bulk with clients by sending messages and receiving method invoke results.
	 * @param sendToClientsAsync Function to send messages to clients and receive method invoke results.
	 * @param errorHandler Optional function to handle errors.
	 */
	exchangeMessagesBulkAsync(sendToClientsAsync: (messagesByClient: Map<ClientConnection, Message[]>) => Promise<Map<ClientConnection, MethodExecuteResult[]>>, errorHandler?: (client: ClientConnection, error: any) => void): Promise<void>;
	/**
	 * Registers a type serializer.
	 * @param serializer The type serializer to register.
	 */
	registerSerializer(serializer: TypeSerializer<any> & {
		typeId: string;
	}): void;
	/**
	 * Gets the identity of this ObjectSync instance.
	 */
	get identity(): string;
	/** Returns all currently tracked objects. */
	get allTrackedObjects(): object[];
	/**
	 * Registers a new client connection.
	 * @param settings Settings for the client connection.
	 * @returns The registered client connection.
	 */
	registerClient(settings: ClientConnectionSettings): ClientConnection;
	/**
	 * Removes all client-specific state for a client (e.g., when disconnecting).
	 */
	removeClient(client: ClientConnection): void;
	/**
	 * Begins tracking an object, optionally with settings for object ID and client visibility.
	 * Throws if objectId is specified for an already-trackable object.
	 */
	track<T extends object>(target: T, trackSettings?: TrackSettings): void;
	/**
	 * Stops tracking an object.
	 * @param target The target object to untrack.
	 */
	untrack<T extends object>(target: T): void;
	/**
	 * Sets a client restriction filter for a tracked object.
	 * @param obj The tracked object to set the filter for.
	 * @param filter The client restriction filter to apply.
	 */
	setClientRestriction<T extends object>(obj: T, filter: ClientFilter): void;
	/**
	 * Registers a type generator.
	 * @param typeId The type ID the generator is for.
	 * @param generator The type generator to register.
	 */
	registerGenerator(typeId: string, generator: TypeGenerator): void;
	/**
	 * Finds a tracked object by its constructor and optional object ID.
	 * @param constructor The constructor of the object type to find.
	 * @param objectId Optional object ID to find a specific object.
	 * @returns The found object, or undefined if not found.
	 */
	findObjectOfType<T extends object>(constructor: Constructor<T>, objectId?: unknown): T | null;
	/**
	 * Finds all tracked objects of a specific type.
	 * @param constructor The constructor of the object type to find.
	 * @returns An array of found objects.
	 */
	findObjectsOfType<T extends object>(constructor: Constructor<T>): T[];
	/**
	 * Returns a proxy for the target object that routes method calls through the ObjectSync system.
	 * Will also track the object if it is not already tracked as non root object.
	 * This is a helper function to easily get a method call proxy for an object.
	 * @param target The target object to create a method call proxy for.
	 * @returns A proxy object that routes method calls.
	 */
	getInvokeProxy<T extends object>(target: T): SyncCallProxy<T>;
	/**
	 * Invokes a method on the target object through the ObjectSync system.
	 * Will also track the object if it is not already tracked as non root object.
	 * This is a helper function to easily invoke methods on tracked objects.
	 * @param target The target object to invoke the method on.
	 * @param method The method name to invoke.
	 * @param args The arguments to pass to the method.
	 * @returns The result of the method invocation.
	 */
	invoke<T extends object, K extends keyof T>(target: T, method: K, ...args: T[K] extends (...a: infer P) => any ? P : never): SyncMethodInvokeResult<T, K>;
}

export {
	nativeArraySerializer as nativeArray,
	nativeMapSerializer as nativeMap,
	nativeObjectSerializer as nativeObject,
	nativeSetSerializer as nativeSet,
	nativeTypeSerializers as nativeTypeGenerators,
};

export {};
