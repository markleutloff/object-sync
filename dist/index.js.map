{
  "version": 3,
  "sources": ["../src/shared/decorators.ts", "../src/shared/messages.ts", "../src/applicator/trackableTarget.ts", "../src/shared/objectInfoBase.ts", "../src/applicator/applicatorObjectInfo.ts", "../src/applicator/applicator.ts", "../src/tracker/decorators.ts", "../src/shared/objectSyncMetaInfo.ts", "../src/shared/trackedObjectPool.ts", "../src/tracker/interfaces.ts", "../src/shared/syncableArray.ts", "../src/shared/eventEmitter.ts", "../src/shared/syncableObservableArray.ts", "../src/shared/types.ts", "../src/tracker/trackerObjectInfo.ts", "../src/tracker/tracker.ts", "../src/objectSync/objectSync.ts"],
  "sourcesContent": ["// declare symbol to contain a symbol and metadata\r\ndeclare global {\r\n  interface SymbolConstructor {\r\n    metadata: symbol;\r\n  }\r\n}\r\n// shim Symbol.metadata\r\nSymbol.metadata ??= Symbol(\"metadata\");\r\n\r\nexport {}; // to convert file into a module\r\n", "export const isPropertyInfoSymbol = Symbol(\"isPropertyInfo\");\r\n\r\nexport type PropertyInfo<T extends object, TKey extends keyof T> = {\r\n  value?: T[TKey];\r\n  objectId?: unknown;\r\n  typeId?: string;\r\n  [isPropertyInfoSymbol]?: true;\r\n};\r\n\r\nexport type PropertyInfos<T extends object, TAdditionalPropertyInfo extends object = object> = { [K in keyof T]?: PropertyInfo<T, K> & TAdditionalPropertyInfo };\r\nexport type ResolvablePropertyInfos<T> = {\r\n  deleteProperty(key: keyof T & string): void;\r\n  get deletedProperties(): (keyof T & string)[];\r\n} & {\r\n  [K in keyof T]?: T[K];\r\n};\r\n\r\nexport type MessageBase = {\r\n  type: string;\r\n  objectId: unknown;\r\n};\r\n\r\nexport type DeleteObjectMessage = MessageBase & { type: \"delete\" };\r\n\r\nexport type CreateObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {\r\n  type: \"create\";\r\n  typeId: string;\r\n  properties: PropertyInfos<T, TAdditionalPropertyInfo>;\r\n};\r\n\r\nexport type ChangeObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {\r\n  type: \"change\";\r\n  properties: PropertyInfos<T, TAdditionalPropertyInfo>;\r\n};\r\n\r\nexport type ExecuteObjectMessage<T extends object> = MessageBase & {\r\n  type: \"execute\";\r\n  id: unknown;\r\n  method: keyof T & string;\r\n  parameters: PropertyInfo<any, any>[];\r\n};\r\n\r\nexport type Message<T extends object = object, TAdditionalPropertyInfo extends object = object> =\r\n  | DeleteObjectMessage\r\n  | CreateObjectMessage<T, TAdditionalPropertyInfo>\r\n  | ChangeObjectMessage<T, TAdditionalPropertyInfo>\r\n  | ExecuteObjectMessage<T>;\r\n\r\nexport function isPropertyInfo(value: any): value is PropertyInfo<any, any> {\r\n  return isPropertyInfoSymbol in value;\r\n}\r\n\r\nexport type MethodExecuteResult = {\r\n  id: unknown;\r\n  objectId: unknown;\r\n  result: any;\r\n  status: \"resolved\" | \"rejected\";\r\n  error: any;\r\n};\r\n", "import type { ClientConnection } from \"../tracker/tracker.js\";\r\nimport { ChangeObjectMessage, CreateObjectMessage } from \"../shared/messages.js\";\r\nimport { ObjectChangeApplicator } from \"./applicator.js\";\r\n\r\nexport const onCreated = Symbol(\"onCreated\");\r\nexport const onUpdated = Symbol(\"onUpdated\");\r\nexport const onUpdateProperty = Symbol(\"onUpdateProperty\");\r\nexport const onDelete = Symbol(\"onDelete\");\r\nexport const onDeleted = Symbol(\"onDeleted\");\r\n\r\nexport interface ITrackableOnCreated<T extends object> {\r\n  [onCreated](changes: CreateObjectMessage<T>, client: ObjectChangeApplicator, clientConnection?: ClientConnection): void;\r\n}\r\n\r\nexport interface ITrackableOnUpdated<T extends object> {\r\n  [onUpdated](changes: ChangeObjectMessage<T>, client: ObjectChangeApplicator, clientConnection?: ClientConnection): void;\r\n}\r\n\r\nexport interface ITrackableOnDeleted {\r\n  [onDeleted](client: ObjectChangeApplicator, clientConnection?: ClientConnection): void;\r\n}\r\n\r\nexport interface ITrackableOnDelete {\r\n  [onDelete](client: ObjectChangeApplicator, clientConnection?: ClientConnection): boolean;\r\n}\r\n\r\nexport interface ITrackableOnUpdateProperty<T extends object> {\r\n  [onUpdateProperty](key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectChangeApplicator, clientConnection: ClientConnection): boolean;\r\n}\r\n\r\nfunction hasOnCreated<T extends object>(obj: any): obj is ITrackableOnCreated<T> {\r\n  return onCreated in obj;\r\n}\r\n\r\nfunction hasOnDeleted(obj: any): obj is ITrackableOnDeleted {\r\n  return onDeleted in obj;\r\n}\r\n\r\nfunction hasOnDelete(obj: any): obj is ITrackableOnDelete {\r\n  return onDelete in obj;\r\n}\r\n\r\nfunction hasOnUpdated<T extends object>(obj: any): obj is ITrackableOnUpdated<T> {\r\n  return onUpdated in obj;\r\n}\r\n\r\nfunction hasOnUpdateProperty<T extends object>(obj: any): obj is ITrackableOnUpdateProperty<T> {\r\n  return onUpdateProperty in obj;\r\n}\r\n\r\nexport function invokeOnCreated<T extends object>(obj: T, changes: CreateObjectMessage<T>, client: ObjectChangeApplicator, clientConnection?: ClientConnection) {\r\n  if (hasOnCreated<T>(obj)) {\r\n    obj[onCreated](changes, client, clientConnection);\r\n  }\r\n}\r\n\r\nexport function invokeOnUpdated<T extends object>(obj: T, changes: ChangeObjectMessage<T>, client: ObjectChangeApplicator, clientConnection?: ClientConnection) {\r\n  if (hasOnUpdated<T>(obj)) {\r\n    obj[onUpdated](changes, client, clientConnection);\r\n  }\r\n}\r\n\r\nexport function invokeOnDeleted<T extends object>(obj: T, client: ObjectChangeApplicator, clientConnection?: ClientConnection) {\r\n  if (hasOnDeleted(obj)) {\r\n    obj[onDeleted](client, clientConnection);\r\n  }\r\n}\r\n\r\nexport function invokeOnDelete<T extends object>(obj: T, client: ObjectChangeApplicator, clientConnection?: ClientConnection) {\r\n  if (hasOnDelete(obj)) {\r\n    obj[onDelete](client, clientConnection);\r\n  }\r\n  return true; // not handled\r\n}\r\n\r\nexport function invokeOnUpdateProperty<T extends object>(obj: T, key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectChangeApplicator, clientConnection: ClientConnection): boolean {\r\n  if (hasOnUpdateProperty<T>(obj)) {\r\n    return obj[onUpdateProperty](key, value, isForCreate, client, clientConnection);\r\n  }\r\n  return false; // not handled\r\n}\r\n", "import type { ObjectSyncMetaInfo } from \"./objectSyncMetaInfo.js\";\r\n\r\nexport class ObjectInfoBase {\r\n  constructor(private readonly _objectSyncMetaInfo: ObjectSyncMetaInfo) {}\r\n\r\n  get objectId(): unknown {\r\n    return this._objectSyncMetaInfo.objectId;\r\n  }\r\n\r\n  get typeId(): string {\r\n    return this._objectSyncMetaInfo.typeId;\r\n  }\r\n\r\n  get object(): object {\r\n    return this._objectSyncMetaInfo.object;\r\n  }\r\n\r\n  get objectSyncMetaInfo() {\r\n    return this._objectSyncMetaInfo;\r\n  }\r\n}\r\n", "import { ObjectInfoBase } from \"../shared/objectInfoBase.js\";\r\nimport { ObjectSyncMetaInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport type { ObjectChangeApplicator } from \"./applicator.js\";\r\n\r\nexport class ApplicatorObjectInfo<T extends object> extends ObjectInfoBase {\r\n  constructor(objectSyncMetaInfo: ObjectSyncMetaInfo, private readonly _client: ObjectChangeApplicator) {\r\n    super(objectSyncMetaInfo);\r\n  }\r\n\r\n  get client(): ObjectChangeApplicator {\r\n    return this._client;\r\n  }\r\n}\r\n", "import { checkCanApplyProperty, getSyncMethodInfo, getSyncPropertyInfo, getTrackableTypeInfo } from \"../tracker/decorators.js\";\r\nimport {\r\n  ChangeObjectMessage,\r\n  Message,\r\n  CreateObjectMessage,\r\n  DeleteObjectMessage,\r\n  ExecuteObjectMessage,\r\n  PropertyInfos,\r\n  ResolvablePropertyInfos,\r\n  MethodExecuteResult,\r\n  PropertyInfo,\r\n} from \"../shared/messages.js\";\r\nimport { ensureObjectSyncMetaInfo, getObjectSyncMetaInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { TrackedObjectPool } from \"../shared/trackedObjectPool.js\";\r\nimport { invokeOnCreated, invokeOnDeleted, invokeOnUpdated, invokeOnUpdateProperty, invokeOnDelete } from \"./trackableTarget.js\";\r\nimport { ApplicatorObjectInfo } from \"./applicatorObjectInfo.js\";\r\nimport type { ClientConnection } from \"../tracker/index.js\";\r\n\r\ntype Constructor<T = any> = { new (...args: any[]): T };\r\n\r\nexport type TypeGenerator = Constructor | TrackableTargetGenerator;\r\n\r\nexport type TrackableTargetGenerator<T = any> = (client: ObjectChangeApplicator, properties: ResolvablePropertyInfos<T>, objectId: unknown, typeId: string) => T;\r\n\r\nexport type TypeSerializer<T> = {\r\n  typeId?: string;\r\n  type: Constructor<T>;\r\n} & (\r\n  | {\r\n      deserialize: undefined;\r\n      serialize: undefined;\r\n    }\r\n  | {\r\n      deserialize(value: any): T;\r\n      serialize(value: T): any;\r\n    }\r\n);\r\n\r\nexport const allTypeGenerators = new Map<string, TypeGenerator>();\r\n\r\nfunction isGeneratorConstructor(value: TypeGenerator): value is Constructor {\r\n  return (value as Constructor).prototype !== undefined;\r\n}\r\n\r\nfunction isGeneratorTargetGenerator(value: TypeGenerator): value is TrackableTargetGenerator {\r\n  debugger;\r\n  return true;\r\n}\r\n\r\nexport type ObjectChangeApplicatorSettings = {\r\n  objectPool: TrackedObjectPool;\r\n  identity: string;\r\n  typeGenerators: Map<string, TypeGenerator>;\r\n  typeSerializers: Map<string, TypeSerializer<any>>;\r\n};\r\n\r\ntype FinalObjectChangeApplicatorSettings = {\r\n  identity: string;\r\n};\r\n\r\ntype ClientApplyResult = {\r\n  newTrackedObjects: object[];\r\n  methodExecuteResults: MethodExecuteResult[];\r\n};\r\n\r\nexport class ObjectChangeApplicator {\r\n  private _trackedObjectPool: TrackedObjectPool;\r\n  private _pendingCreationMessages = new Map<unknown, CreateObjectMessage<any>>();\r\n\r\n  private _currentClientApplyResult: ClientApplyResult = { newTrackedObjects: [], methodExecuteResults: [] };\r\n\r\n  private readonly _settings: FinalObjectChangeApplicatorSettings;\r\n  private readonly _typeGenerators: Map<string, TypeGenerator>;\r\n  private readonly _typeSerializers: Map<string, TypeSerializer<any>>;\r\n\r\n  constructor(settings: ObjectChangeApplicatorSettings) {\r\n    this._settings = {\r\n      identity: settings.identity,\r\n    };\r\n\r\n    this._trackedObjectPool = settings.objectPool;\r\n    this._typeSerializers = settings.typeSerializers;\r\n    this._typeGenerators = settings.typeGenerators;\r\n  }\r\n\r\n  get settings(): FinalObjectChangeApplicatorSettings {\r\n    return this._settings;\r\n  }\r\n\r\n  get identity(): string {\r\n    return this._settings.identity;\r\n  }\r\n\r\n  registerGenerator(typeId: string, generator: TypeGenerator): void {\r\n    if (this._typeGenerators!.has(typeId)) {\r\n      throw new Error(`Generator for typeId ${typeId} is already registered`);\r\n    }\r\n    this._typeGenerators!.set(typeId, generator);\r\n  }\r\n\r\n  async applyAsync(messages: Message<any>[], clientConnection: ClientConnection): Promise<ClientApplyResult> {\r\n    // sort messages by type, first all creation messages, then update, then execute, then deletion\r\n    messages.sort((a, b) => {\r\n      if (a.type === b.type) return 0;\r\n      if (a.type === \"create\") return -1;\r\n      if (b.type === \"create\") return 1;\r\n      if (a.type === \"change\") return -1;\r\n      if (b.type === \"change\") return 1;\r\n      if (a.type === \"execute\") return -1;\r\n      if (b.type === \"execute\") return 1;\r\n      if (a.type === \"delete\") return 1;\r\n      if (b.type === \"delete\") return -1;\r\n      return 0;\r\n    });\r\n\r\n    // extract all creation messages and remove them from the main list\r\n    const creationMessages = messages.filter(isCreateObjectMessage);\r\n    messages = messages.filter((m) => !isCreateObjectMessage(m));\r\n\r\n    // Store all create messages in pending map for deferred resolution\r\n    for (const creationMessage of creationMessages) {\r\n      this._pendingCreationMessages.set(creationMessage.objectId, creationMessage);\r\n    }\r\n    while (this._pendingCreationMessages.size > 0) {\r\n      const creationMessage = this._pendingCreationMessages.values().next().value!;\r\n      this.createNewTrackedObject(creationMessage, clientConnection);\r\n    }\r\n\r\n    for (const message of messages) {\r\n      if (isChangeObjectMessage(message)) this.handleChanges(message, clientConnection);\r\n      else if (isDeleteObjectMessage(message)) this.deleteTrackedObject(message, clientConnection);\r\n      else if (isExecuteObjectMessage(message)) await this.executeMethodAsync(message, clientConnection);\r\n    }\r\n\r\n    const result = this._currentClientApplyResult!;\r\n    this._currentClientApplyResult = { newTrackedObjects: [], methodExecuteResults: [] };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Resolves a property value, returning the tracked object if objectId is present, or the value otherwise.\r\n   * If the object is not yet tracked, attempts to create it from pending messages.\r\n   */\r\n  getPropertyValue(property: PropertyInfo<any, any>, clientConnection: ClientConnection): any {\r\n    const { objectId, value, typeId } = property;\r\n    if (typeId) {\r\n      return this.deserializeValue(typeId, value as object);\r\n    }\r\n    if (objectId !== undefined && objectId !== null) {\r\n      let tracked = this._trackedObjectPool.get(objectId);\r\n      if (!tracked) {\r\n        // Try to create from pending messages\r\n        const pendingMsg = this._pendingCreationMessages.get(objectId);\r\n        if (pendingMsg) {\r\n          this.createNewTrackedObject(pendingMsg, clientConnection);\r\n          tracked = this._trackedObjectPool.get(objectId);\r\n        }\r\n      }\r\n      if (!tracked) {\r\n        throw new Error(`Cannot find or create target with id ${objectId}`);\r\n      }\r\n      return tracked;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  findObjectOfType<T extends object>(constructor: Constructor<T>, objectId?: unknown) {\r\n    for (const tracked of this._trackedObjectPool.all) {\r\n      if (tracked instanceof constructor) {\r\n        const metaInfo = getObjectSyncMetaInfo(tracked)!;\r\n        if (objectId !== undefined && metaInfo.objectId !== objectId) continue;\r\n        return tracked;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  findObjectsOfType<T extends object>(constructor: Constructor<T>) {\r\n    const results: T[] = [];\r\n    for (const tracked of this._trackedObjectPool.all) {\r\n      if (tracked instanceof constructor) {\r\n        return results.push(tracked as T);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  get allTrackedObjects(): object[] {\r\n    return Array.from(this._trackedObjectPool.all);\r\n  }\r\n\r\n  private deleteTrackedObject(data: Message<any>, clientConnection: ClientConnection): void {\r\n    if (!isDeleteObjectMessage(data)) return;\r\n\r\n    if (!this._trackedObjectPool.hasById(data.objectId)) {\r\n      throw new Error(`Object with id ${data.objectId} is not being tracked`);\r\n    }\r\n\r\n    const tracked = this._trackedObjectPool.get(data.objectId)!;\r\n    if (!invokeOnDelete(tracked, this, clientConnection)) return;\r\n    this._trackedObjectPool.deleteById(data.objectId);\r\n    invokeOnDeleted(tracked, this, clientConnection);\r\n  }\r\n\r\n  private constructObject(data: CreateObjectMessage<any>, clientConnection: ClientConnection) {\r\n    if (this._trackedObjectPool.hasById(data.objectId)) {\r\n      return;\r\n    }\r\n\r\n    let result: object | null = null;\r\n\r\n    const generatorOrConstructor = this._typeGenerators.get(data.typeId);\r\n    if (!generatorOrConstructor) {\r\n      throw new Error(`No constructor or generator registered for typeId ${data.typeId}`);\r\n    }\r\n\r\n    if (isGeneratorConstructor(generatorOrConstructor)) {\r\n      result = new generatorOrConstructor();\r\n    } else if (isGeneratorTargetGenerator(generatorOrConstructor)) {\r\n      const resolvablePropertyInfos = this.createResolvablePropertyInfos(data.properties, clientConnection);\r\n\r\n      result = generatorOrConstructor(this, resolvablePropertyInfos, data.objectId, data.typeId);\r\n\r\n      resolvablePropertyInfos.deletedProperties.forEach((key) => {\r\n        delete (result as any)[key];\r\n      });\r\n    }\r\n\r\n    if (!result) return;\r\n\r\n    const objectInfo = ensureObjectSyncMetaInfo({\r\n      object: result,\r\n      objectId: data.objectId,\r\n      typeId: data.typeId,\r\n    });\r\n    objectInfo.client = new ApplicatorObjectInfo<any>(objectInfo, this);\r\n\r\n    if (!this._trackedObjectPool.has(result)) {\r\n      this._trackedObjectPool.add(result);\r\n      this._currentClientApplyResult.newTrackedObjects.push(result);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  private createResolvablePropertyInfos<T extends object>(unresolvedProperties: PropertyInfos<T>, clientConnection: ClientConnection): ResolvablePropertyInfos<T> {\r\n    const deletedProperties: Set<string> = new Set();\r\n    const properties: ResolvablePropertyInfos<any> = {\r\n      deleteProperty(key: string) {\r\n        deletedProperties.add(key);\r\n      },\r\n      get deletedProperties(): string[] {\r\n        return Array.from(deletedProperties);\r\n      },\r\n    };\r\n    Object.keys(unresolvedProperties).forEach((key) => {\r\n      const propertyInfo = unresolvedProperties[key as keyof T]!;\r\n      let resolvedValue: any = undefined;\r\n      let hasResolved = false;\r\n      Object.defineProperty(properties, key, {\r\n        get: () => {\r\n          if (!hasResolved) {\r\n            hasResolved = true;\r\n            resolvedValue = this.getPropertyValue(propertyInfo, clientConnection);\r\n          }\r\n          return resolvedValue;\r\n        },\r\n      });\r\n    });\r\n\r\n    return properties as ResolvablePropertyInfos<T>;\r\n  }\r\n\r\n  private createNewTrackedObject(data: Message<any>, clientConnection: ClientConnection): void {\r\n    if (!isCreateObjectMessage(data)) return;\r\n    this._pendingCreationMessages.delete(data.objectId);\r\n\r\n    this.constructObject(data, clientConnection);\r\n    this.handleChanges(data, clientConnection);\r\n  }\r\n\r\n  private handleChanges(data: Message<any>, clientConnection: ClientConnection): void {\r\n    const isCreate = isCreateObjectMessage(data);\r\n    const isChange = isChangeObjectMessage(data);\r\n\r\n    if (!isCreate && !isChange) return;\r\n\r\n    const tracked = this._trackedObjectPool.get(data.objectId) as any;\r\n    if (!tracked) {\r\n      throw new Error(`Cannot find target with id ${data.objectId}`);\r\n    }\r\n\r\n    Object.keys(data.properties).forEach((key) => {\r\n      if (!checkCanApplyProperty(tracked.constructor as Constructor, tracked, key, false, clientConnection)) return;\r\n      const property = data.properties[key]!;\r\n      const finalValue = this.getPropertyValue(property, clientConnection);\r\n\r\n      const propertyInfo = getSyncPropertyInfo(tracked.constructor as Constructor, key);\r\n      if (propertyInfo) propertyInfo.isBeeingApplied = true;\r\n\r\n      try {\r\n        if (!invokeOnUpdateProperty(tracked, key, finalValue, isCreate, this, clientConnection)) tracked[key] = finalValue;\r\n      } finally {\r\n        if (propertyInfo) propertyInfo.isBeeingApplied = false;\r\n      }\r\n    });\r\n\r\n    if (isChange) invokeOnUpdated(tracked, data, this, clientConnection);\r\n    else if (isCreate) invokeOnCreated(tracked, data, this, clientConnection);\r\n  }\r\n\r\n  private async executeMethodAsync(data: Message<any>, clientConnection: ClientConnection): Promise<void> {\r\n    if (!isExecuteObjectMessage(data)) return;\r\n\r\n    const tracked = this._trackedObjectPool.get(data.objectId) as any;\r\n    if (!tracked) {\r\n      throw new Error(`Cannot find target with id ${data.objectId}`);\r\n    }\r\n\r\n    if (!checkCanApplyProperty(tracked.constructor as Constructor, tracked, data.method, true, clientConnection)) {\r\n      this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result: null, status: \"rejected\", error: \"Not allowed.\" });\r\n      return;\r\n    }\r\n\r\n    if (typeof tracked[data.method] !== \"function\") {\r\n      throw new Error(`Target with id ${data.objectId} has no method ${data.method}`);\r\n    }\r\n\r\n    const methodInfo = getSyncMethodInfo(tracked.constructor as Constructor, data.method);\r\n\r\n    const args = data.parameters.map((property) => this.getPropertyValue(property, clientConnection));\r\n    let result: any;\r\n    try {\r\n      if (methodInfo) methodInfo.isBeeingApplied = true;\r\n      result = tracked[data.method](...args);\r\n    } catch (e) {\r\n      this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result: null, status: \"rejected\", error: e });\r\n      return;\r\n    } finally {\r\n      if (methodInfo) methodInfo.isBeeingApplied = false;\r\n    }\r\n\r\n    // Store reply, handle Promise\r\n    if (result && typeof result.then === \"function\" && typeof result.catch === \"function\") {\r\n      const promiseHandlingType = getSyncMethodInfo(tracked.constructor as Constructor, data.method)?.promiseHandlingType ?? \"normal\";\r\n      const resolveNow = promiseHandlingType === \"await\";\r\n      if (resolveNow) {\r\n        try {\r\n          const resolved = await result;\r\n\r\n          this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result: resolved, status: \"resolved\", error: null });\r\n        } catch (error) {\r\n          this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result: null, status: \"rejected\", error: error });\r\n        }\r\n      } else {\r\n        result\r\n          .then((resolved: any) => {\r\n            this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result: resolved, status: \"resolved\", error: null });\r\n          })\r\n          .catch((error: any) => {\r\n            this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result: null, status: \"rejected\", error: error });\r\n          });\r\n      }\r\n    } else {\r\n      // Synchronous result\r\n      this._currentClientApplyResult.methodExecuteResults.push({ objectId: data.objectId, id: data.id, result, status: \"resolved\", error: null });\r\n    }\r\n  }\r\n\r\n  private deserializeValue(typeId: string, value: any) {\r\n    const generator = this._typeSerializers.get(typeId);\r\n    if (!generator) {\r\n      throw new Error(`No deserializer registered for typeId ${typeId}`);\r\n    }\r\n    if (generator.deserialize) return generator.deserialize(value);\r\n    else return new generator.type(value);\r\n  }\r\n}\r\n\r\nfunction isDeleteObjectMessage<T extends object = any>(change: Message<T>): change is DeleteObjectMessage {\r\n  return change.type === \"delete\";\r\n}\r\n\r\nfunction isCreateObjectMessage<T extends object = any>(change: Message<T>): change is CreateObjectMessage<T> {\r\n  return change.type === \"create\";\r\n}\r\n\r\nfunction isChangeObjectMessage<T extends object = any>(change: Message<T>): change is ChangeObjectMessage<T> {\r\n  return change.type === \"change\";\r\n}\r\n\r\nfunction isExecuteObjectMessage<T extends object = any>(change: Message<T>): change is ExecuteObjectMessage<T> {\r\n  return change.type === \"execute\";\r\n}\r\n", "import \"../shared/decorators.js\";\r\nimport { allTypeGenerators, TrackableTargetGenerator } from \"../applicator/applicator.js\";\r\nimport { getObjectSyncMetaInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { hasInIterable, OneOrMany } from \"../shared/types.js\";\r\nimport type { ClientConnection, ObjectChangeTracker } from \"./tracker.js\";\r\nimport type { ChangeTrackerObjectInfo } from \"./trackerObjectInfo.js\";\r\nimport { PropertyInfo } from \"../shared/messages.js\";\r\n\r\nconst TRACKABLE_CONSTRUCTOR_INFO = Symbol(\"trackableConstructor\");\r\n\r\ntype Constructor<T = any> = { new (...args: any[]): T };\r\n\r\ntype TrackedPropertySettingsBase<T> = {\r\n  /**\r\n   * Returns true when the property/method should be tracked.\r\n   * @param key The name of the property/method which should be tracked.\r\n   * @param client The client which tracks the property/method.\r\n   */\r\n  canTrack?<TKey extends keyof T & string>(object: T, key: TKey, host: ChangeTrackerObjectInfo<any>): boolean;\r\n\r\n  /**\r\n   *  Returns true when the property/method change should be applied.\r\n   * @param key The name of the property/method which should be applied.\r\n   * @param clientConnection The clientConnection from which the changes came from.\r\n   */\r\n  canApply?<TKey extends keyof T & string>(object: T, key: TKey, clientConnection: ClientConnection): boolean;\r\n};\r\n\r\ntype TrackedPropertySettings<T> = TrackedPropertySettingsBase<T> & {\r\n  /**\r\n   * Function which is called before sending the property value to the client.\r\n   * Can be used to modify or filter the value being sent.\r\n   * When the symbol value \"nothing\" is returned, the property update will be skipped.\r\n   * @param key The name of the property which is being sent.\r\n   * @param value The current value of the property.\r\n   * @param clientConnection The client connection to which the value is being sent.\r\n   */\r\n  beforeSendToClient?<TKey extends keyof T & string>(object: T, key: TKey, value: any, clientConnection: ClientConnection): any;\r\n};\r\n\r\nexport const nothing = Symbol(\"nothing\");\r\n\r\ntype TrackedMethodSettings<T extends object> = TrackedPropertySettingsBase<T> & {\r\n  /*\r\n   * Defines how method execution should handle returned Promises.\r\n   * - \"await\": The method call will be awaited, and the resolved value will be used or the rejection will be sent back to the client.\r\n   * - \"normal\": The Promise will be returned as-is without awaiting, once settled the result will be sent back to the client.\r\n   * If not set, the default behavior is \"normal\".\r\n   */\r\n  promiseHandlingType?: \"await\" | \"normal\";\r\n\r\n  /**\r\n   * Function which is called before sending the method execution call to the client.\r\n   * Can be used to prevent the method call from being sent.\r\n   * @param key The name of the method which is being sent.\r\n   * @param clientConnection The client connection to which the value is being sent.\r\n   */\r\n  beforeExecuteOnClient?<TKey extends keyof T & string>(object: T, methodName: TKey, args: \r\n    T[TKey] extends (...args: infer P) => any ? P : never, \r\n    clientConnection: ClientConnection): boolean;\r\n};\r\n\r\ntype TrackedPropertyInfo<T> = TrackedPropertySettings<T> & {\r\n  isBeeingApplied: boolean;\r\n};\r\n\r\ntype TrackedMethodInfo<T extends object> = TrackedMethodSettings<T> & {\r\n  isBeeingApplied: boolean;\r\n};\r\n\r\ntype TrackableConstructorInfo<T extends object> = {\r\n  trackedProperties: Map<string, TrackedPropertyInfo<T>>;\r\n  trackedMethods: Map<string, TrackedMethodInfo<T>>;\r\n  typeId: string;\r\n\r\n  /**\r\n   * Function which is called before sending the object to the client.\r\n   * Can be used to modify or filter the typeId being sent.\r\n   * When the symbol value \"nothing\", null or undefined is returned, the object creation will be skipped.\r\n   * @param object The object which is being sent.\r\n   * @param constructor The constructor function of the object being sent.\r\n   * @param typeId The current typeId of the object which will be send\r\n   * @param clientConnection The client connection to which the object is being sent.\r\n   */\r\n  beforeSendToClient?(object: T, constructor: Constructor<T>, typeId: string, clientConnection: ClientConnection): string | typeof nothing | Constructor | null | undefined;\r\n};\r\n\r\ntype TrackableObjectSettings<T extends object> = {\r\n  // The type ID for the trackable object\r\n  typeId?: string;\r\n  // The generator function for creating trackable instances, when not provided the default constructor will be used\r\n  generator?: TrackableTargetGenerator<T>;\r\n\r\n  // Additional settings for tracked properties\r\n  properties?: { [propertyKey: string]: TrackedPropertySettings<T> };\r\n  // Additional settings for tracked methods\r\n  methods?: { [methodKey: string]: TrackedMethodSettings<T> };\r\n\r\n  /**\r\n   * Function which is called before sending the object to the client.\r\n   * Can be used to modify or filter the typeId being sent.\r\n   * When the symbol value \"nothing\", null or undefined is returned, the object creation will be skipped.\r\n   * @param object The object which is being sent.\r\n   * @param constructor The constructor function of the object being sent.\r\n   * @param typeId The current typeId of the object which will be send\r\n   * @param clientConnection The client connection to which the object is being sent.\r\n   */\r\n  beforeSendToClient?(object: T, constructor: Constructor<T>, typeId: string, clientConnection: ClientConnection): string | typeof nothing | Constructor | null | undefined;\r\n};\r\n\r\n/**\r\n * Property accessor decorator for marking a property as trackable.\r\n * Registers the property and ensures changes are propagated to all TrackableObject instances.\r\n */\r\nexport function syncProperty<This, Return>(settings?: TrackedPropertySettings<This>) {\r\n  settings ??= {};\r\n\r\n  return function syncProperty(target: ClassAccessorDecoratorTarget<This, Return>, context: ClassAccessorDecoratorContext<This, Return>) {\r\n    const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\r\n    const propertyInfo: TrackedPropertyInfo<This> = {\r\n      ...settings,\r\n      isBeeingApplied: false,\r\n    };\r\n\r\n    const propertyName = context.name as string;\r\n    trackableInfo.trackedProperties.set(propertyName, propertyInfo);\r\n\r\n    const result: ClassAccessorDecoratorResult<This, Return> = {\r\n      set(value: any) {\r\n        const isBeeingApplied = propertyInfo.isBeeingApplied;\r\n        propertyInfo.isBeeingApplied = false;\r\n\r\n        target.set.call(this, value);\r\n\r\n        if (isBeeingApplied) return;\r\n\r\n        const host = getObjectSyncMetaInfo(this as any)?.host;\r\n\r\n        if (host && checkCanTrackPropertyInfo(propertyInfo, this as any, propertyName, host)) {\r\n          host.onPropertyChanged(context.name as any, value);\r\n        }\r\n      },\r\n    };\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * Method decorator for marking a method as trackable.\r\n * Ensures method calls are recorded for all TrackableObject instances.\r\n */\r\nexport function syncMethod<This extends object, Return>(settings?: TrackedMethodSettings<This>) {\r\n  settings ??= {};\r\n\r\n  return function syncMethod(target: any, context: ClassMethodDecoratorContext) {\r\n    const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\r\n    const methodInfo: TrackedMethodInfo<This> = {\r\n      ...settings,\r\n      isBeeingApplied: false,\r\n    };\r\n    const methodName = context.name as string;\r\n    trackableInfo.trackedMethods.set(methodName, methodInfo);\r\n\r\n    const originalMethod = target;\r\n    const func = function (this: any, ...args: any[]) {\r\n      const isBeeingApplied = methodInfo.isBeeingApplied;\r\n      methodInfo.isBeeingApplied = false;\r\n\r\n      const result = originalMethod.apply(this, args);\r\n\r\n      if (isBeeingApplied) return result;\r\n\r\n      const hostInfo = getObjectSyncMetaInfo(this)?.host;\r\n      if (hostInfo && checkCanTrackPropertyInfo(methodInfo, this, methodName, hostInfo)) {\r\n        hostInfo.onMethodExecute(context.name as any, args);\r\n      }\r\n\r\n      return result;\r\n    };\r\n    return func;\r\n  };\r\n}\r\n\r\n/**\r\n * Retrieves the TrackableConstructorInfo metadata for a class constructor, if present.\r\n */\r\nexport function getTrackableTypeInfo(ctor: Constructor): TrackableConstructorInfo<any> | null {\r\n  const trackableInfo: TrackableConstructorInfo<any> | undefined = (ctor as any)[Symbol.metadata]?.[TRACKABLE_CONSTRUCTOR_INFO] as TrackableConstructorInfo<any>;\r\n  return trackableInfo ?? null;\r\n}\r\n\r\n/**\r\n * Class decorator for marking a class as auto-trackable by the host.\r\n * Can be used as @syncObject or @syncObject(\"typeId\").\r\n * Registers the class for automatic tracking and assigns a typeId if provided.\r\n */\r\nexport function syncObject<This extends abstract new (...args: any) => any>(settings?: TrackableObjectSettings<InstanceType<This>>) {\r\n  return function syncObject(target: This, context: ClassDecoratorContext<This>) {\r\n    settings ??= {};\r\n    settings.typeId ??= context.name!;\r\n    const trackableInfo = ensureTrackableConstructorInfo<InstanceType<This>>(context.metadata);\r\n    trackableInfo.typeId = settings.typeId;\r\n    trackableInfo.beforeSendToClient = settings.beforeSendToClient;\r\n\r\n    if (settings.properties) {\r\n      for (const [propertyKey, propertySettings] of Object.entries(settings.properties)) {\r\n        trackableInfo.trackedProperties.set(propertyKey, {\r\n          ...propertySettings,\r\n          isBeeingApplied: false,\r\n        });\r\n      }\r\n    }\r\n    if (settings.methods) {\r\n      for (const [methodKey, methodSettings] of Object.entries(settings.methods)) {\r\n        trackableInfo.trackedMethods.set(methodKey, {\r\n          ...methodSettings,\r\n          isBeeingApplied: false,\r\n        });\r\n      }\r\n    }\r\n\r\n    allTypeGenerators.set(settings.typeId, settings.generator ?? (target as any));\r\n  };\r\n}\r\n\r\nfunction ensureTrackableConstructorInfo<T extends object = any>(metadata: DecoratorMetadataObject): TrackableConstructorInfo<T> {\r\n  const oldTrackableInfo = (metadata[TRACKABLE_CONSTRUCTOR_INFO] ?? {\r\n    trackedProperties: new Map<string, TrackedPropertyInfo<T>>(),\r\n    trackedMethods: new Map<string, TrackedMethodInfo<T>>(),\r\n    isAutoTrackable: false,\r\n    beforeSendToClient: undefined,\r\n  }) as TrackableConstructorInfo<T>;\r\n\r\n  const newTrackableInfo: TrackableConstructorInfo<T> = {\r\n    trackedProperties: new Map<string, TrackedPropertyInfo<T>>(oldTrackableInfo.trackedProperties),\r\n    trackedMethods: new Map<string, TrackedMethodInfo<T>>(oldTrackableInfo.trackedMethods),\r\n    typeId: oldTrackableInfo.typeId,\r\n    beforeSendToClient: oldTrackableInfo.beforeSendToClient,\r\n  };\r\n\r\n  metadata![TRACKABLE_CONSTRUCTOR_INFO] = newTrackableInfo;\r\n\r\n  return newTrackableInfo;\r\n}\r\n\r\nexport function getSyncPropertyInfo(constructor: Constructor, propertyKey: string) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return null;\r\n  }\r\n  const propertyInfo = constructorInfo.trackedProperties.get(propertyKey);\r\n  return propertyInfo ?? null;\r\n}\r\n\r\nexport function getSyncMethodInfo(constructor: Constructor, propertyKey: string) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return null;\r\n  }\r\n  const propertyInfo = constructorInfo.trackedMethods.get(propertyKey);\r\n  return propertyInfo ?? null;\r\n}\r\n\r\nexport function checkCanApplyProperty(constructor: Constructor, object: object, propertyKey: string, isMethod: boolean, clientConnection: ClientConnection) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return false;\r\n  }\r\n  const propertyInfo = isMethod ? constructorInfo.trackedMethods.get(propertyKey) : constructorInfo.trackedProperties.get(propertyKey);\r\n  if (!propertyInfo) {\r\n    return false;\r\n  }\r\n  if (propertyInfo.canApply?.(object, propertyKey, clientConnection) === false) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function checkCanTrackProperty(constructor: Constructor, object: object, propertyKey: string, isMethod: boolean, host: ChangeTrackerObjectInfo<any>) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return false;\r\n  }\r\n  const propertyInfo = isMethod ? constructorInfo.trackedMethods.get(propertyKey) : constructorInfo.trackedProperties.get(propertyKey);\r\n  return checkCanTrackPropertyInfo(propertyInfo, object, propertyKey, host);\r\n}\r\n\r\nfunction checkCanTrackPropertyInfo(propertyInfo: TrackedPropertyInfo<any> | undefined, object: object, propertyKey: string, host: ChangeTrackerObjectInfo<any>) {\r\n  if (!propertyInfo) {\r\n    return false;\r\n  }\r\n  if (propertyInfo.canTrack?.(object, propertyKey, host) === false) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function beforeExecuteOnClient(constructor: Constructor, object: object, methodKey: string, args: any[], clientConnection: ClientConnection) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return false;\r\n  }\r\n  const methodInfo = constructorInfo.trackedMethods.get(methodKey);\r\n  if (!methodInfo) {\r\n    return false;\r\n  }\r\n  if (methodInfo.beforeExecuteOnClient?.(object, methodKey, args, clientConnection) === false) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function beforeSendPropertyToClient(constructor: Constructor, object: object, propertyKey: string, value: any, clientConnection: ClientConnection) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return nothing;\r\n  }\r\n  const propertyInfo = constructorInfo.trackedProperties.get(propertyKey);\r\n  if (!propertyInfo) {\r\n    return nothing;\r\n  }\r\n  if (!propertyInfo.beforeSendToClient) {\r\n    return value;\r\n  }\r\n  return propertyInfo.beforeSendToClient(object, propertyKey, value, clientConnection);\r\n}\r\n\r\nexport function beforeSendObjectToClient(constructor: Constructor, object: object, typeId: string, clientConnection: ClientConnection) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return nothing;\r\n  }\r\n  if (!constructorInfo.beforeSendToClient) {\r\n    return typeId;\r\n  }\r\n  const result = constructorInfo.beforeSendToClient(object, constructor, typeId, clientConnection);\r\n  if (result === null || result === undefined || result === nothing) {\r\n    return nothing;\r\n  }\r\n  if (typeof result === \"string\") {\r\n    return result;\r\n  }\r\n  if (typeof result === \"function\") {\r\n    const newConstructorInfo = getTrackableTypeInfo(result);\r\n    if (newConstructorInfo && newConstructorInfo.typeId) {\r\n      return newConstructorInfo.typeId;\r\n    }\r\n    throw new Error(`The constructor returned from beforeSendToClient does not have a typeId.`);\r\n  }\r\n  return typeId;\r\n}\r\n", "import type { ApplicatorObjectInfo } from \"../applicator/applicatorObjectInfo.js\";\r\nimport type { ChangeTrackerObjectInfo } from \"../tracker/trackerObjectInfo.js\";\r\nimport { getTrackableTypeInfo } from \"../tracker/decorators.js\";\r\n\r\nexport const objectSyncSymbol = Symbol(\"objectSync\");\r\n\r\nexport type ObjectSyncMetaInfo = {\r\n  objectId: unknown;\r\n  typeId: string;\r\n  object: object;\r\n  client?: ApplicatorObjectInfo<any>;\r\n  host?: ChangeTrackerObjectInfo<any>;\r\n};\r\n\r\nexport function getObjectSyncMetaInfo(target: object): ObjectSyncMetaInfo | undefined {\r\n  if (!target || typeof target !== \"object\") return undefined;\r\n  if (typeof target === \"function\") return undefined;\r\n\r\n  return (target as any)[objectSyncSymbol] as ObjectSyncMetaInfo | undefined;\r\n}\r\n\r\nlet nextObjectId = 1;\r\n\r\nexport function createObjectId(objectIdPrefix: string): string {\r\n  return `${objectIdPrefix}${nextObjectId++}`;\r\n}\r\n\r\nexport type ObjectSyncMetaInfoCreateSettings<T extends object = object> =\r\n  | {\r\n      object: T;\r\n      objectIdPrefix: string;\r\n      typeId?: string;\r\n      objectId?: unknown;\r\n    }\r\n  | {\r\n      object: T;\r\n      typeId: string;\r\n      objectId: unknown;\r\n    };\r\n\r\nexport function ensureObjectSyncMetaInfo(settings: ObjectSyncMetaInfoCreateSettings): ObjectSyncMetaInfo {\r\n  let metaInfo = getObjectSyncMetaInfo(settings.object);\r\n  if (metaInfo) return metaInfo;\r\n\r\n  if (!(\"objectId\" in settings) && !(\"objectIdPrefix\" in settings)) {\r\n    throw new Error(\"objectIdPrefix must be provided when objectId is provided\");\r\n  }\r\n\r\n  const typeId = settings.typeId ?? getTrackableTypeInfo(settings.object.constructor as any)?.typeId ?? settings.object.constructor.name;\r\n  const objectId = settings.objectId ?? createObjectId((settings as any).objectIdPrefix);\r\n\r\n  metaInfo = {\r\n    objectId,\r\n    typeId,\r\n    object: settings.object,\r\n  };\r\n\r\n  (settings.object as any)[objectSyncSymbol] = metaInfo;\r\n  return metaInfo;\r\n}\r\n\r\nexport function getHostObjectInfo<T extends object>(obj: T): ChangeTrackerObjectInfo<T> | null {\r\n  return getObjectSyncMetaInfo(obj)?.host ?? null;\r\n}\r\n\r\nexport function getClientObjectInfo<T extends object>(obj: T): ApplicatorObjectInfo<T> | null {\r\n  return getObjectSyncMetaInfo(obj)?.client ?? null;\r\n}\r\n", "import { ObjectSyncMetaInfo, getObjectSyncMetaInfo, createObjectId } from \"./objectSyncMetaInfo.js\";\r\n\r\nexport class TrackedObjectPool {\r\n  private _trackedObjectInfos = new Map<unknown, ObjectSyncMetaInfo>();\r\n\r\n  add(object: object) {\r\n    const metaInfo = getObjectSyncMetaInfo(object);\r\n    if (!metaInfo) throw new Error(\"Object is not trackable.\");\r\n\r\n    if (this.hasById(metaInfo?.objectId)) return;\r\n\r\n    this._trackedObjectInfos.set(metaInfo.objectId, metaInfo);\r\n  }\r\n\r\n  delete(object: object): boolean {\r\n    const metaInfo = getObjectSyncMetaInfo(object);\r\n    if (!metaInfo) return false;\r\n\r\n    return this._trackedObjectInfos.delete(metaInfo.objectId);\r\n  }\r\n\r\n  deleteById(objectId: unknown): boolean {\r\n    return this._trackedObjectInfos.delete(objectId);\r\n  }\r\n\r\n  get(objectId: unknown): object | null {\r\n    const metaInfo = this._trackedObjectInfos.get(objectId);\r\n    return metaInfo?.object ?? null;\r\n  }\r\n\r\n  has(object: object): boolean {\r\n    const metaInfo = getObjectSyncMetaInfo(object);\r\n    if (!metaInfo) return false;\r\n\r\n    return this._trackedObjectInfos.has(metaInfo.objectId);\r\n  }\r\n\r\n  hasById(objectId: unknown): boolean {\r\n    return this._trackedObjectInfos.has(objectId);\r\n  }\r\n\r\n  get allMetaInfos(): ObjectSyncMetaInfo[] {\r\n    const result: ObjectSyncMetaInfo[] = [];\r\n    this._trackedObjectInfos.forEach((info) => result.push(info));\r\n    return result;\r\n  }\r\n\r\n  get all(): object[] {\r\n    const result: object[] = [];\r\n    this._trackedObjectInfos.forEach((info) => result.push(info.object));\r\n    return result;\r\n  }\r\n}\r\n", "import { ChangeTrackerObjectInfo } from \"./trackerObjectInfo.js\";\r\n\r\nexport const onConvertedToTrackable = Symbol(\"onConvertedToTrackable\");\r\nexport const onTick = Symbol(\"onTick\");\r\n\r\nexport interface ITrackedOnConvertedToTrackable<T extends object> {\r\n  [onConvertedToTrackable](info: ChangeTrackerObjectInfo<T>): void;\r\n}\r\n\r\nexport interface ITrackedOnTick<T extends object> {\r\n  [onTick](): void;\r\n}\r\n\r\nfunction hasOnConvertedToTrackable<T extends object>(obj: any): obj is ITrackedOnConvertedToTrackable<T> {\r\n  return onConvertedToTrackable in obj;\r\n}\r\n\r\nfunction hasOnTick<T extends object>(obj: any): obj is ITrackedOnTick<T> {\r\n  return onTick in obj;\r\n}\r\n\r\nexport function invokeOnConvertedToTrackable<T extends object>(obj: T, info: ChangeTrackerObjectInfo<T>) {\r\n  if (hasOnConvertedToTrackable<T>(obj)) {\r\n    obj[onConvertedToTrackable](info);\r\n  }\r\n}\r\n\r\nexport function invokeOnTick<T extends object>(obj: T) {\r\n  if (hasOnTick<T>(obj)) {\r\n    obj[onTick]();\r\n  }\r\n}\r\n", "import { ObjectChangeApplicator } from \"../applicator/applicator.js\";\r\nimport { ITrackableOnUpdateProperty, onUpdateProperty } from \"../applicator/trackableTarget.js\";\r\nimport { syncObject } from \"../tracker/decorators.js\";\r\nimport { ClientConnection } from \"../tracker/tracker.js\";\r\nimport { ChangeTrackerObjectInfo } from \"../tracker/trackerObjectInfo.js\";\r\nimport { ITrackedOnConvertedToTrackable, ITrackedOnTick, onConvertedToTrackable, onTick } from \"../tracker/interfaces.js\";\r\nimport { isPropertyInfoSymbol, PropertyInfo } from \"./messages.js\";\r\nimport { getHostObjectInfo } from \"./objectSyncMetaInfo.js\";\r\n\r\nexport type SyncableArrayChange<T> = { start: number; deleteCount: number; items: PropertyInfo<any, any>[] };\r\n\r\n@syncObject({\r\n  typeId: \"SyncableArray\",\r\n  properties: {\r\n    _changes: {},\r\n    _creation: {},\r\n  },\r\n})\r\nexport class SyncableArray<T> implements ITrackableOnUpdateProperty<any>, ITrackedOnConvertedToTrackable<SyncableArray<T>>, ITrackedOnTick<SyncableArray<T>> {\r\n  private _values: T[] = [];\r\n  private _changes: SyncableArrayChange<T>[] = [];\r\n  private _creation: PropertyInfo<any, any>[] = [];\r\n\r\n  constructor(initial: T[] = []) {\r\n    this.push(...initial);\r\n  }\r\n\r\n  get value(): T[] {\r\n    return this._values;\r\n  }\r\n\r\n  set value(value: T[]) {\r\n    this.clear();\r\n    this.push(...value);\r\n  }\r\n\r\n  clear() {\r\n    this.length = 0;\r\n  }\r\n\r\n  changeAt(index: number, value: T) {\r\n    this._values[index] = value;\r\n\r\n    this.onRemoved(index, [value]);\r\n    this.onAdded(index, [value]);\r\n\r\n    const hostObjectInfo = getHostObjectInfo(this);\r\n    if (hostObjectInfo) {\r\n      this._creation[index] = this.convertItemToPropertyInfo(hostObjectInfo, value);\r\n      this.addChange({ start: index, deleteCount: 1, items: this.convertItemsToPropertyInfos(hostObjectInfo, [value]) });\r\n    }\r\n  }\r\n\r\n  get length(): number {\r\n    return this._values.length;\r\n  }\r\n\r\n  set length(value: number) {\r\n    if (value < this._values.length) {\r\n      this.splice(value, this._values.length - value);\r\n    } else if (value > this._values.length) {\r\n      this.push(...(new globalThis.Array(value - this._values.length).fill(undefined) as T[]));\r\n    }\r\n  }\r\n\r\n  push(...items: T[]): number {\r\n    if (items.length === 0) return this._values.length;\r\n\r\n    const startIndex = this._values.length;\r\n    this._values.push(...items);\r\n\r\n    const hostObjectInfo = getHostObjectInfo(this);\r\n    if (hostObjectInfo) {\r\n      this._creation.push(...this.convertItemsToPropertyInfos(hostObjectInfo, items));\r\n      this.addChange({ start: startIndex, deleteCount: 0, items: this.convertItemsToPropertyInfos(hostObjectInfo, items) });\r\n    }\r\n\r\n    this.onAdded(startIndex, items);\r\n    return this._values.length;\r\n  }\r\n\r\n  private convertPropertyInfosToItems(items: PropertyInfo<any, any>[], client: ObjectChangeApplicator, clientConnection: ClientConnection): T[] {\r\n    return items.map((item) => client.getPropertyValue(item, clientConnection));\r\n  }\r\n\r\n  splice(start: number, deleteCount?: number, ...items: T[]): T[] {\r\n    deleteCount ??= this._values.length - start;\r\n    if (deleteCount === 0 && items.length === 0) return [];\r\n\r\n    const removedItems = this._values.splice(start, deleteCount, ...items);\r\n    if (removedItems.length > 0) this.onRemoved(start, removedItems);\r\n    if (items.length > 0) this.onAdded(start, items);\r\n\r\n    const hostObjectInfo = getHostObjectInfo(this);\r\n    if (hostObjectInfo) {\r\n      const convertedItems = this.convertItemsToPropertyInfos(hostObjectInfo, items);\r\n      this._creation.splice(start, deleteCount, ...convertedItems);\r\n      this.addChange({ start, deleteCount, items: convertedItems });\r\n    }\r\n\r\n    return removedItems;\r\n  }\r\n\r\n  private addChange(pendingChange: SyncableArrayChange<T> | null) {\r\n    this.onPropertyChanged(\"_changes\", this._changes);\r\n\r\n    while (pendingChange) {\r\n      const lastChange = this._changes[this._changes.length - 1];\r\n      if (!lastChange) {\r\n        this._changes.push(pendingChange);\r\n        return;\r\n      }\r\n\r\n      // Try to merge consecutive pushes at the end\r\n      if (lastChange.deleteCount === 0 && pendingChange.deleteCount === 0 && lastChange.start + lastChange.items.length === pendingChange.start) {\r\n        // Merge pushes at the end\r\n        lastChange.items.push(...pendingChange.items);\r\n        // After merging, try to merge lastChange with the previous one\r\n        pendingChange = this._changes.pop()!;\r\n        continue;\r\n      }\r\n\r\n      // Try to merge a removal at the end with a previous push\r\n      if (\r\n        lastChange.deleteCount === 0 &&\r\n        pendingChange.deleteCount > 0 &&\r\n        pendingChange.items.length === 0 &&\r\n        lastChange.start + lastChange.items.length === pendingChange.start + pendingChange.deleteCount &&\r\n        pendingChange.start >= lastChange.start\r\n      ) {\r\n        // Only remove from the end of the last push\r\n        const removeCount = pendingChange.deleteCount;\r\n        const newLength = lastChange.items.length - removeCount;\r\n        if (newLength > 0) {\r\n          lastChange.items.length = newLength;\r\n          // After merging, try to merge lastChange with the previous one\r\n          pendingChange = this._changes.pop()!;\r\n          continue;\r\n        } else {\r\n          // If all items are removed, remove the last change\r\n          this._changes.pop();\r\n          // After removing, try to merge with the new last change\r\n          pendingChange = pendingChange;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Try to merge a removal inside a previous push\r\n      if (\r\n        lastChange.deleteCount === 0 &&\r\n        pendingChange.deleteCount > 0 &&\r\n        pendingChange.items.length === 0 &&\r\n        pendingChange.start >= lastChange.start &&\r\n        pendingChange.start < lastChange.start + lastChange.items.length &&\r\n        pendingChange.start + pendingChange.deleteCount <= lastChange.start + lastChange.items.length\r\n      ) {\r\n        // Remove items from inside the previous push\r\n        const relativeStart = pendingChange.start - lastChange.start;\r\n        lastChange.items.splice(relativeStart, pendingChange.deleteCount);\r\n        // After merging, try to merge lastChange with the previous one\r\n        pendingChange = this._changes.pop()!;\r\n        continue;\r\n      }\r\n\r\n      // No merge possible, just push\r\n      this._changes.push(pendingChange);\r\n      return;\r\n    }\r\n  }\r\n\r\n  private convertItemsToPropertyInfos(serverObjectInfo: ChangeTrackerObjectInfo<any>, items: T[]): PropertyInfo<any, any>[] {\r\n    return items.map((item) => this.convertItemToPropertyInfo(serverObjectInfo, item));\r\n  }\r\n\r\n  private convertItemToPropertyInfo(serverObjectInfo: ChangeTrackerObjectInfo<any>, item: T): PropertyInfo<any, any> {\r\n    const metaInfo = serverObjectInfo.convertToTrackableObjectReference(item as any);\r\n    const transformed: PropertyInfo<any, any> = {\r\n      value: item,\r\n      objectId: metaInfo?.objectId,\r\n      [isPropertyInfoSymbol]: true,\r\n    };\r\n\r\n    return transformed;\r\n  }\r\n\r\n  [Symbol.iterator]() {\r\n    return this._values[Symbol.iterator]();\r\n  }\r\n\r\n  private onPropertyChanged(property: string, value: any) {\r\n    const host = getHostObjectInfo(this);\r\n    if (!host) return;\r\n\r\n    host.onPropertyChanged(property as any, value);\r\n  }\r\n\r\n  [onTick](): void {\r\n    this._changes = [];\r\n  }\r\n\r\n  [onConvertedToTrackable](hostObjectInfo: ChangeTrackerObjectInfo<SyncableArray<T>>): void {\r\n    this._creation = [...this.convertItemsToPropertyInfos(hostObjectInfo, this._values)];\r\n    this.onPropertyChanged(\"_creation\", this._creation);\r\n    this.onPropertyChanged(\"_changes\", this._changes);\r\n  }\r\n\r\n  [onUpdateProperty](key: string | number | symbol, value: any, isForCreate: boolean, client: ObjectChangeApplicator, clientConnection: ClientConnection): boolean {\r\n    if (isForCreate && key === \"_creation\") {\r\n      this.value = this.convertPropertyInfosToItems(value, client, clientConnection);\r\n    } else if (!isForCreate && key === \"_changes\") {\r\n      this.applyTrackableArrayChanges(this._values, value, client, clientConnection);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private applyTrackableArrayChanges(arr: T[], changes: SyncableArrayChange<T>[], client: ObjectChangeApplicator, clientConnection: ClientConnection): T[] {\r\n    for (const change of changes) {\r\n      const newItems = this.convertPropertyInfosToItems(change.items, client, clientConnection);\r\n      const removedItems = arr.splice(change.start, change.deleteCount, ...newItems);\r\n      if (removedItems.length > 0) this.onRemoved(change.start, removedItems);\r\n      if (change.items.length > 0) this.onAdded(change.start, newItems);\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  // toJson and toValue\r\n  toJSON() {\r\n    return this._values;\r\n  }\r\n\r\n  toValue() {\r\n    return this._values;\r\n  }\r\n\r\n  protected onRemoved(start: number, items: T[]): void {\r\n    // Can be used in subclasses\r\n  }\r\n\r\n  protected onAdded(start: number, items: T[]): void {\r\n    // Can be used in subclasses\r\n  }\r\n}\r\n", "type EventFunction = (...args: any[]) => void;\r\n\r\nexport type EventMap = {\r\n  [key: string]: EventFunction;\r\n};\r\n\r\nexport type IEventEmitter<Events extends EventMap = EventMap> = {\r\n  on<Event extends keyof Events>(event: Event, callback: Events[Event]): void;\r\n  once<Event extends keyof Events>(event: Event, callback: Events[Event]): void;\r\n  off<Event extends keyof Events>(event: Event, callback: Events[Event]): void;\r\n  listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event] | undefined): number;\r\n};\r\n\r\nexport class EventEmitter<Events extends EventMap = EventMap> implements IEventEmitter<Events> {\r\n  readonly _events: {\r\n    [key in keyof Events]?: EventFunction[];\r\n  } = {};\r\n\r\n  public on<Event extends keyof Events>(event: Event, callback: Events[Event]): void {\r\n    if (!this._events[event]) this._events[event] = [callback];\r\n    else this._events[event].push(callback);\r\n\r\n    this.onEventListenerAdded(event, callback as Events[Event]);\r\n  }\r\n\r\n  public once<Event extends keyof Events>(event: Event, callback: Events[Event]): void {\r\n    const onceCallback = ((...args: any[]) => {\r\n      this.off(event, onceCallback);\r\n      callback(...args);\r\n    }) as Events[Event];\r\n\r\n    this.on(event, onceCallback);\r\n  }\r\n\r\n  public off<Event extends keyof Events>(event: Event, callback: Events[Event]): void {\r\n    if (!this._events[event]) return;\r\n\r\n    this._events[event] = this._events[event].filter((cb) => cb !== callback);\r\n    this.onEventListenerRemoved(event, callback);\r\n  }\r\n\r\n  public listenerCount<Event extends keyof Events>(event: Event, callback?: Events[Event]): number {\r\n    if (!this._events[event]) return 0;\r\n\r\n    if (!callback) return this._events[event].length;\r\n    return this._events[event].filter((cb) => cb === callback).length;\r\n  }\r\n\r\n  public emit<Event extends keyof Events>(event: Event, ...args: any[]): void {\r\n    if (!this._events[event]) return;\r\n\r\n    for (const callback of this._events[event]) {\r\n      callback(...args);\r\n    }\r\n  }\r\n\r\n  // protected emit2<Event extends keyof Events>(event: Event, ...args: Parameters<Events[Event]>): void {\r\n  //   if (!this._events[event as string]) return;\r\n  //   for (const callback of this._events[event as string]) {\r\n  //     callback(...args);\r\n  //   }\r\n  // }\r\n\r\n  protected onEventListenerAdded<Event extends keyof Events>(event: Event, callback: Events[Event]): void {\r\n    // do nothing\r\n  }\r\n\r\n  protected onEventListenerRemoved<Event extends keyof Events>(event: Event, callback: Events[Event]): void {\r\n    // do nothing\r\n  }\r\n}\r\n", "import { syncObject } from \"../tracker/decorators.js\";\r\nimport { SyncableArray } from \"./syncableArray.js\";\r\nimport { IEventEmitter, EventEmitter } from \"./eventEmitter.js\";\r\n\r\ntype SyncableObservableArrayEventMap = {\r\n  added: (items: any[], start: number) => void;\r\n  removed: (items: any[], start: number) => void;\r\n};\r\n\r\n@syncObject({\r\n  typeId: \"SyncableObservableArray\",\r\n})\r\nexport class SyncableObservableArray<T> extends SyncableArray<T> implements IEventEmitter<SyncableObservableArrayEventMap> {\r\n  private readonly _eventEmitter: EventEmitter<SyncableObservableArrayEventMap> = new EventEmitter<SyncableObservableArrayEventMap>();\r\n\r\n  constructor(initial: T[] = []) {\r\n    super();\r\n    this.push(...initial);\r\n  }\r\n\r\n  protected override onRemoved(start: number, items: T[]): void {\r\n    this._eventEmitter.emit(\"removed\", items, start);\r\n  }\r\n\r\n  protected override onAdded(start: number, items: T[]): void {\r\n    this._eventEmitter.emit(\"added\", items, start);\r\n  }\r\n\r\n  public on<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void {\r\n    this._eventEmitter.on(event, callback);\r\n  }\r\n\r\n  public once<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void {\r\n    this._eventEmitter.once(event, callback);\r\n  }\r\n\r\n  public off<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback: SyncableObservableArrayEventMap[Event]): void {\r\n    this._eventEmitter.off(event, callback);\r\n  }\r\n\r\n  public listenerCount<Event extends keyof SyncableObservableArrayEventMap>(event: Event, callback?: SyncableObservableArrayEventMap[Event] | undefined): number {\r\n    return this._eventEmitter.listenerCount(event, callback);\r\n  }\r\n}\r\n", "// Type which has only T or any iterable of T\r\nexport type OneOrMany<T> = T | Iterable<T>;\r\n\r\n// function which converts OneOrMany<T> to an iterable of T\r\nexport function toIterable<T>(input: OneOrMany<T>, preferSet = false): Iterable<T> {\r\n  if (Symbol.iterator in Object(input) && typeof input !== \"string\") {\r\n    return input as Iterable<T>;\r\n  }\r\n  return (preferSet ? new Set([input]) : [input]) as Iterable<T>;\r\n}\r\n\r\nexport function forEachIterable<T>(input: OneOrMany<T>, callback: (item: T) => void): void {\r\n  for (const item of toIterable(input)) {\r\n    callback(item);\r\n  }\r\n}\r\n\r\nexport function mapIterable<T, U>(input: OneOrMany<T>, mapper: (item: T) => U): U[] {\r\n  const result: U[] = [];\r\n  for (const item of toIterable(input)) {\r\n    result.push(mapper(item));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function filterIterable<T>(input: OneOrMany<T>, predicate: (item: T) => boolean): T[] {\r\n  const result: T[] = [];\r\n  for (const item of toIterable(input)) {\r\n    if (predicate(item)) {\r\n      result.push(item);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function findInIterable<T>(input: OneOrMany<T>, predicate: (item: T) => boolean): T | undefined {\r\n  for (const item of toIterable(input)) {\r\n    if (predicate(item)) {\r\n      return item;\r\n    }\r\n  }\r\n}\r\n\r\nexport function hasInIterable<T>(input: OneOrMany<T>, expected: T): boolean {\r\n  if (input instanceof Set) {\r\n    return input.has(expected);\r\n  }\r\n  for (const item of toIterable(input)) {\r\n    if (item === expected) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport type Constructor<T = any> = { new (...args: any[]): T };\r\n", "import {\r\n  PropertyInfo,\r\n  CreateObjectMessage,\r\n  PropertyInfos,\r\n  ChangeObjectMessage,\r\n  Message,\r\n  DeleteObjectMessage,\r\n  ExecuteObjectMessage,\r\n  isPropertyInfoSymbol,\r\n  MethodExecuteResult,\r\n} from \"../shared/index.js\";\r\nimport { beforeSendObjectToClient, beforeSendPropertyToClient, beforeExecuteOnClient, getTrackableTypeInfo, nothing } from \"./decorators.js\";\r\nimport { ClientConnection, ObjectChangeTracker } from \"./tracker.js\";\r\nimport { ensureObjectSyncMetaInfo, getObjectSyncMetaInfo, ObjectSyncMetaInfo, ObjectSyncMetaInfoCreateSettings } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { invokeOnConvertedToTrackable, invokeOnTick } from \"./interfaces.js\";\r\nimport { Constructor, hasInIterable, OneOrMany, toIterable } from \"../shared/types.js\";\r\nimport { ObjectInfoBase } from \"../shared/objectInfoBase.js\";\r\n\r\nexport type AdditionalHostPropertyInfo = {\r\n  hasPendingChanges: boolean;\r\n};\r\n\r\nexport type HostChangeObjectMessage<T extends object = object> = ChangeObjectMessage<T, AdditionalHostPropertyInfo>;\r\nexport type HostMessage<T extends object = object> = Message<T, AdditionalHostPropertyInfo>;\r\n\r\ntype TResult<T, K extends keyof T> = T[K] extends (...args: any[]) => any ? ReturnType<T[K]> : never;\r\n\r\nlet nextInvokeId = 0;\r\n\r\nexport type ClientFilter = {\r\n  /**\r\n   * Set of clients to include or exclude\r\n   */\r\n  clients?: OneOrMany<ClientConnection>;\r\n\r\n  /**\r\n   * Set of client designations to include or exclude\r\n   */\r\n  designations?: OneOrMany<string>;\r\n\r\n  /**\r\n   * If true, only the specified clients are included; if false, they are excluded, default is true\r\n   */\r\n  isExclusive?: boolean;\r\n};\r\n\r\nfunction isForClientConnection(clientConnection: ClientConnection, filter: ClientFilter): boolean {\r\n  let hasDesignation = filter.designations === undefined || clientConnection.identity === undefined;\r\n  if (!hasDesignation) {\r\n    hasDesignation = hasInIterable(filter.designations!, clientConnection.identity);\r\n  }\r\n\r\n  let hasClientConnection = filter.clients === undefined;\r\n  if (!hasClientConnection) {\r\n    hasClientConnection = hasInIterable(filter.clients!, clientConnection);\r\n  }\r\n\r\n  return filter.isExclusive === (hasDesignation && hasClientConnection);\r\n}\r\n\r\nexport type ServerObjectSyncMetaInfoCreateSettings<T extends object> = ObjectSyncMetaInfoCreateSettings<T> & {\r\n  isRoot: boolean;\r\n  objectIdPrefix: string;\r\n  owner: ObjectChangeTracker;\r\n};\r\n\r\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\r\nexport type MethodCallResultByClient<T> = Map<ClientConnection, Promise<UnwrapPromise<T>>>;\r\n\r\nexport type MethodCallResult<T> = Promise<MethodCallResultByClient<T>>;\r\n\r\ntype PendingMethodCall = {\r\n  id: unknown;\r\n  remainingClients: ClientConnection[];\r\n  resultByClient: Map<ClientConnection, Promise<any>>;\r\n  result: MethodCallResult<any>;\r\n  onRemainingClientsResolved: (value: Map<ClientConnection, Promise<any>>) => void;\r\n};\r\n\r\n/**\r\n * TrackableObject wraps an object for change tracking and client synchronization on the host side.\r\n * It manages property changes, client-specific views, and message generation for create, change, delete, and execute operations.\r\n */\r\nexport class ChangeTrackerObjectInfo<T extends object> extends ObjectInfoBase {\r\n  /**\r\n   * Ensures an object is auto-trackable, returning a TrackableObject if possible.\r\n   * If the object is already trackable, returns the existing wrapper.\r\n   */\r\n  static create<T extends object>(settings: ServerObjectSyncMetaInfoCreateSettings<T>): ChangeTrackerObjectInfo<T> | null {\r\n    if (!settings.object || typeof settings.object !== \"object\") return null;\r\n\r\n    const trackableTypeInfo = getTrackableTypeInfo((settings.object as any).constructor);\r\n    if (!trackableTypeInfo) return null;\r\n\r\n    const metaInfo = ensureObjectSyncMetaInfo(settings);\r\n    if (!metaInfo) {\r\n      throw new Error(\"Failed to create HostObjectInfo: unable to ensure ObjectSyncMetaInfo.\");\r\n    }\r\n\r\n    if (metaInfo.host) return metaInfo.host;\r\n\r\n    metaInfo.host = new ChangeTrackerObjectInfo<T>(metaInfo, settings.owner, settings.isRoot, settings.objectIdPrefix);\r\n    invokeOnConvertedToTrackable(metaInfo.object as T, metaInfo.host);\r\n    trackableTypeInfo.trackedProperties.forEach((propertyInfo, key) => {\r\n      metaInfo.host!.onPropertyChanged(key as keyof T, (settings.object as any)[key]);\r\n    });\r\n    return metaInfo.host!;\r\n  }\r\n\r\n  /** Holds the current set of property changes for this object. */\r\n  private readonly _changeSet: HostChangeObjectMessage<T>;\r\n  /** Holds pending method invocation messages for this object. */\r\n  private readonly _methodInvokeCalls: ExecuteObjectMessage<T>[] = [];\r\n  private readonly _pendingMethodInvokeCalls: Map<unknown, PendingMethodCall> = new Map();\r\n  /** Holds client filter settings for restricting visibility. */\r\n  private _clientFilters: ClientFilter | null = null;\r\n  /** Holds the set of clients which know about this. */\r\n  private _clients: Set<ClientConnection> = new Set();\r\n\r\n  private _lastMethodCallResult: MethodCallResult<any> | null = null;\r\n\r\n  /**\r\n   * Constructs a TrackableObject with a typeId and optional objectId.\r\n   */\r\n  private constructor(objectSyncMetaInfo: ObjectSyncMetaInfo, private readonly _host: ObjectChangeTracker, private _isRootObject: boolean, private readonly _objectIdPrefix: string) {\r\n    super(objectSyncMetaInfo);\r\n\r\n    this._changeSet = {\r\n      type: \"change\",\r\n      objectId: this.objectId,\r\n      properties: {},\r\n    };\r\n  }\r\n\r\n  get host() {\r\n    return this._host;\r\n  }\r\n\r\n  get clients(): Set<ClientConnection> {\r\n    return this._clients;\r\n  }\r\n\r\n  get isRootObject() {\r\n    return this._isRootObject;\r\n  }\r\n  set isRootObject(value: boolean) {\r\n    this._isRootObject = value;\r\n  }\r\n\r\n  get properties(): PropertyInfos<T, AdditionalHostPropertyInfo> {\r\n    return this._changeSet.properties;\r\n  }\r\n\r\n  /**\r\n   * Determines if this object is visible to a given client based on filters.\r\n   */\r\n  isForClient(client: ClientConnection): boolean {\r\n    if (!this._clientFilters) return true;\r\n\r\n    const filter = this._clientFilters;\r\n    return isForClientConnection(client, filter);\r\n  }\r\n\r\n  /**\r\n   * Removes all client restrictions, making the object visible to all clients.\r\n   */\r\n  removeClientRestrictions(): void {\r\n    this._clientFilters = null;\r\n  }\r\n\r\n  /**\r\n   * Restricts the object to a set of clients (inclusive or exclusive).\r\n   */\r\n  setClientRestriction(filter: ClientFilter): void {\r\n    this._clientFilters = {\r\n      clients: filter.clients ? toIterable(filter.clients, true) : undefined,\r\n      designations: filter.designations ? toIterable(filter.designations, true) : undefined,\r\n      isExclusive: filter.isExclusive ?? true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Records a property change, converting values to trackable references if needed.\r\n   */\r\n  onPropertyChanged(key: keyof T, value: T[keyof T]) {\r\n    let current = this._changeSet.properties[key];\r\n    if (!current) {\r\n      current = { hasPendingChanges: true, [isPropertyInfoSymbol]: true };\r\n      this._changeSet.properties[key] = current;\r\n    } else if (current.value === value) {\r\n      return;\r\n    }\r\n\r\n    this.convertToTrackableObjectReference(value as any);\r\n\r\n    const metaInfo = getObjectSyncMetaInfo(value as object);\r\n    const objectId: unknown = metaInfo?.objectId;\r\n    current.value = value as any;\r\n    current.objectId = objectId;\r\n    current.hasPendingChanges = true;\r\n  }\r\n\r\n  createPropertyInfo(value: any): PropertyInfo<T, keyof T> {\r\n    const trackable = this.convertToTrackableObjectReference(value);\r\n    const paramInfo: PropertyInfo<any, any> = {\r\n      value: trackable ?? value,\r\n      objectId: trackable?.objectSyncMetaInfo.objectId,\r\n      [isPropertyInfoSymbol]: true,\r\n    };\r\n\r\n    return paramInfo;\r\n  }\r\n\r\n  /**\r\n   * Records a method execution for this object, converting arguments to trackable references if needed.\r\n   */\r\n  onMethodExecute(method: keyof T, args: any[]) {\r\n    const parameters: PropertyInfos<any, any>[] = [];\r\n\r\n    args.forEach((arg, index) => {\r\n      const paramInfo = this.createPropertyInfo(arg);\r\n      parameters.push(paramInfo);\r\n    });\r\n\r\n    const message: ExecuteObjectMessage<T> = {\r\n      type: \"execute\",\r\n      id: nextInvokeId++,\r\n      objectId: this.objectId,\r\n      parameters: parameters as any,\r\n      method: method as any,\r\n    };\r\n\r\n    this._methodInvokeCalls.push(message);\r\n\r\n    let onRemainingClientsResolved: (result: Map<ClientConnection, Promise<T>>) => void;\r\n    const result = new Promise<Map<ClientConnection, Promise<T>>>((resolve) => {\r\n      onRemainingClientsResolved = resolve;\r\n    });\r\n\r\n    this._pendingMethodInvokeCalls.set(message.id, {\r\n      id: message.id,\r\n      resultByClient: new Map(),\r\n      remainingClients: [],\r\n      result,\r\n      onRemainingClientsResolved: onRemainingClientsResolved!,\r\n    });\r\n\r\n    this._lastMethodCallResult = result;\r\n\r\n    return result;\r\n  }\r\n\r\n  getInvokeResults<K extends keyof T = any>(method?: K): MethodCallResult<TResult<T, K>> | null {\r\n    const result = this._lastMethodCallResult;\r\n    this._lastMethodCallResult = null;\r\n    return result as MethodCallResult<TResult<T, K>> | null;\r\n  }\r\n\r\n  invoke<K extends keyof T>(method: K, ...args: T[K] extends (...a: infer P) => any ? P : never): { clientResults: MethodCallResult<TResult<T, K>>; hostResult: TResult<T, K> } {\r\n    const hostResult = (this.object as any)[method](...args) as TResult<T, K>;\r\n    const clientResults = this.getInvokeResults<K>(method)!;\r\n    return { clientResults, hostResult };\r\n  }\r\n\r\n  private onClientMethodExecuteSendToClient(client: ClientConnection, invokeId: unknown) {\r\n    const pendingCall = this._pendingMethodInvokeCalls.get(invokeId);\r\n    if (!pendingCall) return;\r\n\r\n    pendingCall.remainingClients.push(client);\r\n  }\r\n\r\n  onClientMethodExecuteResultReceived(methodExecuteResult: MethodExecuteResult, client: ClientConnection) {\r\n    const pendingCall = this._pendingMethodInvokeCalls.get(methodExecuteResult.id);\r\n    if (!pendingCall) return;\r\n\r\n    if (this.clients.has(client)) {\r\n      pendingCall.resultByClient.set(\r\n        client,\r\n        new Promise<any>((resolve, reject) => {\r\n          if (methodExecuteResult.status === \"resolved\") {\r\n            resolve(methodExecuteResult.result);\r\n          } else {\r\n            reject(methodExecuteResult.error);\r\n          }\r\n        })\r\n      );\r\n    }\r\n\r\n    pendingCall.remainingClients = pendingCall.remainingClients.filter((c) => c !== client);\r\n    if (pendingCall.remainingClients.length === 0) {\r\n      this._pendingMethodInvokeCalls.delete(methodExecuteResult.id);\r\n      pendingCall.onRemainingClientsResolved(pendingCall.resultByClient);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a value to a trackable object reference if possible.\r\n   */\r\n  public convertToTrackableObjectReference(target: object) {\r\n    if (target && typeof target === \"object\") {\r\n      return ChangeTrackerObjectInfo.create({\r\n        object: target,\r\n        isRoot: false,\r\n        objectIdPrefix: this._objectIdPrefix,\r\n        owner: this.host,\r\n      });\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Generates a create message for this object for a given client, applying any view-based typeId overrides.\r\n   * Returns null if the object should not be sent to the client.\r\n   */\r\n  getCreateMessage(client: ClientConnection): CreateObjectMessage<T> | null {\r\n    const typeIdOrNothing = beforeSendObjectToClient(this.object.constructor as Constructor, this.object, this.typeId, client);\r\n    if (typeIdOrNothing === nothing) return null;\r\n\r\n    const typeId = typeIdOrNothing as string;\r\n\r\n    const result: CreateObjectMessage<T> = {\r\n      type: \"create\",\r\n      objectId: this.objectId,\r\n      typeId,\r\n      properties: this.getProperties(client, false),\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates a delete message for this object.\r\n   */\r\n  getDeleteMessage(): DeleteObjectMessage {\r\n    const result: DeleteObjectMessage = {\r\n      type: \"delete\",\r\n      objectId: this.objectId,\r\n    };\r\n    this.cancelPendingMethodCalls();\r\n    return result;\r\n  }\r\n\r\n  onClientRemoved(clientConnection: ClientConnection) {\r\n    this.clients.delete(clientConnection);\r\n    this.cancelPendingMethodCalls(clientConnection);\r\n  }\r\n\r\n  cancelPendingMethodCalls(clientConnection?: ClientConnection): void {\r\n    this._pendingMethodInvokeCalls.forEach((pendingCall) => {\r\n      pendingCall.remainingClients.forEach((client) => {\r\n        if (clientConnection && client !== clientConnection) return;\r\n        this.onClientMethodExecuteResultReceived(\r\n          {\r\n            id: pendingCall.id,\r\n            status: \"rejected\",\r\n            error: new Error(\"Object deleted before method could be executed\"),\r\n            objectId: this.objectId,\r\n            result: undefined,\r\n          },\r\n          client\r\n        );\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates a change message for this object for a given client, including only changed properties.\r\n   * Returns null if there are no changes.\r\n   */\r\n  getChangeMessage(client: ClientConnection): ChangeObjectMessage<T> | null {\r\n    const properties = this.getProperties(client, true);\r\n    if (Object.keys(properties).length === 0) return null;\r\n    const result: ChangeObjectMessage<T> = {\r\n      type: \"change\",\r\n      objectId: this.objectId,\r\n      properties,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns all pending execute messages for this object.\r\n   */\r\n  getExecuteMessages(client: ClientConnection): ExecuteObjectMessage<T>[] {\r\n    const result: ExecuteObjectMessage<T>[] = [];\r\n    for (const methodExecuteCall of this._methodInvokeCalls) {\r\n      const args = methodExecuteCall.parameters.map((paramInfo) => {\r\n        return paramInfo.value;\r\n      });\r\n      if (beforeExecuteOnClient(this.object.constructor as Constructor, this.object, methodExecuteCall.method, args, client) === false) {\r\n        continue;\r\n      }\r\n\r\n      result.push({\r\n        ...methodExecuteCall,\r\n        parameters: args.map((arg) => this.createPropertyInfo(arg)),\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gathers property info for this object for a given client, applying any view-based property overrides.\r\n   * If includeChangedOnly is true, only changed properties are included.\r\n   */\r\n  private getProperties(client: ClientConnection, includeChangedOnly: boolean): PropertyInfos<T> {\r\n    const result: PropertyInfos<T> = {};\r\n    Object.keys(this._changeSet.properties).forEach((key) => {\r\n      let propertyInfo = this._changeSet.properties[key as keyof T]!;\r\n      if (includeChangedOnly && !propertyInfo.hasPendingChanges) return;\r\n\r\n      const finalValue = beforeSendPropertyToClient(this.object.constructor as Constructor, this.object, key, propertyInfo.value, client);\r\n      if (finalValue === nothing) return;\r\n\r\n      if (finalValue !== propertyInfo.value) {\r\n        propertyInfo = this.createPropertyInfo(finalValue) as any;\r\n\r\n        const metaInfo = getObjectSyncMetaInfo(finalValue as object);\r\n        propertyInfo.objectId = metaInfo?.objectId;\r\n      }\r\n\r\n      const clientPropertyInfo = this.serializePropertyInfo(key as keyof T, propertyInfo as PropertyInfo<T, keyof T>, client);\r\n      if (clientPropertyInfo) result[key as keyof T] = clientPropertyInfo;\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private serializePropertyInfo(key: keyof T, propertyInfo: PropertyInfo<T, keyof T>, client: ClientConnection) {\r\n    let clientPropertyInfo: PropertyInfo<T, keyof T> = {\r\n      objectId: propertyInfo.objectId,\r\n      value: propertyInfo.value,\r\n      [isPropertyInfoSymbol]: true,\r\n    };\r\n\r\n    if (propertyInfo.objectId === undefined && propertyInfo.objectId === null) {\r\n      delete clientPropertyInfo.objectId;\r\n    }\r\n\r\n    if (clientPropertyInfo.value && clientPropertyInfo.objectId === undefined && typeof clientPropertyInfo.value === \"object\") {\r\n      const serializedValue = this.serializeValue(clientPropertyInfo.value);\r\n      if (serializedValue === null) {\r\n        clientPropertyInfo.value = clientPropertyInfo.value;\r\n      } else {\r\n        clientPropertyInfo.value = serializedValue.value as any;\r\n        clientPropertyInfo.typeId = serializedValue.typeId;\r\n      }\r\n    }\r\n\r\n    return clientPropertyInfo;\r\n  }\r\n\r\n  private serializeValue(value: object) {\r\n    return this.host.serializeValue(value);\r\n  }\r\n\r\n  /**\r\n   * Resets the hasPendingChanges flag for all properties and clears pending method calls.\r\n   */\r\n  tick(): void {\r\n    Object.keys(this._changeSet.properties).forEach((key) => {\r\n      const propertyInfo = this._changeSet.properties[key as keyof T]!;\r\n      propertyInfo.hasPendingChanges = false;\r\n    });\r\n    this._methodInvokeCalls.length = 0;\r\n\r\n    invokeOnTick(this.objectSyncMetaInfo.object as T);\r\n  }\r\n}\r\n", "import { TypeSerializer } from \"../applicator/applicator.js\";\r\nimport { ChangeObjectMessage, CreateObjectMessage, DeleteObjectMessage, ExecuteObjectMessage, isPropertyInfo, Message, MethodExecuteResult, PropertyInfo, TrackedObjectPool } from \"../shared/index.js\";\r\nimport { getHostObjectInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { Constructor, forEachIterable, OneOrMany } from \"../shared/types.js\";\r\nimport { ClientFilter, ChangeTrackerObjectInfo, ServerObjectSyncMetaInfoCreateSettings } from \"./trackerObjectInfo.js\";\r\n\r\nexport type TrackSettings = {\r\n  /**\r\n   * Optional unique identifier for the object; if not provided, one will be generated.\r\n   */\r\n  objectId?: unknown;\r\n\r\n  /**\r\n   * If true, the object is considered a root object. Defaults to true.\r\n   */\r\n  isRoot?: boolean;\r\n\r\n  /**\r\n   * Settings for restricting client visibility of the object.\r\n   */\r\n  clientVisibility?: ClientFilter;\r\n\r\n  knownClients?: OneOrMany<ClientConnection>;\r\n};\r\n\r\nexport type ObjectChangeTrackerSettings = {\r\n  objectIdPrefix: string;\r\n  objectPool: TrackedObjectPool;\r\n  identity: string;\r\n  typeSerializers: Map<string, TypeSerializer<any>>;\r\n};\r\n\r\ntype FinalObjectChangeTrackerSettings = {\r\n  objectIdPrefix: string;\r\n  identity: string;\r\n};\r\n\r\nexport type ClientConnectionSettings = {\r\n  identity: string;\r\n};\r\n\r\nexport type ClientConnection = {\r\n  identity: string;\r\n};\r\n\r\n/**\r\n * The ChangeTrackerHost manages the lifecycle and visibility of trackable objects on the host/server side.\r\n * It tracks which objects are visible to which clients, manages object creation/deletion, and generates messages for clients.\r\n */\r\nexport class ObjectChangeTracker {\r\n  /** Pool of all currently tracked objects and their info. */\r\n  private _trackedObjectPool: TrackedObjectPool;\r\n  /** Maps client IDs to lists of delete messages for objects that have been untracked. */\r\n  private _untrackedObjectInfosByClient = new Map<ClientConnection, DeleteObjectMessage[]>();\r\n\r\n  private _clients: Set<ClientConnectionSettings> = new Set();\r\n  private _serializers: Map<Constructor, TypeSerializer<any> & { typeId: string }> = new Map<Constructor, TypeSerializer<any> & { typeId: string }>();\r\n\r\n  private readonly _settings: FinalObjectChangeTrackerSettings;\r\n\r\n  constructor(settings: ObjectChangeTrackerSettings) {\r\n    this._settings = {\r\n      identity: settings.identity,\r\n      objectIdPrefix: settings.objectIdPrefix,\r\n    };\r\n    this._trackedObjectPool = settings.objectPool;\r\n\r\n    settings.typeSerializers.forEach((gen, typeId) => {\r\n      const serializer = gen as TypeSerializer<any> & { typeId: string };\r\n      serializer.typeId = serializer.typeId ?? typeId;\r\n      this.registerSerializer(serializer);\r\n    });\r\n  }\r\n\r\n  get settings(): FinalObjectChangeTrackerSettings {\r\n    return this._settings;\r\n  }\r\n\r\n  registerSerializer(serializer: TypeSerializer<any> & { typeId: string }): void {\r\n    if (this._serializers.has(serializer.type)) {\r\n      throw new Error(`Serializer for typeId ${serializer.typeId} is already registered`);\r\n    }\r\n    this._serializers.set(serializer.type, serializer);\r\n  }\r\n\r\n  get identity() {\r\n    return this._settings.identity;\r\n  }\r\n\r\n  /** Returns all currently tracked objects. */\r\n  get allTrackedObjects() {\r\n    return this._trackedObjectPool.all;\r\n  }\r\n\r\n  registerClient(settings: ClientConnectionSettings): ClientConnection {\r\n    const clientToken = JSON.parse(JSON.stringify(settings));\r\n    this._clients.add(clientToken);\r\n    return clientToken;\r\n  }\r\n\r\n  /**\r\n   * Removes all client-specific state for a client (e.g., when disconnecting).\r\n   */\r\n  removeClient(client: ClientConnection): void {\r\n    if (!this._clients.has(client)) {\r\n      throw new Error(\"Unknown client token\");\r\n    }\r\n\r\n    this._trackedObjectPool.all.forEach((obj) => {\r\n      const hostObjectInfo = getHostObjectInfo(obj)!;\r\n      hostObjectInfo.onClientRemoved(client);\r\n    });\r\n    this._untrackedObjectInfosByClient.delete(client);\r\n\r\n    this._clients.delete(client);\r\n  }\r\n\r\n  /**\r\n   * Restricts the visibility of a tracked object to a set of clients.\r\n   * @param obj The object to restrict.\r\n   * @param clients The client(s) allowed or excluded.\r\n   * @param isExclusive If true, only the given clients can see the object; otherwise, all except these clients can see it.\r\n   */\r\n  setClientRestriction<T extends object>(obj: T, filter: ClientFilter): void {\r\n    const tracked = getHostObjectInfo(obj);\r\n    if (!tracked) throw new Error(\"Object is not tracked\");\r\n    tracked.setClientRestriction(filter);\r\n  }\r\n\r\n  /**\r\n   * Begins tracking an object, optionally with settings for object ID and client visibility.\r\n   * Throws if objectId is specified for an already-trackable object.\r\n   */\r\n  track<T extends object>(target: T, trackSettings?: TrackSettings): void {\r\n    this.trackInternal(target, trackSettings);\r\n  }\r\n\r\n  private trackInternal<T extends object>(target: T, trackSettings?: TrackSettings): ChangeTrackerObjectInfo<T> | null {\r\n    if (!target) return null;\r\n\r\n    const isRoot = trackSettings?.isRoot !== false;\r\n\r\n    let hostObjectInfo: ChangeTrackerObjectInfo<T> | null = getHostObjectInfo(target);\r\n    if (!hostObjectInfo) {\r\n      const creationSettings: ServerObjectSyncMetaInfoCreateSettings<T> = {\r\n        objectId: trackSettings?.objectId,\r\n        isRoot,\r\n        object: target,\r\n        objectIdPrefix: this._settings.objectIdPrefix!,\r\n        owner: this,\r\n      };\r\n\r\n      hostObjectInfo = getHostObjectInfo(target) ?? ChangeTrackerObjectInfo.create<T>(creationSettings);\r\n      if (!hostObjectInfo) return null;\r\n\r\n      if (!this._trackedObjectPool.has(target)) this._trackedObjectPool.add(target);\r\n\r\n      this._untrackedObjectInfosByClient.forEach((deleteMessages, client) => {\r\n        let deleteMessageIndex = deleteMessages.findIndex((m) => m.objectId === hostObjectInfo!.objectId);\r\n        if (deleteMessageIndex === -1) return;\r\n        deleteMessages.splice(deleteMessageIndex, 1);\r\n        if (deleteMessages.length === 0) {\r\n          this._untrackedObjectInfosByClient.delete(client);\r\n        }\r\n      });\r\n      if (trackSettings?.clientVisibility) {\r\n        this.setClientRestriction(target, trackSettings.clientVisibility);\r\n      }\r\n    } else {\r\n      if (!this._trackedObjectPool.has(target)) this._trackedObjectPool.add(target);\r\n    }\r\n\r\n    if (trackSettings?.knownClients) {\r\n      const clients = hostObjectInfo.clients;\r\n      if (clients) {\r\n        forEachIterable(trackSettings.knownClients, (client) => {\r\n          clients.add(client);\r\n        });\r\n      }\r\n    }\r\n\r\n    return hostObjectInfo!;\r\n  }\r\n\r\n  /**\r\n   * Stops tracking an object and queues delete messages for all clients that could see it.\r\n   * If an object is passed instead of a TrackableObject, it will first be looked up.\r\n   */\r\n  untrack<T extends object>(target: T): void {\r\n    if (this.untrackInternal(target, true)) this.removeUnusedObjects();\r\n  }\r\n\r\n  private untrackInternal<T extends object>(target: T, throwWhenNotTracked: boolean) {\r\n    const hostObjectInfo = getHostObjectInfo(target)!;\r\n    if (!this._trackedObjectPool.has(target) || !hostObjectInfo) {\r\n      if (throwWhenNotTracked) {\r\n        throw new Error(\"Object is not tracked\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    this._trackedObjectPool.delete(target);\r\n    const clients = Array.from(hostObjectInfo.clients);\r\n    const deleteMessage = hostObjectInfo.getDeleteMessage();\r\n    clients.forEach((client) => {\r\n      let deleteMessages = this._untrackedObjectInfosByClient.get(client);\r\n      if (!deleteMessages) {\r\n        deleteMessages = [];\r\n        this._untrackedObjectInfosByClient.set(client, deleteMessages);\r\n      }\r\n      deleteMessages.push(deleteMessage);\r\n    });\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * For a given message, finds and tracks any nested objects referenced by objectId/value pairs.\r\n   * Removes the value from the property after tracking.\r\n   * @returns Array of HostTrackableObjectInfo for any new objects tracked.\r\n   */\r\n  private gatherUntrackedObjectInfos(data: ChangeObjectMessage<any> | CreateObjectMessage<any>) {\r\n    return this.gatherUntrackedObjectInfosFromRaw(data.properties);\r\n  }\r\n\r\n  private gatherUntrackedObjectInfosFromRaw(data: object | Array<any>, tracked: Set<object> = new Set()): object[] {\r\n    if (tracked.has(data)) {\r\n      return [];\r\n    }\r\n    tracked.add(data);\r\n\r\n    const result: object[] = [];\r\n\r\n    if (isPropertyInfo(data)) {\r\n      const propertyInfo = data as PropertyInfo<any, any>;\r\n      if (propertyInfo.objectId && propertyInfo.value) {\r\n        const newTrackable = this.trackInternal(propertyInfo.value, { isRoot: false });\r\n        delete propertyInfo.value;\r\n        if (newTrackable) {\r\n          result.push(newTrackable.object);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (Array.isArray(data)) {\r\n      data.forEach((value) => {\r\n        if (!value || typeof value !== \"object\") return;\r\n\r\n        result.push(...this.gatherUntrackedObjectInfosFromRaw(value, tracked));\r\n      });\r\n      return result;\r\n    }\r\n\r\n    Object.keys(data).forEach((key) => {\r\n      const value = (data as any)[key];\r\n\r\n      if (!value || typeof value !== \"object\") return;\r\n\r\n      if (!isPropertyInfo(value)) {\r\n        result.push(...this.gatherUntrackedObjectInfosFromRaw(value, tracked));\r\n        return;\r\n      }\r\n\r\n      const propertyInfo = value as PropertyInfo<any, any>;\r\n      if (propertyInfo.objectId && propertyInfo.value) {\r\n        const newTrackable = this.trackInternal(propertyInfo.value, { isRoot: false });\r\n        delete propertyInfo.value;\r\n        if (newTrackable) {\r\n          result.push(newTrackable.object);\r\n        }\r\n      }\r\n\r\n      if (propertyInfo.value && typeof propertyInfo.value === \"object\") {\r\n        result.push(...this.gatherUntrackedObjectInfosFromRaw(propertyInfo.value, tracked));\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  getMessages(tick: boolean = true): Map<ClientConnection, Message[]> {\r\n    const result = new Map<ClientConnection, Message[]>();\r\n    for (const client of this._clients) {\r\n      result.set(client, this.getMessagesForClientInternal(client));\r\n    }\r\n    if (tick) this.tick();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Internal: Gathers all messages for a client.\r\n   */\r\n  private getMessagesForClientInternal(client: ClientConnection): Message[] {\r\n    const messages: Message[] = [];\r\n    let all = this._trackedObjectPool.all;\r\n    let newTrackableObjects: object[] = [];\r\n    while (all.length > 0) {\r\n      newTrackableObjects = [];\r\n      all.forEach((obj) => {\r\n        this.getMessagesForTrackableObjectInfo(obj, client, messages, newTrackableObjects);\r\n      });\r\n      all = newTrackableObjects;\r\n    }\r\n\r\n    this._untrackedObjectInfosByClient.forEach((deleteMessages, c) => {\r\n      if (c === client) {\r\n        messages.push(...deleteMessages);\r\n        this._untrackedObjectInfosByClient.delete(client);\r\n      }\r\n    });\r\n    return messages;\r\n  }\r\n\r\n  /**\r\n   * Internal: Adds create/change/execute messages for a tracked object to the outgoing message list for a client.\r\n   * Also tracks any nested objects referenced in the message.\r\n   */\r\n  private getMessagesForTrackableObjectInfo(syncObject: object, client: ClientConnection, messages: Message[], newTrackableObjects: object[]): void {\r\n    const hostObjectInfo = getHostObjectInfo(syncObject);\r\n    if (!hostObjectInfo?.isForClient(client)) return;\r\n\r\n    const hasClient = hostObjectInfo.clients.has(client);\r\n    let message: Message | null;\r\n    if (!hasClient) {\r\n      message = hostObjectInfo.getCreateMessage(client);\r\n      if (message !== null) {\r\n        hostObjectInfo.clients.add(client);\r\n      }\r\n    } else {\r\n      message = hostObjectInfo.getChangeMessage(client);\r\n    }\r\n    if (message !== null) {\r\n      newTrackableObjects.push(...this.gatherUntrackedObjectInfos(message));\r\n      messages.push(message);\r\n    }\r\n\r\n    const executeMessages = hostObjectInfo.getExecuteMessages(client) as ExecuteObjectMessage<object>[];\r\n    messages.push(...executeMessages);\r\n  }\r\n\r\n  public applyClientMethodInvokeResults(client: ClientConnection, methodExecuteResults: MethodExecuteResult[]) {\r\n    for (const result of methodExecuteResults) {\r\n      const tracked = this._trackedObjectPool.get(result.objectId);\r\n      if (!tracked) continue;\r\n      const hostObjectInfo = getHostObjectInfo(tracked);\r\n      hostObjectInfo?.onClientMethodExecuteResultReceived(result, client);\r\n    }\r\n  }\r\n\r\n  private tick(): void {\r\n    this._trackedObjectPool.all.forEach((obj) => {\r\n      const hostObjectInfo = getHostObjectInfo(obj)!;\r\n      hostObjectInfo?.tick();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes all tracked objects that are not reachable from any of the provided root objects.\r\n   * Traverses the object graph starting from the roots and untracks all unreachable objects.\r\n   */\r\n  private removeUnusedObjects(): void {\r\n    // Set of reachable TrackableObjects\r\n    const reachable = new Set<object>();\r\n    const stack: object[] = [];\r\n\r\n    // Helper to add an object to the stack if not already visited\r\n    const visit = (obj: object) => {\r\n      if (!reachable.has(obj)) {\r\n        reachable.add(obj);\r\n        stack.push(obj);\r\n      }\r\n    };\r\n\r\n    // Initialize stack with all root objects\r\n    const allRootObjects = this._trackedObjectPool.all.filter((info) => {\r\n      const hostObjectInfo = getHostObjectInfo(info)!;\r\n      return hostObjectInfo.isRootObject;\r\n    });\r\n    for (const root of allRootObjects) {\r\n      visit(root);\r\n    }\r\n\r\n    // Traverse the object graph\r\n    while (stack.length > 0) {\r\n      const current = stack.pop()!;\r\n      const hostObjectInfo = getHostObjectInfo(current)!;\r\n\r\n      const properties = hostObjectInfo.properties;\r\n      // Check all properties of the current object for references to other trackable objects\r\n      for (const key of Object.keys(properties)) {\r\n        const value = (properties as any)[key]!.value;\r\n        if (value && typeof value === \"object\") {\r\n          visit(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Untrack all objects that are not reachable\r\n    for (const tracked of this._trackedObjectPool.all) {\r\n      if (!reachable.has(tracked)) {\r\n        this.untrackInternal(tracked, false);\r\n      }\r\n    }\r\n  }\r\n\r\n  serializeValue(value: object): { value: any; typeId: string } | null {\r\n    const serializer = this._serializers.get(value.constructor as Constructor);\r\n    if (!serializer) return null;\r\n    return {\r\n      value: serializer.serialize ? serializer.serialize(value) : \"toJSON\" in value && typeof value.toJSON === \"function\" ? value.toJSON() : \"toValue\" in value && typeof value.toValue === \"function\" ? value.toValue() : value,\r\n      typeId: serializer.typeId,\r\n    };\r\n  }\r\n}\r\n", "import { ClientConnection, ClientConnectionSettings, ObjectChangeTracker, TrackSettings } from \"../tracker/tracker.js\";\r\nimport { allTypeGenerators, ObjectChangeApplicator, TypeGenerator, TypeSerializer } from \"../applicator/applicator.js\";\r\nimport { Message, MethodExecuteResult } from \"../shared/messages.js\";\r\nimport { TrackedObjectPool } from \"../shared/trackedObjectPool.js\";\r\nimport { Constructor } from \"../shared/types.js\";\r\nimport { getTrackableTypeInfo } from \"../tracker/decorators.js\";\r\n\r\nexport type ObjectSyncSettings = {\r\n  objectIdPrefix?: string;\r\n  identity: string;\r\n  typeGenerators?: Map<string, TypeGenerator> | Constructor[];\r\n  typeSerializers?: Map<string, TypeSerializer<any>> | TypeSerializer<any>[];\r\n};\r\n\r\ntype FinalObjectSyncSettings = {\r\n  objectIdPrefix: string;\r\n  identity: string;\r\n  typeGenerators: Map<string, TypeGenerator>;\r\n  typeSerializers: Map<string, TypeSerializer<any>>;\r\n};\r\n\r\nexport class ObjectSync {\r\n  private readonly _tracker: ObjectChangeTracker;\r\n  private readonly _applicator: ObjectChangeApplicator;\r\n  private readonly _settings: FinalObjectSyncSettings;\r\n\r\n  constructor(settings: ObjectSyncSettings) {\r\n    this._settings = {\r\n      identity: settings.identity,\r\n      objectIdPrefix: settings.objectIdPrefix ?? `${settings.identity}-${Date.now()}-`,\r\n      typeGenerators: new Map<string, TypeGenerator>(),\r\n      typeSerializers: new Map<string, TypeSerializer<any>>(),\r\n    };\r\n\r\n    if (Array.isArray(settings.typeGenerators)) {\r\n      for (const constructor of settings.typeGenerators) {\r\n        const trackableTypeInfo = getTrackableTypeInfo(constructor);\r\n        this._settings.typeGenerators.set(trackableTypeInfo?.typeId ?? constructor.name, constructor);\r\n      }\r\n    } else if (settings.typeGenerators) this._settings.typeGenerators = settings.typeGenerators;\r\n    else this._settings.typeGenerators = new Map(allTypeGenerators);\r\n\r\n    if (Array.isArray(settings.typeSerializers)) {\r\n      for (const serializer of settings.typeSerializers) {\r\n        this._settings.typeSerializers.set(serializer.typeId ?? serializer.type.name, serializer);\r\n      }\r\n    } else if (settings.typeSerializers) this._settings.typeSerializers = settings.typeSerializers;\r\n\r\n    const objectPool = new TrackedObjectPool();\r\n\r\n    this._tracker = new ObjectChangeTracker({\r\n      objectPool,\r\n      ...this._settings,\r\n    });\r\n    this._applicator = new ObjectChangeApplicator({\r\n      objectPool,\r\n      ...this._settings,\r\n    });\r\n  }\r\n\r\n  // get tracker(): ObjectChangeTracker {\r\n  //   return this._tracker;\r\n  // }\r\n\r\n  // get applicator(): ObjectChangeApplicator {\r\n  //   return this._applicator;\r\n  // }\r\n\r\n  getMessages(): Map<ClientConnection, Message[]> {\r\n    return this._tracker.getMessages();\r\n  }\r\n\r\n  applyAsync(messages: Message<any>[], clientConnection: ClientConnection) {\r\n    return this._applicator.applyAsync(messages, clientConnection);\r\n  }\r\n\r\n  applyClientMethodInvokeResults(resultsByClient: Map<ClientConnection, MethodExecuteResult[]>): void {\r\n    for (const [clientToken, results] of resultsByClient) {\r\n      this._tracker.applyClientMethodInvokeResults(clientToken, results);\r\n    }\r\n  }\r\n\r\n  async applyMessagesAsync(messagesByClient: Map<ClientConnection, Message[]>): Promise<Map<ClientConnection, MethodExecuteResult[]>> {\r\n    const resultsByClient = new Map<ClientConnection, MethodExecuteResult[]>();\r\n    for (const [clientToken, messages] of messagesByClient) {\r\n      const results = await this._applicator.applyAsync(messages, clientToken);\r\n      resultsByClient.set(clientToken, results.methodExecuteResults);\r\n      for (const obj of results.newTrackedObjects) {\r\n        this._tracker.track(obj, {\r\n          knownClients: clientToken,\r\n        });\r\n      }\r\n    }\r\n    return resultsByClient;\r\n  }\r\n\r\n  async applyMessagesFromClientAsync(clientConnection: ClientConnection, messages: Message[]): Promise<MethodExecuteResult[]> {\r\n    const results = await this._applicator.applyAsync(messages, clientConnection);\r\n    for (const obj of results.newTrackedObjects) {\r\n      this._tracker.track(obj, {\r\n        knownClients: clientConnection,\r\n      });\r\n    }\r\n    return results.methodExecuteResults;\r\n  }\r\n\r\n  async exchangeMessagesAsync(\r\n    sendToClientAsync: (client: ClientConnection, messages: Message[]) => Promise<MethodExecuteResult[]>,\r\n    errorHandler?: (client: ClientConnection, error: any) => void\r\n  ): Promise<void> {\r\n    const messages = this.getMessages();\r\n    const resultsByClient = new Map<ClientConnection, Promise<MethodExecuteResult[]>>();\r\n    const allPromises: Promise<MethodExecuteResult[]>[] = [];\r\n\r\n    for (const [clientToken, clientMessages] of messages) {\r\n      const methodInvokeResults = sendToClientAsync(clientToken, clientMessages);\r\n      allPromises.push(methodInvokeResults);\r\n      resultsByClient.set(clientToken, methodInvokeResults);\r\n    }\r\n\r\n    await Promise.allSettled(allPromises);\r\n\r\n    for (const [clientToken, resultsPromise] of resultsByClient) {\r\n      try {\r\n        const results = await resultsPromise;\r\n        this._tracker.applyClientMethodInvokeResults(clientToken, results);\r\n      } catch (error) {\r\n        if (errorHandler) {\r\n          errorHandler(clientToken, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async exchangeMessagesBulkAsync(\r\n    sendToClientsAsync: (messagesByClient: Map<ClientConnection, Message[]>) => Promise<Map<ClientConnection, MethodExecuteResult[]>>,\r\n    errorHandler?: (client: ClientConnection, error: any) => void\r\n  ): Promise<void> {\r\n    const messages = this.getMessages();\r\n    const resultsByClient = await sendToClientsAsync(messages);\r\n\r\n    for (const [clientToken, resultsPromise] of resultsByClient) {\r\n      try {\r\n        const results = await resultsPromise;\r\n        this._tracker.applyClientMethodInvokeResults(clientToken, results);\r\n      } catch (error) {\r\n        if (errorHandler) {\r\n          errorHandler(clientToken, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // shorthands for the tracker and applicator\r\n  registerSerializer(serializer: TypeSerializer<any> & { typeId: string }): void {\r\n    this._tracker.registerSerializer(serializer);\r\n  }\r\n\r\n  get identity() {\r\n    return this._settings.identity;\r\n  }\r\n\r\n  /** Returns all currently tracked objects. */\r\n  get allTrackedObjects() {\r\n    return this._tracker.allTrackedObjects;\r\n  }\r\n\r\n  registerClient(settings: ClientConnectionSettings) {\r\n    return this._tracker.registerClient(settings);\r\n  }\r\n\r\n  /**\r\n   * Removes all client-specific state for a client (e.g., when disconnecting).\r\n   */\r\n  removeClient(client: ClientConnection): void {\r\n    this._tracker.removeClient(client);\r\n  }\r\n\r\n  /**\r\n   * Begins tracking an object, optionally with settings for object ID and client visibility.\r\n   * Throws if objectId is specified for an already-trackable object.\r\n   */\r\n  track<T extends object>(target: T, trackSettings?: TrackSettings): void {\r\n    this._tracker.track(target, trackSettings);\r\n  }\r\n\r\n  untrack<T extends object>(target: T): void {\r\n    this._tracker.untrack(target);\r\n  }\r\n\r\n  //// Applicator shorthands\r\n  registerGenerator(typeId: string, generator: TypeGenerator): void {\r\n    this._applicator.registerGenerator(typeId, generator);\r\n  }\r\n\r\n  findObjectOfType<T extends object>(constructor: Constructor<T>, objectId?: unknown) {\r\n    return this._applicator.findObjectOfType(constructor, objectId);\r\n  }\r\n\r\n  findObjectsOfType<T extends object>(constructor: Constructor<T>) {\r\n    return this._applicator.findObjectsOfType(constructor);\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["syncProperty", "syncMethod", "syncObject", "__esDecorate", "__runInitializers", "syncObject"]
}
