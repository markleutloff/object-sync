{
  "version": 3,
  "sources": ["../build/shared/decorators.js", "../build/shared/eventEmitter.js", "../build/decorators/base.js", "../build/decorators/syncObject.js", "../build/shared/messages.js", "../build/shared/types.js", "../build/objectSync/clientFilter.js", "../build/shared/objectInfo.js", "../build/shared/objectPool.js", "../build/serialization/serializers/base.js", "../build/serialization/serializer.js", "../build/decorators/syncMethod.js", "../build/decorators/syncProperty.js", "../build/serialization/serializers/syncObject/serializer.js", "../build/serialization/serializers/syncObject/typedSerializer.js", "../build/objectSync/objectReference.js", "../build/objectSync/primitiveValue.js", "../build/objectSync/objectSync.js", "../build/objectSync/standaloneSerialization.js", "../build/serialization/serializers/syncArray/metaInfo.js", "../build/serialization/serializers/syncArray/syncArray.js", "../build/serialization/serializers/syncArray/syncObservableArray.js", "../build/serialization/serializers/syncArray/changeSet.js", "../build/serialization/serializers/syncArray/serializer.js", "../build/serialization/serializers/set.js", "../build/serialization/serializers/map.js", "../build/serialization/serializers/object.js"],
  "sourcesContent": ["Symbol.metadata ??= Symbol(\"metadata\");\nexport {};\n", "export class EventEmitter {\n    _events = {};\n    on(event, callback) {\n        if (!this._events[event])\n            this._events[event] = [callback];\n        else\n            this._events[event].push(callback);\n        this.onEventListenerAdded(event, callback);\n    }\n    once(event, callback) {\n        const onceCallback = ((...args) => {\n            this.off(event, onceCallback);\n            callback(...args);\n        });\n        this.on(event, onceCallback);\n    }\n    off(event, callback) {\n        if (!this._events[event])\n            return;\n        this._events[event] = this._events[event].filter((cb) => cb !== callback);\n        this.onEventListenerRemoved(event, callback);\n    }\n    listenerCount(event, callback) {\n        if (!this._events[event])\n            return 0;\n        if (!callback)\n            return this._events[event].length;\n        return this._events[event].filter((cb) => cb === callback).length;\n    }\n    emit(event, ...args) {\n        if (!this._events[event])\n            return;\n        for (const callback of this._events[event]) {\n            callback(...args);\n        }\n    }\n    onEventListenerAdded(event, callback) {\n    }\n    onEventListenerRemoved(event, callback) {\n    }\n}\n", "import { EventEmitter } from \"../shared/eventEmitter.js\";\nexport const nothing = Symbol(\"nothing\");\nclass ObjectSyncMetaInfo extends EventEmitter {\n    reportPropertyChanged(instance, propertyInfo, propertyKey, value) {\n        this.emit(\"propertyChanged\", propertyInfo, instance, propertyKey, value);\n    }\n}\nconst metaInfoByValue = new WeakMap();\nexport function ensureObjectSyncMetaInfo(instance) {\n    let metaInfo = metaInfoByValue.get(instance);\n    if (!metaInfo) {\n        metaInfo = new ObjectSyncMetaInfo();\n        metaInfoByValue.set(instance, metaInfo);\n    }\n    return metaInfo;\n}\nexport function getObjectSyncMetaInfo(instance) {\n    return metaInfoByValue.get(instance) || null;\n}\n", "import \"../shared/decorators.js\";\nimport { nothing } from \"./base.js\";\nconst TRACKABLE_CONSTRUCTOR_INFO = Symbol(\"trackableConstructor\");\nexport const allSyncObjectTypes = new Set();\nexport function syncObject(settings) {\n    return function syncObject(target, context) {\n        settings ??= {};\n        settings.typeId ??= context.name;\n        const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\n        trackableInfo.typeId = settings.typeId;\n        trackableInfo.clientTypeId = settings.clientTypeId;\n        trackableInfo.constructorArguments = settings.constructorArguments;\n        if (settings.properties) {\n            for (const [propertyKey, propertySettings] of Object.entries(settings.properties)) {\n                trackableInfo.trackedProperties.set(propertyKey, {\n                    ...propertySettings,\n                });\n            }\n        }\n        if (settings.methods) {\n            for (const [methodKey, methodSettings] of Object.entries(settings.methods)) {\n                trackableInfo.trackedMethods.set(methodKey, {\n                    ...methodSettings,\n                });\n            }\n        }\n        allSyncObjectTypes.add(target);\n    };\n}\nexport function ensureTrackableConstructorInfo(metadata) {\n    const oldTrackableInfo = (metadata[TRACKABLE_CONSTRUCTOR_INFO] ?? {\n        trackedProperties: new Map(),\n        trackedMethods: new Map(),\n        isAutoTrackable: false,\n        clientTypeId: undefined,\n    });\n    const newTrackableInfo = {\n        trackedProperties: new Map(oldTrackableInfo.trackedProperties),\n        trackedMethods: new Map(oldTrackableInfo.trackedMethods),\n        typeId: oldTrackableInfo.typeId,\n        clientTypeId: oldTrackableInfo.clientTypeId,\n    };\n    metadata[TRACKABLE_CONSTRUCTOR_INFO] = newTrackableInfo;\n    return newTrackableInfo;\n}\nexport function getTrackableTypeInfo(ctor) {\n    const trackableInfo = ctor[Symbol.metadata]?.[TRACKABLE_CONSTRUCTOR_INFO];\n    return trackableInfo ?? null;\n}\nexport function beforeSendObjectToClient(constructor, instance, typeId, destinationClientConnection) {\n    const constructorInfo = getTrackableTypeInfo(constructor);\n    if (!constructorInfo) {\n        return nothing;\n    }\n    if (constructorInfo.clientTypeId === undefined) {\n        return typeId;\n    }\n    if (constructorInfo.clientTypeId === null || constructorInfo.clientTypeId === nothing) {\n        return nothing;\n    }\n    if (typeof constructorInfo.clientTypeId === \"string\") {\n        return constructorInfo.clientTypeId;\n    }\n    if (typeof constructorInfo.clientTypeId !== \"function\") {\n        throw new Error(`Invalid clientTypeId in trackable constructor info.`);\n    }\n    const newConstructorInfo = getTrackableTypeInfo(constructorInfo.clientTypeId);\n    if (newConstructorInfo && newConstructorInfo.typeId) {\n        return newConstructorInfo.typeId;\n    }\n    const result = constructorInfo.clientTypeId.call(instance, { instance, constructor, typeId, destinationClientConnection });\n    if (result === null || result === undefined || result === nothing) {\n        return nothing;\n    }\n    if (typeof result === \"string\") {\n        return result;\n    }\n    if (typeof result === \"function\") {\n        const newConstructorInfo = getTrackableTypeInfo(result);\n        if (newConstructorInfo && newConstructorInfo.typeId) {\n            return newConstructorInfo.typeId;\n        }\n        throw new Error(`The constructor returned from beforeSendToClient does not have a typeId.`);\n    }\n    return typeId;\n}\n", "export const isPropertyInfoSymbol = Symbol(\"isPropertyInfo\");\nexport const CreateMessageType = \"create\";\nexport const ChangeMessageType = \"change\";\nexport const DeleteMessageType = \"delete\";\nexport const ExecuteMessageType = \"execute\";\nexport const ExecuteFinishedMessageType = \"executeFinished\";\nexport function isPropertyInfo(value) {\n    return isPropertyInfoSymbol in value;\n}\nexport function isExecuteObjectMessage(message) {\n    return message.type === ExecuteMessageType;\n}\nexport function isChangeObjectMessage(message) {\n    return message.type === ChangeMessageType;\n}\nexport function isCreateObjectMessage(message) {\n    return message.type === CreateMessageType;\n}\nexport function isDeleteObjectMessage(message) {\n    return message.type === DeleteMessageType;\n}\nexport function isExecuteFinishedObjectMessage(message) {\n    return message.type === ExecuteFinishedMessageType;\n}\n", "export function isIterable(input) {\n    return input && Symbol.iterator in Object(input) && typeof input !== \"string\";\n}\nexport function toIterable(input, preferSet = false) {\n    if (isIterable(input)) {\n        return input;\n    }\n    return (preferSet ? new Set([input]) : [input]);\n}\nexport function forEachIterable(input, callback) {\n    for (const item of toIterable(input)) {\n        callback(item);\n    }\n}\nexport function mapIterable(input, mapper) {\n    const result = [];\n    for (const item of toIterable(input)) {\n        result.push(mapper(item));\n    }\n    return result;\n}\nexport function filterIterable(input, predicate) {\n    const result = [];\n    for (const item of toIterable(input)) {\n        if (predicate(item)) {\n            result.push(item);\n        }\n    }\n    return result;\n}\nexport function findInIterable(input, predicate) {\n    for (const item of toIterable(input)) {\n        if (predicate(item)) {\n            return item;\n        }\n    }\n}\nexport function hasInIterable(input, expected) {\n    if (input instanceof Set) {\n        return input.has(expected);\n    }\n    for (const item of toIterable(input)) {\n        if (item === expected) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function isPrimitiveValue(value) {\n    return value === undefined || value === null || (typeof value !== \"object\" && typeof value !== \"function\");\n}\nexport function isPromiseLike(value) {\n    return value && typeof value.then === \"function\" && typeof value.catch === \"function\";\n}\n", "import { hasInIterable } from \"../shared/types.js\";\nexport function isForClientToken(clientToken, filter) {\n    let hasDesignation = filter.identities === undefined || clientToken.identity === undefined;\n    if (!hasDesignation) {\n        hasDesignation = hasInIterable(filter.identities, clientToken.identity);\n    }\n    let hasClientConnection = filter.clientTokens === undefined;\n    if (!hasClientConnection) {\n        hasClientConnection = hasInIterable(filter.clientTokens, clientToken);\n    }\n    return filter.isExclusive === (hasDesignation && hasClientConnection);\n}\n", "import { isForClientToken } from \"../objectSync/clientFilter.js\";\nimport { toIterable } from \"./types.js\";\nexport class ObjectInfo {\n    _owner;\n    _objectId;\n    _isRoot;\n    _serializer = null;\n    _instance = null;\n    _clientFilters = null;\n    _isOwned = false;\n    _referenceCountByClient = new Map();\n    constructor(_owner, _objectId = null, instanceOrTypeId = null, _isRoot = false) {\n        this._owner = _owner;\n        this._objectId = _objectId;\n        this._isRoot = _isRoot;\n        if (typeof instanceOrTypeId === \"string\") {\n            this._objectId ??= this._owner.generateObjectId();\n        }\n        else {\n            this._instance = instanceOrTypeId;\n            this._objectId ??= this._owner.generateObjectId(this._instance);\n        }\n    }\n    initializeSerializer(instanceOrTypeId = null) {\n        const Serializer = this._owner.findSerializer(instanceOrTypeId);\n        this._serializer = new Serializer(this);\n        if (this._instance)\n            this._serializer.onInstanceSet(false);\n    }\n    get isOwned() {\n        return this._isOwned;\n    }\n    set isOwned(value) {\n        this._isOwned = this._isOwned || value;\n    }\n    get objectId() {\n        return this._objectId;\n    }\n    get instance() {\n        return this._instance;\n    }\n    set instance(value) {\n        if (this._instance)\n            throw new Error(\"Instance is already set and cannot be changed.\");\n        this._instance = value;\n        this._owner.reportInstanceCreated(value, this._objectId);\n    }\n    get isRoot() {\n        return this._isRoot;\n    }\n    set isRoot(value) {\n        this._isRoot = value;\n    }\n    get serializer() {\n        return this._serializer;\n    }\n    get owner() {\n        return this._owner;\n    }\n    addReference(clientToken) {\n        this._referenceCountByClient.set(clientToken, (this._referenceCountByClient.get(clientToken) ?? 0) + 1);\n        let isDisposed = false;\n        return {\n            dispose: () => {\n                if (isDisposed)\n                    return;\n                isDisposed = true;\n                this.removeReference(clientToken);\n            },\n        };\n    }\n    get isOrphaned() {\n        if (this._isRoot || !this._isOwned)\n            return false;\n        for (const count of this._referenceCountByClient.values()) {\n            if (count > 0)\n                return false;\n        }\n        return true;\n    }\n    mustDeleteForClient(clientToken) {\n        return this._instance !== null && this._isOwned && !this._isRoot && this._serializer.clients.has(clientToken) && (this._referenceCountByClient.get(clientToken) ?? 0) <= 0;\n    }\n    removeReference(clientToken) {\n        const currentCount = this._referenceCountByClient.get(clientToken);\n        if (currentCount === undefined)\n            return;\n        if (currentCount <= 1) {\n            this._referenceCountByClient.delete(clientToken);\n        }\n        else {\n            this._referenceCountByClient.set(clientToken, currentCount - 1);\n        }\n    }\n    setClientRestriction(filter) {\n        this._clientFilters = {\n            clientTokens: filter.clientTokens ? toIterable(filter.clientTokens, true) : undefined,\n            identities: filter.identities ? toIterable(filter.identities, true) : undefined,\n            isExclusive: filter.isExclusive ?? true,\n        };\n    }\n    isForClientToken(clientToken) {\n        if (!this._clientFilters)\n            return true;\n        const filter = this._clientFilters;\n        return isForClientToken(clientToken, filter);\n    }\n    removeClientRestrictions() {\n        this._clientFilters = null;\n    }\n}\n", "export class ObjectPool {\n    _objectToInfo = new Map();\n    _objectIdToInfo = new Map();\n    hasObject(instance) {\n        return this._objectToInfo.has(instance);\n    }\n    hasObjectId(objectId) {\n        return this._objectIdToInfo.has(objectId);\n    }\n    getInfoByObject(instance) {\n        return this._objectToInfo.get(instance);\n    }\n    getObjectById(objectId) {\n        return this._objectIdToInfo.get(objectId)?.instance;\n    }\n    getInfoById(objectId) {\n        return this._objectIdToInfo.get(objectId);\n    }\n    get objects() {\n        return Array.from(this._objectIdToInfo.values()).map((info) => info.instance);\n    }\n    get infos() {\n        return Array.from(this._objectIdToInfo.values());\n    }\n    objectInfosToDelete(clientToken) {\n        return this.infos.filter((info) => info.mustDeleteForClient(clientToken));\n    }\n    orphanedObjectInfos(clientToken) {\n        return this.infos.filter((info) => info.isOrphaned);\n    }\n    get ownedObjects() {\n        return this.infos.filter((info) => info.isOwned).map((info) => info.instance);\n    }\n    add(info) {\n        const { instance, objectId } = info;\n        if (instance)\n            this._objectToInfo.set(instance, info);\n        this._objectIdToInfo.set(objectId, info);\n        return info;\n    }\n    deleteByObject(instance) {\n        const info = this._objectToInfo.get(instance);\n        if (info) {\n            this._objectIdToInfo.delete(info.objectId);\n            this._objectToInfo.delete(instance);\n        }\n    }\n    deleteById(objectId) {\n        const info = this._objectIdToInfo.get(objectId);\n        if (info) {\n            this._objectToInfo.delete(info.instance);\n            this._objectIdToInfo.delete(objectId);\n        }\n    }\n    onObjectSet(info) {\n        this._objectToInfo.set(info.instance, info);\n    }\n    findOne(constructor, objectId) {\n        return this.infos.find((info) => {\n            return info.instance && info.instance instanceof constructor && (objectId === undefined || info.objectId === objectId);\n        })?.instance;\n    }\n    findAll(constructor) {\n        return this.infos\n            .filter((info) => {\n            return info.instance && info.instance instanceof constructor;\n        })\n            .map((info) => info.instance);\n    }\n}\n", "export const defaultIntrinsicSerializers = [];\n", "import { isPrimitiveValue } from \"../shared/types.js\";\nexport class TypeSerializer {\n    _objectInfo;\n    static canSerialize(instanceOrTypeId) {\n        throw new Error(\"Not implemented\");\n    }\n    _clients = new Set();\n    _storedReferencesByKey = new Map();\n    _hasPendingChanges = false;\n    constructor(_objectInfo) {\n        this._objectInfo = _objectInfo;\n    }\n    get hasPendingChanges() {\n        return this._hasPendingChanges;\n    }\n    set hasPendingChanges(value) {\n        if (this._hasPendingChanges)\n            return;\n        this._hasPendingChanges = value;\n        this.reportPendingMessages();\n    }\n    get objectId() {\n        return this._objectInfo.objectId;\n    }\n    get instance() {\n        return this._objectInfo.instance;\n    }\n    set instance(value) {\n        this._objectInfo.instance = value;\n        this.onInstanceSet(true);\n    }\n    onInstanceSet(createdByCreateObjectMessage) {\n        if (!createdByCreateObjectMessage) {\n            this.reportPendingMessages();\n        }\n    }\n    get clients() {\n        return this._clients;\n    }\n    onClientConnectionRemoved(clientToken) {\n        this._clients.delete(clientToken);\n        this._storedReferencesByKey.forEach((storedReferencesByClient, key) => {\n            const storedReference = storedReferencesByClient.get(clientToken);\n            storedReference?.dispose();\n        });\n    }\n    clearStates(clientToken) {\n        if (!clientToken)\n            this._hasPendingChanges = false;\n    }\n    reportPendingMessages() {\n        this._objectInfo.owner.reportPendingMessagesForObject(this._objectInfo);\n    }\n    serializeValue(value, clientToken) {\n        return this._objectInfo.owner.serializeValue(value, clientToken);\n    }\n    deserializeValue(value, clientToken) {\n        return this._objectInfo.owner.deserializeValue(value, clientToken);\n    }\n    storeReference(value, clientConnectionOrKey, clientToken) {\n        let key = undefined;\n        if (clientConnectionOrKey && typeof clientConnectionOrKey === \"object\") {\n            clientToken = clientConnectionOrKey;\n        }\n        else if (clientConnectionOrKey !== undefined) {\n            key = clientConnectionOrKey;\n        }\n        return this.storeReferenceInternal(value, clientToken, key);\n    }\n    clearAllStoredReferencesWithKey(key) {\n        const storedReferencesByClient = this._storedReferencesByKey.get(key);\n        if (storedReferencesByClient) {\n            storedReferencesByClient.forEach((storedReference) => {\n                storedReference.dispose();\n            });\n        }\n    }\n    clearAllStoredReferencesWithClientConnection(clientToken) {\n        this._storedReferencesByKey.forEach((storedReferencesByClient, key) => {\n            const storedReference = storedReferencesByClient.get(clientToken);\n            storedReference?.dispose();\n        });\n    }\n    storeReferenceInternal(value, clientToken, key) {\n        let storedReferencesByClient = this._storedReferencesByKey.get(key);\n        if (!storedReferencesByClient) {\n            storedReferencesByClient = new Map();\n            this._storedReferencesByKey.set(key, storedReferencesByClient);\n        }\n        const previousStoredReference = storedReferencesByClient.get(clientToken);\n        previousStoredReference?.dispose();\n        if (isPrimitiveValue(value)) {\n            return {\n                dispose() { },\n            };\n        }\n        const storedReference = this._objectInfo.owner.trackInternal(value).addReference(clientToken);\n        let isDisposed = false;\n        const finalStoredReference = {\n            dispose: () => {\n                if (isDisposed)\n                    return;\n                isDisposed = true;\n                storedReference.dispose();\n                storedReferencesByClient.delete(clientToken);\n                if (storedReferencesByClient.size === 0) {\n                    this._storedReferencesByKey.delete(key);\n                }\n            },\n        };\n        storedReferencesByClient.set(clientToken, finalStoredReference);\n        return finalStoredReference;\n    }\n    get dispatcher() {\n        return null;\n    }\n}\nexport class ExtendedTypeSerializer extends TypeSerializer {\n    _messageTypeToHandler = new Map();\n    constructor(objectInfo) {\n        super(objectInfo);\n        this.registerMessageHandler(\"create\", (message, clientToken) => this.onCreateMessageReceived(message, clientToken));\n        this.registerMessageHandler(\"change\", (message, clientToken) => this.onChangeMessageReceived(message, clientToken));\n    }\n    registerMessageHandler(messageType, handler) {\n        this._messageTypeToHandler.set(messageType, handler);\n    }\n    async applyMessage(message, clientToken) {\n        const handler = this._messageTypeToHandler.get(message.type);\n        if (handler) {\n            await handler(message, clientToken);\n        }\n        else if (message.type === \"create\") {\n            throw new Error(`No handler registered for message type '${message.type}' in serializer.`);\n        }\n    }\n    onChangeMessageReceived(message, clientToken) {\n    }\n}\nexport function MakeSimpleTypeSerializer(settings) {\n    const { type, typeId, serialize, deserialize } = settings;\n    return class SimpleTypeSerializer extends ExtendedTypeSerializer {\n        static canSerialize(instanceOrTypeId) {\n            if (typeof instanceOrTypeId === \"string\") {\n                return instanceOrTypeId === typeId;\n            }\n            else {\n                return instanceOrTypeId instanceof type;\n            }\n        }\n        getTypeId(_clientConnection) {\n            return typeId;\n        }\n        generateMessages(_clientConnection, isNewClientConnection) {\n            const messages = [];\n            if (isNewClientConnection) {\n                messages.push({\n                    type: \"create\",\n                    objectId: this.objectId,\n                    typeId: typeId,\n                    data: serialize(this.instance),\n                });\n            }\n            return messages;\n        }\n        onCreateMessageReceived(message, clientToken) {\n            this.instance = deserialize(message.data);\n        }\n    };\n}\n", "import \"../shared/decorators.js\";\nimport { ensureTrackableConstructorInfo, getTrackableTypeInfo } from \"./syncObject.js\";\nexport function syncMethod(settings) {\n    settings ??= {};\n    return function syncMethod(target, context) {\n        const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\n        const methodInfo = {\n            ...settings,\n        };\n        const methodName = context.name;\n        trackableInfo.trackedMethods.set(methodName, methodInfo);\n    };\n}\nexport function beforeExecuteOnClient(constructor, instance, methodKey, args, destinationClientConnection) {\n    const constructorInfo = getTrackableTypeInfo(constructor);\n    if (!constructorInfo) {\n        return false;\n    }\n    const methodInfo = constructorInfo.trackedMethods.get(methodKey);\n    if (!methodInfo || methodInfo.mode === \"none\" || methodInfo.mode === \"applyOnly\") {\n        return false;\n    }\n    if (methodInfo.beforeExecuteOnClient?.call(instance, { instance, key: methodKey, args, destinationClientConnection }) === false) {\n        return false;\n    }\n    return true;\n}\nexport function getSyncMethodInfo(constructor, propertyKey) {\n    const constructorInfo = getTrackableTypeInfo(constructor);\n    if (!constructorInfo) {\n        return null;\n    }\n    const propertyInfo = constructorInfo.trackedMethods.get(propertyKey);\n    return propertyInfo ?? null;\n}\n", "import \"../shared/decorators.js\";\nimport { getObjectSyncMetaInfo, nothing } from \"./base.js\";\nimport { ensureTrackableConstructorInfo, getTrackableTypeInfo } from \"./syncObject.js\";\nexport function syncProperty(settings) {\n    settings ??= {};\n    return function syncProperty(target, context) {\n        const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\n        const propertyInfo = {\n            ...settings,\n        };\n        const propertyName = context.name;\n        trackableInfo.trackedProperties.set(propertyName, propertyInfo);\n        const result = {\n            set(value) {\n                target.set.call(this, value);\n                if (propertyInfo.mode === \"none\" || propertyInfo.mode === \"applyOnly\")\n                    return;\n                const metaInfo = getObjectSyncMetaInfo(this);\n                metaInfo?.reportPropertyChanged(this, propertyInfo, propertyName, value);\n            },\n        };\n        return result;\n    };\n}\nexport function checkCanApplyProperty(constructor, instance, propertyKey, isMethod, sourceClientConnection) {\n    const constructorInfo = getTrackableTypeInfo(constructor);\n    if (!constructorInfo)\n        return false;\n    const propertyInfo = isMethod ? constructorInfo.trackedMethods.get(propertyKey) : constructorInfo.trackedProperties.get(propertyKey);\n    if (!propertyInfo)\n        return false;\n    if (propertyInfo.mode === \"none\" || propertyInfo.mode === \"trackOnly\")\n        return;\n    if (propertyInfo.canApply?.call(instance, { instance, key: propertyKey, sourceClientConnection }) === false)\n        return false;\n    return true;\n}\nexport function beforeSendPropertyToClient(constructor, instance, propertyKey, value, destinationClientConnection) {\n    const constructorInfo = getTrackableTypeInfo(constructor);\n    if (!constructorInfo) {\n        return nothing;\n    }\n    const propertyInfo = constructorInfo.trackedProperties.get(propertyKey);\n    if (!propertyInfo) {\n        return nothing;\n    }\n    if (!propertyInfo.beforeSendToClient) {\n        return value;\n    }\n    return propertyInfo.beforeSendToClient.call(instance, { instance, key: propertyKey, value, destinationClientConnection });\n}\nexport function getSyncPropertyInfo(constructor, propertyKey) {\n    const constructorInfo = getTrackableTypeInfo(constructor);\n    if (!constructorInfo) {\n        return null;\n    }\n    const propertyInfo = constructorInfo.trackedProperties.get(propertyKey);\n    return propertyInfo ?? null;\n}\n", "import { ExtendedTypeSerializer } from \"../../serializer.js\";\nimport { forEachIterable, isIterable, isPrimitiveValue, isPromiseLike } from \"../../../shared/types.js\";\nimport { ensureObjectSyncMetaInfo, nothing } from \"../../../decorators/base.js\";\nimport { beforeExecuteOnClient, getSyncMethodInfo } from \"../../../decorators/syncMethod.js\";\nimport { beforeSendObjectToClient, getTrackableTypeInfo } from \"../../../decorators/syncObject.js\";\nimport { beforeSendPropertyToClient, checkCanApplyProperty } from \"../../../decorators/syncProperty.js\";\nexport class SyncObjectSerializer extends ExtendedTypeSerializer {\n    _typeInfo = null;\n    _properties = new Map();\n    _temporaryReferencesByClient = new Map();\n    _pendingInvokeMethodInfosById = new Map();\n    _methodInvokeResultsByClient = new Map();\n    _nextInvokeId = 1;\n    _dispatcher;\n    constructor(objectInfo) {\n        super(objectInfo);\n        this.registerMessageHandler(\"execute\", (message, clientToken) => this.onExecuteMessageReceived(message, clientToken));\n        this.registerMessageHandler(\"executeFinished\", (message, clientToken) => this.onExecuteFinishedMessageReceived(message, clientToken));\n    }\n    createTemporaryReference(value, clientToken) {\n        if (isPrimitiveValue(value)) {\n            return {\n                dispose() { },\n            };\n        }\n        const storedReference = this._objectInfo.owner.trackInternal(value).addReference(clientToken);\n        let tempRefs = this._temporaryReferencesByClient.get(clientToken);\n        if (!tempRefs) {\n            tempRefs = [];\n            this._temporaryReferencesByClient.set(clientToken, tempRefs);\n        }\n        tempRefs.push(storedReference);\n        return storedReference;\n    }\n    onInstanceSet(createdByCreateObjectMessage) {\n        super.onInstanceSet(createdByCreateObjectMessage);\n        const metaInfo = ensureObjectSyncMetaInfo(this.instance);\n        metaInfo?.on(\"propertyChanged\", (propertyInfo, instance, propertyKey, value) => {\n            this.reportPropertyChanged(propertyInfo, propertyKey, value);\n        });\n        if (createdByCreateObjectMessage)\n            return;\n        this._typeInfo = getTrackableTypeInfo(this.instance.constructor);\n        this._typeInfo.trackedProperties.forEach((propertyInfo, key) => {\n            this.reportPropertyChanged(propertyInfo, key, this.instance[key]);\n        });\n    }\n    async onCreateMessageReceived(message, clientToken) {\n        const constructorArguments = (message.data[\"[[constructor]]\"] ?? []).map((arg) => {\n            return this.deserializeValue(arg, clientToken);\n        });\n        this.instance = new this.type(...constructorArguments);\n        await this.onChangeMessageReceived(message, clientToken);\n        this._properties.forEach((propertyValueInfo, propertyKey) => {\n            propertyValueInfo.hasPendingChanges = false;\n        });\n    }\n    onChangeMessageReceived(message, clientToken) {\n        for (const key of Object.keys(message.data)) {\n            if (!checkCanApplyProperty(this.instance.constructor, this.instance, key, false, clientToken))\n                continue;\n            const value = this.deserializeValue(message.data[key], clientToken);\n            const property = this._properties.get(key);\n            try {\n                if (property)\n                    property.isBeeingApplied = true;\n                this.instance[key] = value;\n            }\n            finally {\n                if (property)\n                    property.isBeeingApplied = false;\n            }\n        }\n    }\n    async onExecuteMessageReceived(message, clientToken) {\n        if (typeof this.instance[message.method] !== \"function\") {\n            throw new Error(`Target with id ${message.objectId} has no method ${message.method}`);\n        }\n        const finishInvoke = (result, error) => {\n            let methodInvokeResults = this._methodInvokeResultsByClient.get(clientToken);\n            if (!methodInvokeResults) {\n                methodInvokeResults = [];\n                this._methodInvokeResultsByClient.set(clientToken, methodInvokeResults);\n            }\n            if (error)\n                methodInvokeResults.push({ objectId: message.objectId, invokeId: message.id, error });\n            else\n                methodInvokeResults.push({ objectId: message.objectId, invokeId: message.id, result });\n            this.reportPendingMessages();\n        };\n        if (!checkCanApplyProperty(this.instance.constructor, this.instance, message.method, true, clientToken)) {\n            finishInvoke(null, \"Not allowed.\");\n            return;\n        }\n        const parameters = message.parameters.map((value) => {\n            return this.deserializeValue(value, clientToken);\n        });\n        let resultOrPromise;\n        try {\n            resultOrPromise = this.instance[message.method](...parameters);\n        }\n        catch (e) {\n            finishInvoke(null, e);\n            return;\n        }\n        if (isPromiseLike(resultOrPromise)) {\n            const promise = resultOrPromise.then((result) => {\n                finishInvoke(result, null);\n            }, (error) => {\n                finishInvoke(null, error);\n            });\n            const promiseHandlingType = getSyncMethodInfo(this.instance.constructor, message.method)?.promiseHandlingType ?? \"normal\";\n            if (promiseHandlingType === \"await\")\n                await promise;\n        }\n        else {\n            finishInvoke(resultOrPromise, null);\n        }\n    }\n    onExecuteFinishedMessageReceived(message, clientToken) {\n        const pendingCall = this._pendingInvokeMethodInfosById.get(message.invokeId);\n        if (!pendingCall)\n            return;\n        const clientPromiseInfo = pendingCall.invokeMethodInfoByClient.get(clientToken);\n        if (!clientPromiseInfo)\n            return;\n        if (\"error\" in message) {\n            clientPromiseInfo.reject(message.error);\n        }\n        else {\n            clientPromiseInfo.resolve(message.result);\n        }\n    }\n    generateCreateMessage(typeId, clientToken) {\n        const data = {};\n        const propertiesToOmit = new Set();\n        if (this._typeInfo.constructorArguments !== undefined) {\n            const constructorArgumentsResult = typeof this._typeInfo.constructorArguments === \"function\"\n                ? this._typeInfo.constructorArguments.call(this.instance, { instance: this.instance, constructor: this.type, typeId, destinationClientConnection: clientToken })\n                : this._typeInfo.constructorArguments;\n            const finalConstructorArguments = (data[\"[[constructor]]\"] = []);\n            if (Array.isArray(constructorArgumentsResult)) {\n                constructorArgumentsResult.forEach((propertyKey) => {\n                    propertiesToOmit.add(propertyKey);\n                    const propertyValueInfo = this._properties.get(propertyKey);\n                    if (!propertyValueInfo) {\n                        throw new Error(`Cannot use property '${propertyKey}' as constructor argument for type '${this.typeId}' because it is not a tracked property.`);\n                    }\n                    const value = propertyValueInfo.value;\n                    const finalValue = beforeSendPropertyToClient(this.instance.constructor, this.instance, propertyKey, value, clientToken);\n                    if (finalValue === nothing) {\n                        this.storeReference(undefined, propertyKey, clientToken);\n                        return;\n                    }\n                    this.storeReference(finalValue, propertyKey, clientToken);\n                    finalConstructorArguments.push(this.serializeValue(finalValue, clientToken));\n                });\n            }\n            else {\n                if (constructorArgumentsResult.propertiesToOmit) {\n                    for (const prop of constructorArgumentsResult.propertiesToOmit) {\n                        propertiesToOmit.add(prop);\n                    }\n                }\n                constructorArgumentsResult.arguments.forEach((argument) => {\n                    const transformedValue = this.serializeValue(argument, clientToken);\n                    finalConstructorArguments.push(transformedValue);\n                });\n            }\n        }\n        this._properties.forEach((propertyValueInfo, propertyKey) => {\n            if (propertiesToOmit.has(propertyKey))\n                return;\n            const value = propertyValueInfo.value;\n            const finalValue = beforeSendPropertyToClient(this.instance.constructor, this.instance, propertyKey, value, clientToken);\n            if (finalValue === nothing) {\n                this.storeReference(undefined, propertyKey, clientToken);\n                return;\n            }\n            this.storeReference(finalValue, propertyKey, clientToken);\n            const transformedValue = this.serializeValue(finalValue, clientToken);\n            data[propertyKey] = transformedValue;\n        });\n        const createMessage = {\n            type: \"create\",\n            objectId: this.objectId,\n            typeId,\n            data,\n        };\n        return createMessage;\n    }\n    generateChangeMessage(clientToken) {\n        const data = {};\n        let hasDataToSend = false;\n        this._properties.forEach((propertyValueInfo, propertyKey) => {\n            if (!propertyValueInfo.hasPendingChanges)\n                return;\n            const value = propertyValueInfo.value;\n            const finalValue = beforeSendPropertyToClient(this.instance.constructor, this.instance, propertyKey, value, clientToken);\n            if (finalValue === nothing) {\n                this.storeReference(undefined, propertyKey, clientToken);\n                return;\n            }\n            this.storeReference(finalValue, propertyKey, clientToken);\n            const transformedValue = this.serializeValue(finalValue, clientToken);\n            data[propertyKey] = transformedValue;\n            hasDataToSend = true;\n        });\n        if (!hasDataToSend)\n            return null;\n        const changeMessage = {\n            type: \"change\",\n            objectId: this.objectId,\n            data,\n        };\n        return changeMessage;\n    }\n    generateMessages(clientToken, isNewClientConnection) {\n        const result = [];\n        if (isNewClientConnection || this.hasPendingChanges) {\n            let typeId = this.getTypeId(clientToken);\n            if (typeId === null) {\n                return result;\n            }\n            if (isNewClientConnection)\n                result.push(this.generateCreateMessage(typeId, clientToken));\n            else {\n                const changeMessage = this.generateChangeMessage(clientToken);\n                if (changeMessage)\n                    result.push(changeMessage);\n            }\n        }\n        this.generateExecuteMessages(clientToken, result);\n        this.generateExecuteResultMessages(clientToken, result);\n        return result;\n    }\n    generateExecuteResultMessages(clientToken, result) {\n        const methodInvokeResults = this._methodInvokeResultsByClient.get(clientToken);\n        if (methodInvokeResults) {\n            this._methodInvokeResultsByClient.delete(clientToken);\n            for (const methodInvokeResult of methodInvokeResults ?? []) {\n                const executeFinishedMessage = {\n                    type: \"executeFinished\",\n                    objectId: methodInvokeResult.objectId,\n                    invokeId: methodInvokeResult.invokeId,\n                };\n                if (\"result\" in methodInvokeResult) {\n                    this.createTemporaryReference(methodInvokeResult.result, clientToken);\n                    executeFinishedMessage.result = this.serializeValue(methodInvokeResult.result, clientToken);\n                }\n                if (\"error\" in methodInvokeResult) {\n                    this.createTemporaryReference(methodInvokeResult.error, clientToken);\n                    executeFinishedMessage.error = this.serializeValue(methodInvokeResult.error, clientToken);\n                }\n                result.push(executeFinishedMessage);\n            }\n        }\n    }\n    generateExecuteMessages(clientToken, result) {\n        for (const pendingInvokeMethodInfos of this._pendingInvokeMethodInfosById.values()) {\n            const clientInvokeInfo = pendingInvokeMethodInfos.invokeMethodInfoByClient.get(clientToken);\n            if (!clientInvokeInfo || clientInvokeInfo.sentToClient)\n                continue;\n            clientInvokeInfo.sentToClient = true;\n            const args = pendingInvokeMethodInfos.parameters.slice();\n            if (beforeExecuteOnClient(this.instance.constructor, this.instance, pendingInvokeMethodInfos.methodName, args, clientToken) === false) {\n                clientInvokeInfo.reject(\"Not allowed to invoke method.\");\n                continue;\n            }\n            const parameters = args.map((arg) => {\n                this.createTemporaryReference(arg, clientToken);\n                const transformedValue = this.serializeValue(arg, clientToken);\n                return transformedValue;\n            });\n            const executeMessage = {\n                id: pendingInvokeMethodInfos.id,\n                type: \"execute\",\n                objectId: this.objectId,\n                method: pendingInvokeMethodInfos.methodName,\n                parameters,\n            };\n            result.push(executeMessage);\n        }\n    }\n    getTypeId(clientToken) {\n        const typeIdOrNothing = beforeSendObjectToClient(this.type, this.instance, this.typeId, clientToken);\n        if (typeIdOrNothing === nothing)\n            return null;\n        return typeIdOrNothing;\n    }\n    reportPropertyChanged(propertyInfo, key, value) {\n        if (!this.checkCanTrackPropertyInfo(propertyInfo, this.instance, key))\n            return;\n        let current = this._properties.get(key);\n        if (!current) {\n            current = {\n                hasPendingChanges: true,\n                value: undefined,\n                propertyInfo,\n                isBeeingApplied: false,\n            };\n            this._properties.set(key, current);\n            this.hasPendingChanges = true;\n        }\n        if (current.value === value)\n            return;\n        this.clearAllStoredReferencesWithKey(key);\n        current.value = value;\n        if (current.isBeeingApplied)\n            return;\n        current.hasPendingChanges = true;\n        this.hasPendingChanges = true;\n    }\n    clearStates(clientToken) {\n        super.clearStates(clientToken);\n        if (clientToken) {\n            this._methodInvokeResultsByClient.delete(clientToken);\n            const tempRefs = this._temporaryReferencesByClient.get(clientToken);\n            if (tempRefs) {\n                for (const storedReference of tempRefs) {\n                    storedReference.dispose();\n                }\n                this._temporaryReferencesByClient.delete(clientToken);\n            }\n        }\n        else {\n            this._properties.forEach((property) => {\n                property.hasPendingChanges = false;\n            });\n        }\n    }\n    checkCanTrackPropertyInfo(propertyInfo, instance, propertyKey) {\n        if (!propertyInfo) {\n            return false;\n        }\n        if (propertyInfo.canTrack?.call(instance, { instance, key: propertyKey }) === false) {\n            return false;\n        }\n        return true;\n    }\n    get dispatcher() {\n        return (this._dispatcher ??= this.createDispatcher());\n    }\n    createDispatcher() {\n        const result = {\n            invoke: (clientOrClientsOrMethodName, ...args) => {\n                if (typeof clientOrClientsOrMethodName === \"string\") {\n                    const methodName = clientOrClientsOrMethodName;\n                    return this.invokeMethodForClients(undefined, methodName, ...args);\n                }\n                else {\n                    const clientOrClients = clientOrClientsOrMethodName;\n                    const methodName = args.shift();\n                    const result = this.invokeMethodForClients(clientOrClients, methodName, ...args);\n                    if (isIterable(clientOrClients)) {\n                        return result;\n                    }\n                    else {\n                        const client = clientOrClients;\n                        return result.get(client);\n                    }\n                }\n            },\n        };\n        return result;\n    }\n    invokeMethodForClients(clientOrClients, methodName, ...parameters) {\n        const clients = clientOrClients ?? this._objectInfo.owner.registeredClientTokens;\n        const methodInfo = this._typeInfo.trackedMethods.get(methodName);\n        const resultByClient = new Map();\n        if (!this.checkCanTrackPropertyInfo(methodInfo, this.instance, methodName)) {\n            forEachIterable(clients, (c) => {\n                resultByClient.set(c, Promise.reject(new Error(`Not allowed to invoke method ${methodName} on object ${this.objectId}.`)));\n            });\n            return resultByClient;\n        }\n        const id = this._nextInvokeId++;\n        const promiseDataByClient = new Map();\n        const invokeMethodInfo = {\n            id,\n            methodName: methodName,\n            parameters,\n            invokeMethodInfoByClient: promiseDataByClient,\n        };\n        forEachIterable(clients, (clientToken) => {\n            let resolve;\n            let reject;\n            const promise = new Promise((res, rej) => {\n                resolve = (data) => {\n                    res(this.deserializeValue(data, clientToken));\n                };\n                reject = (data) => {\n                    rej(this.deserializeValue(data, clientToken));\n                };\n            });\n            promise.finally(() => {\n                invokeMethodInfo.invokeMethodInfoByClient.delete(clientToken);\n                if (invokeMethodInfo.invokeMethodInfoByClient.size === 0) {\n                    this._pendingInvokeMethodInfosById.delete(id);\n                }\n            });\n            resultByClient.set(clientToken, promise);\n            promiseDataByClient.set(clientToken, {\n                resolve: resolve,\n                reject: reject,\n                sentToClient: false,\n            });\n        });\n        this._pendingInvokeMethodInfosById.set(invokeMethodInfo.id, invokeMethodInfo);\n        this.reportPendingMessages();\n        return resultByClient;\n    }\n}\n", "import { getTrackableTypeInfo } from \"../../../decorators/syncObject.js\";\nimport { SyncObjectSerializer } from \"./serializer.js\";\nconst serializersByType = new Map();\nexport function getSyncObjectSerializer(type) {\n    if (serializersByType.has(type)) {\n        return serializersByType.get(type);\n    }\n    const typeId = getTrackableTypeInfo(type).typeId;\n    const TypedSyncObjectSerializer = class TypedSyncObjectSerializer extends SyncObjectSerializer {\n        static canSerialize(instanceOrTypeId) {\n            if (typeof instanceOrTypeId === \"string\") {\n                return instanceOrTypeId === typeId;\n            }\n            return instanceOrTypeId.constructor === type;\n        }\n        get type() {\n            return type;\n        }\n        get typeId() {\n            return typeId;\n        }\n        constructor(objectInfo) {\n            super(objectInfo);\n        }\n    };\n    serializersByType.set(type, TypedSyncObjectSerializer);\n    return TypedSyncObjectSerializer;\n}\n", "export class ObjectReference {\n    objectId;\n    typeId;\n    static from(objectInfo, clientToken) {\n        const typeId = objectInfo.serializer.getTypeId(clientToken);\n        if (typeId === undefined || typeId === null) {\n            return undefined;\n        }\n        return new ObjectReference(objectInfo.objectId, typeId);\n    }\n    constructor(objectId, typeId) {\n        this.objectId = objectId;\n        this.typeId = typeId;\n    }\n}\n", "export class PrimitiveValue {\n    value;\n    constructor(value) {\n        this.value = value;\n    }\n}\n", "import { allSyncObjectTypes } from \"../decorators/syncObject.js\";\nimport { isCreateObjectMessage, isDeleteObjectMessage } from \"../shared/messages.js\";\nimport { ObjectInfo } from \"../shared/objectInfo.js\";\nimport { ObjectPool } from \"../shared/objectPool.js\";\nimport { forEachIterable, isIterable, isPrimitiveValue } from \"../shared/types.js\";\nimport { defaultIntrinsicSerializers } from \"../serialization/serializers/base.js\";\nimport { getSyncObjectSerializer } from \"../serialization/serializers/syncObject/index.js\";\nimport { ObjectReference } from \"./objectReference.js\";\nimport { PrimitiveValue } from \"./primitiveValue.js\";\nexport class ObjectSync {\n    _objectPool = new ObjectPool();\n    _objectsWithPendingMessages = new Set();\n    _clients = new Set();\n    _settings;\n    _nextObjectId = 1;\n    _pendingCreateMessageByObjectId = new Map();\n    _ownClientConnection;\n    constructor(settings) {\n        this._settings = {\n            identity: settings.identity,\n            serializers: (settings.serializers ?? Array.from(allSyncObjectTypes)).map((ctor) => {\n                if (\"canSerialize\" in ctor)\n                    return ctor;\n                return getSyncObjectSerializer(ctor);\n            }),\n            intrinsicSerializers: settings.intrinsicSerializers ?? defaultIntrinsicSerializers,\n            objectIdGeneratorSettings: settings.objectIdGeneratorSettings ?? {\n                prefix: settings.identity,\n            },\n            arrayChangeSetMode: settings.arrayChangeSetMode ?? \"compareStates\",\n        };\n        this._ownClientConnection = this.registerClient({ identity: settings.identity });\n    }\n    get arrayChangeSetMode() {\n        return this._settings.arrayChangeSetMode;\n    }\n    reportPendingMessagesForObject(objectInfo) {\n        if (!objectInfo.instance)\n            return;\n        this._objectsWithPendingMessages.add(objectInfo.instance);\n    }\n    generateObjectId(value) {\n        if (\"generateId\" in this._settings.objectIdGeneratorSettings) {\n            return this._settings.objectIdGeneratorSettings.generateId(value);\n        }\n        else {\n            return `${this._settings.objectIdGeneratorSettings.prefix}-${this._nextObjectId++}`;\n        }\n    }\n    registerClient(settings) {\n        const clientToken = JSON.parse(JSON.stringify(settings));\n        this._clients.add(clientToken);\n        return clientToken;\n    }\n    get registeredClientTokens() {\n        return Array.from(this._clients).filter((c) => c !== this._ownClientConnection);\n    }\n    removeClient(clientToken) {\n        if (!this._clients.has(clientToken)) {\n            throw new Error(\"Unknown client token\");\n        }\n        this._objectPool.infos.forEach((info) => {\n            info.serializer.onClientConnectionRemoved(clientToken);\n        });\n        this._clients.delete(clientToken);\n    }\n    get identity() {\n        return this._settings.identity;\n    }\n    get allTrackedObjects() {\n        return this._objectPool.objects;\n    }\n    setClientRestriction(obj, filter) {\n        const info = this._objectPool.getInfoByObject(obj);\n        if (!info)\n            throw new Error(\"Object is not tracked\");\n        info.setClientRestriction(filter);\n    }\n    track(instance, objectId) {\n        const info = this.trackInternal(instance, objectId);\n        if (!info) {\n            throw new Error(\"Cannot track primitive value as root.\");\n        }\n        info.isRoot = true;\n        info.serializer.clients.add(this._ownClientConnection);\n    }\n    trackInternal(instance, objectId) {\n        if (isPrimitiveValue(instance))\n            return null;\n        let info = this._objectPool.getInfoByObject(instance);\n        if (info) {\n            return info;\n        }\n        if (objectId !== undefined) {\n            info = this._objectPool.getInfoById(objectId);\n            if (info) {\n                this._objectPool.onObjectSet(info);\n                return info;\n            }\n        }\n        info = new ObjectInfo(this, objectId, instance);\n        info.isOwned = true;\n        this._objectPool.add(info);\n        info.initializeSerializer(instance);\n        return info;\n    }\n    untrack(instance) {\n        const info = this._objectPool.getInfoByObject(instance);\n        if (!info || !info.isRoot)\n            return false;\n        info.isRoot = false;\n        return true;\n    }\n    reportInstanceCreated(instance, objectId) {\n        this.trackInternal(instance, objectId);\n    }\n    findSerializer(instanceOrTypeId) {\n        const serializer = this._settings.serializers.find((s) => s.canSerialize(instanceOrTypeId)) ?? this._settings.intrinsicSerializers.find((s) => s.canSerialize(instanceOrTypeId));\n        if (!serializer)\n            throw new Error(`No serializer found for value of type ${typeof instanceOrTypeId === \"string\" ? instanceOrTypeId : instanceOrTypeId.constructor.name}`);\n        return serializer;\n    }\n    handleCreateMessage(message, clientToken) {\n        this._pendingCreateMessageByObjectId.delete(message.objectId);\n        const info = new ObjectInfo(this, message.objectId, message.typeId);\n        this._objectPool.add(info);\n        info.initializeSerializer(message.typeId);\n        info.serializer.clients.add(clientToken);\n        info.serializer.applyMessage(message, clientToken);\n    }\n    async handleOtherMessage(message, clientToken) {\n        const info = this._objectPool.getInfoById(message.objectId);\n        if (!info)\n            return;\n        await info.serializer.applyMessage(message, clientToken);\n    }\n    async handleDeleteMessage(message, clientToken) {\n        const info = this._objectPool.getInfoById(message.objectId);\n        if (!info)\n            return;\n        await info.serializer.applyMessage(message, clientToken);\n        this._objectPool.deleteById(message.objectId);\n    }\n    serializeValue(value, clientToken) {\n        if (isPrimitiveValue(value)) {\n            return new PrimitiveValue(value);\n        }\n        return ObjectReference.from(this.trackInternal(value), clientToken);\n    }\n    deserializeValue(value, clientToken) {\n        if (value === undefined)\n            return undefined;\n        if (!(\"objectId\" in value)) {\n            return value.value;\n        }\n        const objectId = value.objectId;\n        let instance = this._objectPool.getObjectById(objectId);\n        if (instance)\n            return instance;\n        const createMessage = this._pendingCreateMessageByObjectId.get(objectId);\n        if (!createMessage)\n            throw new Error(`Object with id ${objectId} not found`);\n        this.handleCreateMessage(createMessage, clientToken);\n        instance = this._objectPool.getObjectById(objectId);\n        if (!instance)\n            throw new Error(`Object with id ${objectId} not found after processing create message`);\n        return instance;\n    }\n    async applyMessagesAsync(messagesOrMessagesByClient, clientToken) {\n        if (messagesOrMessagesByClient instanceof Map) {\n            for (const [clientToken, messages] of messagesOrMessagesByClient) {\n                await this.applyMessagesAsync(messages, clientToken);\n            }\n            return;\n        }\n        let messages = messagesOrMessagesByClient;\n        if (this._clients.has(clientToken) === false) {\n            throw new Error(\"Unknown client token received messages from.\");\n        }\n        messages.sort((a, b) => {\n            if (a.type === b.type)\n                return 0;\n            if (a.type === \"create\")\n                return -1;\n            if (b.type === \"create\")\n                return 1;\n            if (a.type === \"change\")\n                return -1;\n            if (b.type === \"change\")\n                return 1;\n            if (a.type === \"execute\")\n                return -1;\n            if (b.type === \"execute\")\n                return 1;\n            if (a.type === \"delete\")\n                return 1;\n            if (b.type === \"delete\")\n                return -1;\n            return 0;\n        });\n        const creationMessages = messages.filter(isCreateObjectMessage);\n        messages = messages.filter((m) => !isCreateObjectMessage(m));\n        for (const creationMessage of creationMessages) {\n            this._pendingCreateMessageByObjectId.set(creationMessage.objectId, creationMessage);\n        }\n        while (this._pendingCreateMessageByObjectId.size > 0) {\n            const creationMessage = this._pendingCreateMessageByObjectId.values().next().value;\n            this.handleCreateMessage(creationMessage, clientToken);\n        }\n        for (const message of messages) {\n            if (isDeleteObjectMessage(message))\n                await this.handleDeleteMessage(message, clientToken);\n            else\n                await this.handleOtherMessage(message, clientToken);\n        }\n    }\n    clearStates() {\n        this._objectPool.infos.forEach((info) => {\n            info.serializer.clearStates();\n        });\n        this._objectsWithPendingMessages.clear();\n        this._objectPool.orphanedObjectInfos(this._ownClientConnection).forEach((info) => {\n            this._objectPool.deleteByObject(info.instance);\n        });\n    }\n    getMessages(clientOrClientsOrCallTick, clearNonClientStates = true) {\n        let result;\n        let clientTokens;\n        if (typeof clientOrClientsOrCallTick === \"boolean\" || clientOrClientsOrCallTick === undefined) {\n            clientTokens = undefined;\n            clearNonClientStates = clientOrClientsOrCallTick ?? true;\n        }\n        else if (!isIterable(clientOrClientsOrCallTick)) {\n            clientTokens = clientOrClientsOrCallTick;\n        }\n        result = this.getMessagesForClients(clientTokens ?? this._clients, clearNonClientStates);\n        if (clientTokens === undefined || isIterable(clientTokens))\n            return result;\n        return result.get(clientTokens);\n    }\n    getMessagesForClients(clientOrClientTokens, clearNonClientStates) {\n        const resultByClient = new Map();\n        forEachIterable(clientOrClientTokens, (clientToken) => {\n            if (clientToken === this._ownClientConnection)\n                return;\n            const generatedMessages = [];\n            const serializersWhichsStatesNeedsToBeCleared = new Set();\n            for (const instance of this._objectsWithPendingMessages) {\n                const objectInfo = this.trackInternal(instance);\n                if (!objectInfo.isForClientToken(clientToken))\n                    continue;\n                serializersWhichsStatesNeedsToBeCleared.add(objectInfo.serializer);\n                const isNewInstance = objectInfo.serializer.clients.has(clientToken) === false;\n                if (isNewInstance) {\n                    objectInfo.serializer.clients.add(clientToken);\n                }\n                const messages = objectInfo.serializer.generateMessages(clientToken, isNewInstance);\n                generatedMessages.push(...messages);\n            }\n            for (const serializer of serializersWhichsStatesNeedsToBeCleared) {\n                serializer.clearStates(clientToken);\n            }\n            while (true) {\n                const noLongerTrackedByClient = this._objectPool.objectInfosToDelete(clientToken);\n                if (noLongerTrackedByClient.length === 0) {\n                    break;\n                }\n                for (const objectInfo of noLongerTrackedByClient) {\n                    objectInfo.serializer.onClientConnectionRemoved(clientToken);\n                    generatedMessages.push({\n                        type: \"delete\",\n                        objectId: objectInfo.objectId,\n                    });\n                }\n            }\n            resultByClient.set(clientToken, generatedMessages);\n        });\n        if (clearNonClientStates)\n            this.clearStates();\n        return resultByClient;\n    }\n    findOne(constructorOrObjectId, objectId) {\n        if (typeof constructorOrObjectId === \"string\") {\n            return this._objectPool.getObjectById(constructorOrObjectId);\n        }\n        return this._objectPool.findOne(constructorOrObjectId, objectId);\n    }\n    findAll(constructor) {\n        return this._objectPool.findAll(constructor);\n    }\n    async exchangeMessagesAsync(settings) {\n        const messages = settings.clients ? this.getMessages(settings.clients) : this.getMessages();\n        if (settings.clientMessageFilter) {\n            for (const [clientToken, clientMessages] of messages) {\n                const filteredMessages = clientMessages.filter((message) => settings.clientMessageFilter(clientToken, message, false));\n                messages.set(clientToken, filteredMessages);\n            }\n        }\n        let responseMessagesByClient;\n        if (\"sendToClientAsync\" in settings) {\n            responseMessagesByClient = new Map();\n            for (const [clientToken, clientMessages] of messages) {\n                const responseMessagesFromClient = settings.sendToClientAsync(clientToken, clientMessages);\n                responseMessagesByClient.set(clientToken, responseMessagesFromClient);\n            }\n            await Promise.allSettled(responseMessagesByClient.values());\n        }\n        else {\n            responseMessagesByClient = await settings.sendToClientsAsync(messages);\n        }\n        for (const [clientToken, resultsPromise] of responseMessagesByClient) {\n            try {\n                let messagesFromClient = await resultsPromise;\n                if (settings.clientMessageFilter) {\n                    messagesFromClient = messagesFromClient.filter((message) => settings.clientMessageFilter(clientToken, message, true));\n                }\n                await this.applyMessagesAsync(messagesFromClient, clientToken);\n            }\n            catch (error) {\n                settings.errorHandler?.(clientToken, error);\n            }\n        }\n    }\n    getDispatcher(instance) {\n        const info = this._objectPool.getInfoByObject(instance);\n        if (!info)\n            throw new Error(\"Object is not tracked\");\n        const dispatcher = info.serializer.dispatcher;\n        if (!dispatcher) {\n            return null;\n        }\n        return dispatcher;\n    }\n}\n", "import { ObjectSync } from \"./objectSync.js\";\nexport function serializeValue(value, settings) {\n    let isPrimitive = false;\n    if (typeof value !== \"object\") {\n        value = { value };\n        isPrimitive = true;\n    }\n    const hostSync = new ObjectSync({ ...settings, identity: settings?.identity ?? \"host\" });\n    hostSync.track(value, isPrimitive ? \"value\" : \"root\");\n    const clientToken = hostSync.registerClient({ identity: settings?.clientIdentity ?? \"client\" });\n    const messages = hostSync.getMessages(clientToken);\n    return JSON.stringify(messages);\n}\nexport function deserializeValue(data, settings) {\n    const hostSync = new ObjectSync({ ...settings, identity: settings?.clientIdentity ?? \"client\" });\n    const clientToken = hostSync.registerClient({ identity: settings?.identity ?? \"host\" });\n    const messages = JSON.parse(data);\n    hostSync.applyMessagesAsync(messages, clientToken);\n    const root = hostSync.findOne(\"root\");\n    if (root)\n        return root;\n    const primitive = hostSync.findOne(\"value\");\n    if (primitive)\n        return primitive.value;\n    throw new Error(\"Deserialized data does not contain a root or primitive value\");\n}\nexport async function deserializeValueAsync(data, settings) {\n    const hostSync = new ObjectSync({ ...settings, identity: settings?.clientIdentity ?? \"client\" });\n    const clientToken = hostSync.registerClient({ identity: settings?.identity ?? \"host\" });\n    const messages = JSON.parse(data);\n    await hostSync.applyMessagesAsync(messages, clientToken);\n    const root = hostSync.findOne(\"root\");\n    if (root)\n        return root;\n    const primitive = hostSync.findOne(\"value\");\n    if (primitive)\n        return primitive.value;\n    throw new Error(\"Deserialized data does not contain a root or primitive value\");\n}\n", "import { EventEmitter } from \"../../../shared/eventEmitter.js\";\nimport { SyncableArray } from \"./syncArray.js\";\nclass SyncArrayMetaInfo extends EventEmitter {\n    reportArrayChanged(instance, change) {\n        this.emit(\"addChange\", instance, change);\n    }\n}\nconst metaInfoBySyncArray = new WeakMap();\nexport function ensureSyncArrayMetaInfo(instance) {\n    if (!(instance instanceof SyncableArray))\n        return undefined;\n    let metaInfo = getSyncArrayMetaInfo(instance);\n    if (!metaInfo) {\n        metaInfo = new SyncArrayMetaInfo();\n        metaInfoBySyncArray.set(instance, metaInfo);\n    }\n    return metaInfo;\n}\nexport function getSyncArrayMetaInfo(instance) {\n    return metaInfoBySyncArray.get(instance) ?? null;\n}\n", "import { getSyncArrayMetaInfo } from \"./metaInfo.js\";\nconst realInstanceSymbol = Symbol(\"realInstanceSymbol\");\nconst ignoreSyncSpliceCounterByInstance = new Map();\nexport class SyncableArray extends Array {\n    constructor(...initialData) {\n        super(...initialData);\n        const that = this;\n        const proxy = new Proxy(this, {\n            get(target, prop, receiver) {\n                if (prop === realInstanceSymbol) {\n                    return that;\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n                const isIndexer = (typeof prop === \"string\" || typeof prop === \"number\") && !isNaN(Number(prop));\n                if (isIndexer)\n                    return that.setAtIndex.call(receiver, Number(prop), value);\n                if (prop === \"length\") {\n                    target.setLength.call(receiver, value);\n                    return true;\n                }\n                return Reflect.set(target, prop, value, receiver);\n            },\n        });\n        return proxy;\n    }\n    setLength(value) {\n        if (value >= 0 && !isIgnoringSpliceGathering(this)) {\n            const oldLength = this.length;\n            if (value < oldLength) {\n                const spliceInstruction = {\n                    start: value,\n                    deletedItems: this.slice(value, oldLength),\n                    items: [],\n                };\n                this.onSplice(spliceInstruction);\n            }\n            else if (value > oldLength) {\n                const spliceInstruction = {\n                    start: oldLength,\n                    deletedItems: [],\n                    items: new Array(value - oldLength).fill(undefined),\n                };\n                this.onSplice(spliceInstruction);\n            }\n        }\n        withIgnoredSyncSplice(this, () => {\n            super.length = value;\n        });\n    }\n    setAtIndex(index, value) {\n        if (index >= 0 && !isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: index,\n                deletedItems: this.slice(index, index + 1),\n                items: [value],\n            };\n            this.onSplice(spliceInstruction);\n        }\n        withIgnoredSyncSplice(this, () => {\n            super[index] = value;\n        });\n        return true;\n    }\n    splice(start, deleteCount, ...items) {\n        const actualStart = typeof start === \"number\" ? start : 0;\n        const actualDeleteCount = typeof deleteCount === \"number\" ? deleteCount : this.length - actualStart;\n        const deletedItems = super.splice(actualStart, actualDeleteCount, ...items);\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: actualStart,\n                deletedItems,\n                items,\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return deletedItems;\n    }\n    push(...items) {\n        if (!isIgnoringSpliceGathering(this)) {\n            const start = this.length;\n            const spliceInstruction = {\n                start,\n                deletedItems: [],\n                items,\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return withIgnoredSyncSplice(this, () => {\n            return super.push(...items);\n        });\n    }\n    pop() {\n        if (this.length === 0)\n            return undefined;\n        if (!isIgnoringSpliceGathering(this)) {\n            const start = this.length - 1;\n            const spliceInstruction = {\n                start,\n                deletedItems: this.slice(start, start + 1),\n                items: [],\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return withIgnoredSyncSplice(this, () => {\n            return super.pop();\n        });\n    }\n    shift() {\n        if (this.length === 0)\n            return undefined;\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: 0,\n                deletedItems: this.slice(0, 1),\n                items: [],\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return withIgnoredSyncSplice(this, () => {\n            return super.shift();\n        });\n    }\n    unshift(...items) {\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: 0,\n                deletedItems: [],\n                items,\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return withIgnoredSyncSplice(this, () => {\n            return super.unshift(...items);\n        });\n    }\n    reverse() {\n        const result = withIgnoredSyncSplice(this, () => {\n            return super.reverse();\n        });\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: 0,\n                deletedItems: this.slice(0, this.length),\n                items: [...this],\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return result;\n    }\n    sort(compareFn) {\n        const result = withIgnoredSyncSplice(this, () => {\n            return super.sort(compareFn);\n        });\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: 0,\n                deletedItems: this.slice(0, this.length),\n                items: [...this],\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return result;\n    }\n    fill(value, start, end) {\n        const actualStart = start !== undefined ? start : 0;\n        const actualEnd = end !== undefined ? end : this.length;\n        const result = withIgnoredSyncSplice(this, () => {\n            return super.fill(value, start, end);\n        });\n        var itemsFromData = this.slice(actualStart, actualEnd);\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: actualStart,\n                deletedItems: this.slice(actualStart, actualEnd),\n                items: itemsFromData,\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return result;\n    }\n    copyWithin(target, start, end) {\n        const actualEnd = end !== undefined ? end : this.length;\n        const result = withIgnoredSyncSplice(this, () => {\n            return super.copyWithin(target, start, end);\n        });\n        var itemsFromData = this.slice(target, target + (actualEnd - start));\n        if (!isIgnoringSpliceGathering(this)) {\n            const spliceInstruction = {\n                start: target,\n                deletedItems: this.slice(target, target + (actualEnd - start)),\n                items: itemsFromData,\n            };\n            this.onSplice(spliceInstruction);\n        }\n        return result;\n    }\n    onSplice(spliceInstruction) {\n        getSyncArrayMetaInfo(this)?.reportArrayChanged(this, spliceInstruction);\n    }\n}\nfunction withIgnoredSyncSplice(instance, action) {\n    const realInstance = instance[realInstanceSymbol] ?? instance;\n    const cnt = ignoreSyncSpliceCounterByInstance.get(realInstance) ?? 0;\n    ignoreSyncSpliceCounterByInstance.set(realInstance, cnt + 1);\n    try {\n        return action();\n    }\n    finally {\n        const cnt = ignoreSyncSpliceCounterByInstance.get(realInstance) ?? 1;\n        if (cnt <= 1) {\n            ignoreSyncSpliceCounterByInstance.delete(realInstance);\n        }\n        else {\n            ignoreSyncSpliceCounterByInstance.set(realInstance, cnt - 1);\n        }\n    }\n}\nfunction isIgnoringSpliceGathering(instance) {\n    const realInstance = instance[realInstanceSymbol] ?? instance;\n    const cnt = ignoreSyncSpliceCounterByInstance.get(realInstance) ?? 0;\n    return cnt > 0;\n}\n", "import { EventEmitter } from \"../../../shared/eventEmitter.js\";\nimport { SyncableArray } from \"./syncArray.js\";\nexport class SyncableObservableArray extends SyncableArray {\n    _eventEmitter = new EventEmitter();\n    onSplice(spliceInstruction) {\n        super.onSplice(spliceInstruction);\n        if (spliceInstruction.deletedItems.length > 0 && this._eventEmitter.listenerCount(\"removed\") > 0) {\n            this._eventEmitter.emit(\"removed\", spliceInstruction.deletedItems, spliceInstruction.start);\n        }\n        if (spliceInstruction.items.length > 0 && this._eventEmitter.listenerCount(\"added\") > 0) {\n            this._eventEmitter.emit(\"added\", spliceInstruction.items, spliceInstruction.start);\n        }\n    }\n    on(event, callback) {\n        this._eventEmitter.on(event, callback);\n    }\n    once(event, callback) {\n        this._eventEmitter.once(event, callback);\n    }\n    off(event, callback) {\n        this._eventEmitter.off(event, callback);\n    }\n    listenerCount(event, callback) {\n        return this._eventEmitter.listenerCount(event, callback);\n    }\n}\n", "export class Span {\n    _data;\n    end;\n    start;\n    constructor(dataOrSpan, start = 0, length) {\n        if (dataOrSpan instanceof Span) {\n            this._data = dataOrSpan._data;\n            this.start = dataOrSpan.start + start;\n            this.end = length !== undefined ? this.start + length - 1 : dataOrSpan.end;\n        }\n        else {\n            this._data = dataOrSpan;\n            this.start = start;\n            this.end = (length !== undefined ? this.start + length : dataOrSpan.length) - 1;\n        }\n        if (this.length > this._data.length) {\n            this.end = this._data.length - 1;\n        }\n    }\n    get length() {\n        return this.end - this.start + 1;\n    }\n    get(index) {\n        return this._data[this.start + index];\n    }\n    get data() {\n        return this._data.slice(this.start, this.end + 1);\n    }\n    subSpan(start, length) {\n        return new Span(this._data, this.start + start, Math.min(length, this.length - start));\n    }\n    dataFromRange(start, length) {\n        return this._data.slice(this.start + start, this.start + start + length);\n    }\n}\nexport function createChangeSet(before, after, startIndex = 0) {\n    let beforeSpan = new Span(before);\n    let afterSpan = new Span(after);\n    let start = startIndex;\n    if (beforeSpan.length === 0)\n        return [{ start, deleteCount: 0, items: afterSpan.data }];\n    if (afterSpan.length === 0)\n        return [{ start, deleteCount: beforeSpan.length, items: [] }];\n    const preprocessed = preprocessSpans(beforeSpan, afterSpan);\n    if (preprocessed.isIdentical)\n        return [];\n    const results = [];\n    while (true) {\n        const nextMatch = findMatchInIndexMaps(preprocessed.spanAndIndexMap0, preprocessed.spanAndIndexMap1);\n        if (!nextMatch)\n            break;\n        const [indexInBefore, indexInAfter, skipCount] = nextMatch;\n        if (indexInBefore === 0 && indexInAfter === 0) {\n            beforeSpan.start += skipCount;\n            afterSpan.start += skipCount;\n            start += skipCount;\n            continue;\n        }\n        results.push({ start, deleteCount: indexInBefore, items: afterSpan.dataFromRange(0, indexInAfter) });\n        afterSpan.start += indexInAfter + skipCount - 1;\n        beforeSpan.start += indexInBefore + skipCount - 1;\n        start += indexInAfter + skipCount - 1;\n    }\n    if (beforeSpan.length > 0 || afterSpan.length > 0)\n        results.push({ start, deleteCount: beforeSpan.length, items: afterSpan.data });\n    return results;\n}\nexport function applyChangeSet(array, changeSet) {\n    for (const change of changeSet) {\n        if (change.start > array.length && change.items.length > 0) {\n            array[change.start] = undefined;\n        }\n        array.splice(change.start, change.deleteCount, ...change.items);\n    }\n    return array;\n}\nfunction preprocessSpans(span0, span1) {\n    const sameLength = span0.length === span1.length;\n    let isIdentical = sameLength;\n    const indexMap0 = new Map();\n    const indexMap1 = new Map();\n    for (let inSpanIndex = 0; inSpanIndex < span0.length; inSpanIndex++) {\n        const item0 = span0.get(inSpanIndex);\n        storeSpanItemInIndexMap(span0, indexMap0, inSpanIndex, item0);\n        if (sameLength) {\n            var item1 = span1.get(inSpanIndex);\n            storeSpanItemInIndexMap(span1, indexMap1, inSpanIndex, item1);\n            if (isIdentical && item0 !== item1)\n                isIdentical = false;\n        }\n    }\n    if (isIdentical) {\n        return { isIdentical: true };\n    }\n    if (!sameLength) {\n        for (let inSpanIndex = 0; inSpanIndex < span1.length; inSpanIndex++) {\n            const item1 = span1.get(inSpanIndex);\n            storeSpanItemInIndexMap(span1, indexMap1, inSpanIndex, item1);\n        }\n    }\n    return {\n        spanAndIndexMap0: {\n            span: span0,\n            indexMap: indexMap0,\n        },\n        spanAndIndexMap1: {\n            span: span1,\n            indexMap: indexMap1,\n        },\n        isIdentical,\n    };\n}\nfunction storeSpanItemInIndexMap(span, indexMap, inSpanIndex, item) {\n    if (!indexMap.has(item))\n        indexMap.set(item, []);\n    indexMap.get(item).push(inSpanIndex + span.start);\n}\nfunction findMatchInIndexMaps(spanAndIndexMap0, spanAndIndexMap1) {\n    const threshold0 = spanAndIndexMap0.span.start;\n    const threshold1 = spanAndIndexMap1.span.start;\n    for (let i = 0; i < spanAndIndexMap0.span.length; i++) {\n        const item = spanAndIndexMap0.span.get(i);\n        const indicesInMap0 = spanAndIndexMap0.indexMap.get(item);\n        if (!indicesInMap0)\n            continue;\n        const indicesInMap1 = spanAndIndexMap1.indexMap.get(item);\n        if (!indicesInMap1)\n            continue;\n        for (const indexInMap0 of indicesInMap0) {\n            if (indexInMap0 < threshold0)\n                continue;\n            for (const indexInMap1 of indicesInMap1) {\n                if (indexInMap1 < threshold1)\n                    continue;\n                let countOfMatchingItems = 0;\n                while (indexInMap0 + countOfMatchingItems <= spanAndIndexMap0.span.end &&\n                    indexInMap1 + countOfMatchingItems <= spanAndIndexMap1.span.end &&\n                    spanAndIndexMap0.span.get(indexInMap0 + countOfMatchingItems - threshold0) === spanAndIndexMap1.span.get(indexInMap1 + countOfMatchingItems - threshold1)) {\n                    countOfMatchingItems++;\n                }\n                return [indexInMap0 - threshold0, indexInMap1 - threshold1, countOfMatchingItems];\n            }\n        }\n    }\n}\n", "import { ExtendedTypeSerializer } from \"../../serializer.js\";\nimport { defaultIntrinsicSerializers } from \"../base.js\";\nimport { ensureSyncArrayMetaInfo } from \"./metaInfo.js\";\nimport { SyncableArray } from \"./syncArray.js\";\nimport { SyncableObservableArray } from \"./syncObservableArray.js\";\nimport { applyChangeSet, createChangeSet } from \"./changeSet.js\";\nconst TYPE_ID_NATIVEARRAY = \"<nativeArray>\";\nconst TYPE_ID_SYNCARRAY = \"<syncArray>\";\nconst TYPE_ID_OBSERVABLEARRAY = \"<syncObservableArray>\";\nclass SyncArraySerializerBase extends ExtendedTypeSerializer {\n    _oldArrayContent = [];\n    _temporaryChanges = null;\n    _dispatcher;\n    _changeSetMode;\n    onInstanceSet(createdByCreateObjectMessage) {\n        super.onInstanceSet(createdByCreateObjectMessage);\n        const metaInfo = ensureSyncArrayMetaInfo(this.instance);\n        metaInfo?.on(\"addChange\", (instance, change) => {\n            this.reportSplice(change.start, change.deletedItems.length, ...change.items);\n        });\n        if (createdByCreateObjectMessage)\n            return;\n    }\n    reportSplice(start, deleteCount, ...items) {\n        this.hasPendingChanges = true;\n        if (this.changeSetMode === \"trackSplices\") {\n            if (!this._temporaryChanges)\n                this._temporaryChanges = [];\n            this._temporaryChanges.push({\n                start,\n                deleteCount,\n                items,\n            });\n        }\n        else {\n            this._temporaryChanges = null;\n        }\n    }\n    get changeSetMode() {\n        return this._changeSetMode ?? this._objectInfo.owner.arrayChangeSetMode;\n    }\n    set changeSetMode(value) {\n        this._changeSetMode = value;\n    }\n    onCreateMessageReceived(message, clientToken) {\n        if (message.typeId === TYPE_ID_SYNCARRAY)\n            this.instance = new SyncableArray();\n        else if (message.typeId === TYPE_ID_OBSERVABLEARRAY)\n            this.instance = new SyncableObservableArray();\n        else\n            this.instance = new Array();\n        this.instance.push(...message.data.map((value) => this.deserializeValue(value, clientToken)));\n    }\n    onChangeMessageReceived(message, clientToken) {\n        const deserializedSplices = message.data.map((change) => ({\n            start: change.start,\n            deleteCount: change.deleteCount,\n            items: change.items.map((item) => this.deserializeValue(item, clientToken)),\n        }));\n        applyChangeSet(this.instance, deserializedSplices);\n    }\n    generateMessages(clientToken, isNewClientConnection) {\n        const messages = [];\n        if (isNewClientConnection || this.hasPendingChanges) {\n            if (!this._temporaryChanges && this.changeSetMode === \"compareStates\") {\n                this._temporaryChanges = createChangeSet(this._oldArrayContent, this.instance);\n            }\n        }\n        if (isNewClientConnection) {\n            this.clearAllStoredReferencesWithClientConnection(clientToken);\n            this.instance.forEach((element, index) => {\n                this.storeReference(element, index, clientToken);\n            });\n            const data = [];\n            this.instance.forEach((element, index) => {\n                const mappedValue = this.serializeValue(element, clientToken);\n                data.push(mappedValue);\n            });\n            const createMessage = {\n                type: \"create\",\n                objectId: this.objectId,\n                typeId: this.getTypeId(clientToken),\n                data,\n            };\n            messages.push(createMessage);\n        }\n        else if (this.hasPendingChanges) {\n            this._temporaryChanges?.forEach((change) => {\n                for (let i = 0; i < change.deleteCount; i++)\n                    this.storeReference(undefined, change.start + i, clientToken);\n                change.items.forEach((item, itemIndex) => {\n                    this.storeReference(item, change.start + itemIndex, clientToken);\n                });\n            });\n            const data = this._temporaryChanges.map((change) => ({\n                start: change.start,\n                deleteCount: change.deleteCount,\n                items: change.items.map((item) => {\n                    const mappedValue = this.serializeValue(item, clientToken);\n                    return mappedValue;\n                }),\n            }));\n            const changeMessage = {\n                type: \"change\",\n                objectId: this.objectId,\n                data,\n            };\n            messages.push(changeMessage);\n        }\n        return messages;\n    }\n    clearStates(clientToken) {\n        super.clearStates(clientToken);\n        if (!clientToken) {\n            this._oldArrayContent = this.instance.slice();\n            this._temporaryChanges = null;\n        }\n    }\n    get dispatcher() {\n        return (this._dispatcher ??= this.createDispatcher());\n    }\n    createDispatcher() {\n        const self = this;\n        const result = {\n            reportSplice(...args) {\n                if (args.length === 0 && self.changeSetMode !== \"compareStates\") {\n                    throw new Error(\"reportSplice requires parameters when arrayChangeSetMode is not 'compareStates'.\");\n                }\n                else if (args.length !== 0 && self.changeSetMode !== \"trackSplices\") {\n                    throw new Error(\"reportSplice with parameters requires arrayChangeSetMode to be 'trackSplices'.\");\n                }\n                self.reportSplice(...args);\n            },\n            get changeSetMode() {\n                return self.changeSetMode;\n            },\n            set changeSetMode(value) {\n                self.changeSetMode = value;\n            },\n        };\n        return result;\n    }\n}\nexport class ArraySerializer extends SyncArraySerializerBase {\n    static canSerialize(instanceOrTypeId) {\n        if (typeof instanceOrTypeId === \"string\") {\n            return instanceOrTypeId === TYPE_ID_NATIVEARRAY;\n        }\n        return instanceOrTypeId instanceof Array;\n    }\n    getTypeId(clientToken) {\n        return TYPE_ID_NATIVEARRAY;\n    }\n}\nexport class SyncArraySerializer extends SyncArraySerializerBase {\n    static canSerialize(instanceOrTypeId) {\n        if (typeof instanceOrTypeId === \"string\") {\n            return instanceOrTypeId === TYPE_ID_SYNCARRAY;\n        }\n        return instanceOrTypeId instanceof SyncableArray;\n    }\n    getTypeId(clientToken) {\n        return TYPE_ID_SYNCARRAY;\n    }\n}\nexport class SyncObservableArraySerializer extends SyncArraySerializerBase {\n    static canSerialize(instanceOrTypeId) {\n        if (typeof instanceOrTypeId === \"string\") {\n            return instanceOrTypeId === TYPE_ID_OBSERVABLEARRAY;\n        }\n        return instanceOrTypeId instanceof SyncableObservableArray;\n    }\n    getTypeId(clientToken) {\n        return TYPE_ID_OBSERVABLEARRAY;\n    }\n}\ndefaultIntrinsicSerializers.push(SyncObservableArraySerializer);\ndefaultIntrinsicSerializers.push(SyncArraySerializer);\ndefaultIntrinsicSerializers.push(ArraySerializer);\n", "import { ExtendedTypeSerializer } from \"../serializer.js\";\nimport { defaultIntrinsicSerializers } from \"./base.js\";\nconst TYPE_ID = \"<set>\";\nexport class SetSerializer extends ExtendedTypeSerializer {\n    static canSerialize(instanceOrTypeId) {\n        if (typeof instanceOrTypeId === \"string\") {\n            return instanceOrTypeId === TYPE_ID;\n        }\n        return instanceOrTypeId instanceof Set;\n    }\n    constructor(objectInfo) {\n        super(objectInfo);\n        if (objectInfo.instance) {\n            objectInfo.instance.forEach((value) => this.storeReference(value));\n        }\n    }\n    getTypeId(clientToken) {\n        return TYPE_ID;\n    }\n    onCreateMessageReceived(message, clientToken) {\n        this.instance = new Set();\n        this.onChangeMessageReceived(message, clientToken);\n    }\n    onChangeMessageReceived(message, clientToken) {\n        this.instance.clear();\n        for (const value of message.data) {\n            this.instance.add(this.deserializeValue(value, clientToken));\n        }\n    }\n    generateMessages(clientToken, isNewClientConnection) {\n        if (!isNewClientConnection && !this.hasPendingChanges)\n            return [];\n        const message = {\n            type: isNewClientConnection ? \"create\" : \"change\",\n            objectId: this.objectId,\n            typeId: (isNewClientConnection ? TYPE_ID : undefined),\n            data: this.getSerializedData(clientToken),\n        };\n        return [message];\n    }\n    getSerializedData(clientToken) {\n        this.clearAllStoredReferencesWithClientConnection(clientToken);\n        const data = [];\n        let index = 0;\n        this.instance.forEach((element) => {\n            this.storeReference(element, index, clientToken);\n            const mappedValue = this.serializeValue(element, clientToken);\n            data.push(mappedValue);\n            index++;\n        });\n        return data;\n    }\n}\ndefaultIntrinsicSerializers.push(SetSerializer);\n", "import { ExtendedTypeSerializer } from \"../serializer.js\";\nimport { defaultIntrinsicSerializers } from \"./base.js\";\nconst TYPE_ID = \"<map>\";\nexport class MapSerializer extends ExtendedTypeSerializer {\n    static canSerialize(instanceOrTypeId) {\n        if (typeof instanceOrTypeId === \"string\") {\n            return instanceOrTypeId === TYPE_ID;\n        }\n        return instanceOrTypeId instanceof Map;\n    }\n    constructor(objectInfo) {\n        super(objectInfo);\n        if (objectInfo.instance) {\n            objectInfo.instance.forEach((value) => this.storeReference(value));\n        }\n    }\n    getTypeId(clientToken) {\n        return TYPE_ID;\n    }\n    onCreateMessageReceived(message, clientToken) {\n        this.instance = new Map();\n        this.onChangeMessageReceived(message, clientToken);\n    }\n    onChangeMessageReceived(message, clientToken) {\n        this.instance.clear();\n        for (const value of message.data) {\n            this.instance.set(this.deserializeValue(value.key, clientToken), this.deserializeValue(value.value, clientToken));\n        }\n    }\n    generateMessages(clientToken, isNewClientConnection) {\n        if (!isNewClientConnection && !this.hasPendingChanges)\n            return [];\n        const message = {\n            type: isNewClientConnection ? \"create\" : \"change\",\n            objectId: this.objectId,\n            typeId: (isNewClientConnection ? TYPE_ID : undefined),\n            data: this.getSerializedData(clientToken),\n        };\n        return [message];\n    }\n    getSerializedData(clientToken) {\n        this.clearAllStoredReferencesWithClientConnection(clientToken);\n        const data = [];\n        let index = 0;\n        for (const [key, value] of this.instance) {\n            this.storeReference(key, `key:${index}`, clientToken);\n            this.storeReference(value, `value:${index}`, clientToken);\n            index++;\n            const serializedKey = this.serializeValue(key, clientToken);\n            const serializedValue = this.serializeValue(value, clientToken);\n            data.push({ key: serializedKey, value: serializedValue });\n        }\n        return data;\n    }\n}\ndefaultIntrinsicSerializers.push(MapSerializer);\n", "import { ExtendedTypeSerializer } from \"../serializer.js\";\nimport { defaultIntrinsicSerializers } from \"./base.js\";\nconst TYPE_ID = \"<object>\";\nexport class ObjectSerializer extends ExtendedTypeSerializer {\n    static canSerialize(instanceOrTypeId) {\n        if (typeof instanceOrTypeId === \"string\") {\n            return instanceOrTypeId === TYPE_ID;\n        }\n        return typeof instanceOrTypeId === \"object\";\n    }\n    constructor(objectInfo) {\n        super(objectInfo);\n        if (objectInfo.instance) {\n            for (const key of Object.keys(objectInfo.instance)) {\n                const value = objectInfo.instance[key];\n                this.storeReference(value);\n            }\n        }\n    }\n    getTypeId(clientToken) {\n        return TYPE_ID;\n    }\n    onCreateMessageReceived(message, clientToken) {\n        this.instance = {};\n        this.onChangeMessageReceived(message, clientToken);\n    }\n    onChangeMessageReceived(message, clientToken) {\n        for (const key of Object.keys(message.data)) {\n            this.instance[key] = this.deserializeValue(message.data[key], clientToken);\n        }\n    }\n    generateMessages(clientToken, isNewClientConnection) {\n        if (!isNewClientConnection && !this.hasPendingChanges)\n            return [];\n        const message = {\n            type: isNewClientConnection ? \"create\" : \"change\",\n            objectId: this.objectId,\n            typeId: (isNewClientConnection ? TYPE_ID : undefined),\n            data: this.getSerializedData(clientToken),\n        };\n        return [message];\n    }\n    getSerializedData(clientToken) {\n        this.clearAllStoredReferencesWithClientConnection(clientToken);\n        const data = {};\n        for (const key of Object.keys(this.instance)) {\n            const value = this.instance[key];\n            this.storeReference(value, key, clientToken);\n            const mappedValue = this.serializeValue(value, clientToken);\n            data[key] = mappedValue;\n        }\n        return data;\n    }\n}\ndefaultIntrinsicSerializers.push(ObjectSerializer);\n"],
  "mappings": "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",
  "names": ["syncObject", "newConstructorInfo", "syncMethod", "syncProperty", "result", "clientToken", "messages", "cnt", "item1", "TYPE_ID", "TYPE_ID"]
}
