{
  "version": 3,
  "sources": ["../src/shared/decorators.ts", "../src/shared/messages.ts", "../src/shared/objectSyncMetaInfo.ts", "../src/shared/trackedObjectPool.ts", "../src/client/trackableTarget.ts", "../src/client/client.ts", "../src/shared/types.ts", "../src/host/decorators.ts", "../src/host/trackedTarget.ts", "../src/shared/syncableArray.ts", "../src/host/hostObjectInfo.ts", "../src/host/host.ts", "../src/shared/objectSync.ts"],
  "sourcesContent": ["// declare symbol to contain a symbol and metadata\r\ndeclare global {\r\n  interface SymbolConstructor {\r\n    metadata: symbol;\r\n  }\r\n}\r\n// shim Symbol.metadata\r\nSymbol.metadata ??= Symbol(\"metadata\");\r\n\r\nexport {}; // to convert file into a module\r\n", "export const isPropertyInfoSymbol = Symbol(\"isPropertyInfo\");\r\n\r\nexport type PropertyInfo<T extends object, TKey extends keyof T> = {\r\n  value?: T[TKey];\r\n  objectId?: unknown;\r\n  [isPropertyInfoSymbol]?: true;\r\n};\r\n\r\nexport type PropertyInfos<T extends object, TAdditionalPropertyInfo extends object = object> = { [K in keyof T]?: PropertyInfo<T, K> & TAdditionalPropertyInfo };\r\nexport type ResolvablePropertyInfos<T extends object> = {\r\n  deleteProperty(key: keyof T & string): void;\r\n  get deletedProperties(): (keyof T & string)[];\r\n} & {\r\n  [K in keyof T]?: T[K];\r\n};\r\n\r\nexport type MessageBase = {\r\n  type: string;\r\n  objectId: unknown;\r\n};\r\n\r\nexport type DeleteObjectMessage = MessageBase & { type: \"delete\" };\r\n\r\nexport type CreateObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {\r\n  type: \"create\";\r\n  typeId: string;\r\n  properties: PropertyInfos<T, TAdditionalPropertyInfo>;\r\n};\r\n\r\nexport type ChangeObjectMessage<T extends object, TAdditionalPropertyInfo extends object = object> = MessageBase & {\r\n  type: \"change\";\r\n  properties: PropertyInfos<T, TAdditionalPropertyInfo>;\r\n};\r\n\r\nexport type ExecuteObjectMessage<T extends object> = MessageBase & {\r\n  type: \"execute\";\r\n  id: unknown;\r\n  method: keyof T & string;\r\n  parameters: PropertyInfo<any, any>[];\r\n};\r\n\r\nexport type Message<T extends object = object, TAdditionalPropertyInfo extends object = object> =\r\n  | DeleteObjectMessage\r\n  | CreateObjectMessage<T, TAdditionalPropertyInfo>\r\n  | ChangeObjectMessage<T, TAdditionalPropertyInfo>\r\n  | ExecuteObjectMessage<T>;\r\n\r\nexport function isPropertyInfo(value: any): value is PropertyInfo<any, any> {\r\n  return isPropertyInfoSymbol in value;\r\n}\r\n\r\nexport type MethodExecuteResult = {\r\n  id: unknown;\r\n  result: any;\r\n  status: \"resolved\" | \"rejected\" | \"sync\";\r\n  error: string | null;\r\n};\r\n", "import { ClientObjectInfo } from \"../client/clientObjectInfo.js\";\r\nimport { HostObjectInfo } from \"../host/hostObjectInfo.js\";\r\n\r\nexport const objectSyncSymbol = Symbol(\"objectSync\");\r\n\r\nexport type ObjectSyncMetaInfo = {\r\n  objectId: unknown;\r\n  typeId: string;\r\n  object: object;\r\n  client?: ClientObjectInfo<any>;\r\n  host?: HostObjectInfo<any>;\r\n};\r\n\r\nexport class ObjectInfoBase {\r\n  constructor(private readonly _objectSyncMetaInfo: ObjectSyncMetaInfo) {}\r\n\r\n  get objectId(): unknown {\r\n    return this._objectSyncMetaInfo.objectId;\r\n  }\r\n\r\n  get typeId(): string {\r\n    return this._objectSyncMetaInfo.typeId;\r\n  }\r\n\r\n  get object(): object {\r\n    return this._objectSyncMetaInfo.object;\r\n  }\r\n\r\n  get objectSyncMetaInfo() {\r\n    return this._objectSyncMetaInfo;\r\n  }\r\n}\r\n\r\nexport function getObjectSyncMetaInfo(target: object): ObjectSyncMetaInfo | undefined {\r\n  if (!target || typeof target !== \"object\") return undefined;\r\n  if (typeof target === \"function\") return undefined;\r\n  // throw when the target is a constructor function\r\n  return (target as any)[objectSyncSymbol] as ObjectSyncMetaInfo | undefined;\r\n}\r\n\r\nlet nextObjectId = 1;\r\n\r\nexport function createObjectId(objectIdPrefix: string): string {\r\n  return `${objectIdPrefix}${nextObjectId++}`;\r\n}\r\n\r\nexport type ObjectSyncMetaInfoCreateSettings<T extends object = object> =\r\n  | {\r\n      object: T;\r\n      objectIdPrefix: string;\r\n      typeId?: string;\r\n      objectId?: unknown;\r\n    }\r\n  | {\r\n      object: T;\r\n      typeId: string;\r\n      objectId: unknown;\r\n    };\r\n\r\nexport function ensureObjectSyncMetaInfo(settings: ObjectSyncMetaInfoCreateSettings): ObjectSyncMetaInfo {\r\n  let metaInfo = getObjectSyncMetaInfo(settings.object);\r\n  if (metaInfo) return metaInfo;\r\n\r\n  if (!(\"objectId\" in settings) && !(\"objectIdPrefix\" in settings)) {\r\n    throw new Error(\"objectIdPrefix must be provided when objectId is provided\");\r\n  }\r\n\r\n  const typeId = settings.typeId ?? settings.object.constructor.name;\r\n  const objectId = settings.objectId ?? createObjectId((settings as any).objectIdPrefix);\r\n\r\n  metaInfo = {\r\n    objectId,\r\n    typeId,\r\n    object: settings.object,\r\n  };\r\n\r\n  (settings.object as any)[objectSyncSymbol] = metaInfo;\r\n  return metaInfo;\r\n}\r\n\r\nexport function getHostObjectInfo<T extends object>(obj: T): HostObjectInfo<T> | null {\r\n  return getObjectSyncMetaInfo(obj)?.host ?? null;\r\n}\r\n\r\nexport function getClientObjectInfo<T extends object>(obj: T): ClientObjectInfo<T> | null {\r\n  return getObjectSyncMetaInfo(obj)?.client ?? null;\r\n}\r\n", "import { ObjectSyncMetaInfo, getObjectSyncMetaInfo, createObjectId } from \"./objectSyncMetaInfo.js\";\r\n\r\nexport class TrackedObjectPool {\r\n  private _trackedObjectInfos = new Map<unknown, ObjectSyncMetaInfo>();\r\n\r\n  add(object: object) {\r\n    const metaInfo = getObjectSyncMetaInfo(object);\r\n    if (!metaInfo) throw new Error(\"Object is not trackable.\");\r\n\r\n    if (this.hasById(metaInfo?.objectId)) return;\r\n\r\n    this._trackedObjectInfos.set(metaInfo.objectId, metaInfo);\r\n  }\r\n\r\n  delete(object: object): boolean {\r\n    const metaInfo = getObjectSyncMetaInfo(object);\r\n    if (!metaInfo) return false;\r\n\r\n    return this._trackedObjectInfos.delete(metaInfo.objectId);\r\n  }\r\n\r\n  deleteById(objectId: unknown): boolean {\r\n    return this._trackedObjectInfos.delete(objectId);\r\n  }\r\n\r\n  get(objectId: unknown): object | null {\r\n    const metaInfo = this._trackedObjectInfos.get(objectId);\r\n    return metaInfo?.object ?? null;\r\n  }\r\n\r\n  has(object: object): boolean {\r\n    const metaInfo = getObjectSyncMetaInfo(object);\r\n    if (!metaInfo) return false;\r\n\r\n    return this._trackedObjectInfos.has(metaInfo.objectId);\r\n  }\r\n\r\n  hasById(objectId: unknown): boolean {\r\n    return this._trackedObjectInfos.has(objectId);\r\n  }\r\n\r\n  get allMetaInfos(): ObjectSyncMetaInfo[] {\r\n    const result: ObjectSyncMetaInfo[] = [];\r\n    this._trackedObjectInfos.forEach((info) => result.push(info));\r\n    return result;\r\n  }\r\n\r\n  get all(): object[] {\r\n    const result: object[] = [];\r\n    this._trackedObjectInfos.forEach((info) => result.push(info.object));\r\n    return result;\r\n  }\r\n}\r\n", "import { ChangeObjectMessage, CreateObjectMessage } from \"../shared/messages.js\";\r\nimport { ObjectSyncClient } from \"./client.js\";\r\n\r\nexport const onCreated = Symbol(\"onCreated\");\r\nexport const onUpdated = Symbol(\"onUpdated\");\r\nexport const onUpdateProperty = Symbol(\"onUpdateProperty\");\r\nexport const onDeleted = Symbol(\"onDeleted\");\r\n\r\nexport interface ITrackableOnCreated<T extends object>  {\r\n  [onCreated](changes: CreateObjectMessage<T>): void;\r\n};\r\n\r\nexport interface ITrackableOnUpdated<T extends object> {\r\n  [onUpdated](changes: ChangeObjectMessage<T>): void;\r\n};\r\n\r\nexport interface ITrackableOnDeleted {\r\n  [onDeleted](): void;\r\n};\r\n\r\nexport interface ITrackableOnUpdateProperty<T extends object> {\r\n  [onUpdateProperty](key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectSyncClient): boolean;\r\n};\r\n\r\nfunction hasOnCreated<T extends object>(obj: any): obj is ITrackableOnCreated<T> {\r\n  return onCreated in obj;\r\n}\r\n\r\nfunction hasOnDeleted(obj: any): obj is ITrackableOnDeleted {\r\n  return onDeleted in obj;\r\n}\r\n\r\nfunction hasOnUpdated<T extends object>(obj: any): obj is ITrackableOnUpdated<T> {\r\n  return onUpdated in obj;\r\n}\r\n\r\nfunction hasOnUpdateProperty<T extends object>(obj: any): obj is ITrackableOnUpdateProperty<T> {\r\n  return onUpdateProperty in obj;\r\n}\r\n\r\nexport function invokeOnCreated<T extends object>(obj: T, changes: CreateObjectMessage<T>) {\r\n  if (hasOnCreated<T>(obj)) {\r\n    obj[onCreated](changes);\r\n  }\r\n}\r\n\r\nexport function invokeOnUpdated<T extends object>(obj: T, changes: ChangeObjectMessage<T>) {\r\n  if (hasOnUpdated<T>(obj)) {\r\n    obj[onUpdated](changes);\r\n  }\r\n}\r\n\r\nexport function invokeOnDeleted<T extends object>(obj: T) {\r\n  if (hasOnDeleted(obj)) {\r\n    obj[onDeleted]();\r\n  }\r\n}\r\n\r\nexport function invokeOnUpdateProperty<T extends object>(obj: T, key: keyof T, value: T[keyof T], isForCreate: boolean, client: ObjectSyncClient): boolean {\r\n  if (hasOnUpdateProperty<T>(obj)) {\r\n    return obj[onUpdateProperty](key, value, isForCreate, client);\r\n  }\r\n  return false; // not handled\r\n}", "import { checkCanUseConstructor, checkCanUseMethod, checkCanUseProperty } from \"../host/decorators.js\";\r\nimport { ChangeObjectMessage, Message, CreateObjectMessage, DeleteObjectMessage, ExecuteObjectMessage, PropertyInfos, ResolvablePropertyInfos, MethodExecuteResult } from \"../shared/messages.js\";\r\nimport { ensureObjectSyncMetaInfo, getObjectSyncMetaInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { TrackedObjectPool } from \"../shared/trackedObjectPool.js\";\r\nimport { invokeOnCreated, invokeOnDeleted, invokeOnUpdated, invokeOnUpdateProperty } from \"./trackableTarget.js\";\r\n\r\ntype Constructor<T = any> = { new (...args: any[]): T };\r\n\r\nexport type TrackableTargetGenerator<T extends object = any> = {\r\n  getType(client: ObjectSyncClient, properties: ResolvablePropertyInfos<T>, objectId: unknown, typeId: string): Constructor;\r\n  create(client: ObjectSyncClient, properties: ResolvablePropertyInfos<T>, objectId: unknown, typeId: string): T;\r\n}\r\n\r\nexport const defaultConstructorsByTypeId = new Map<string, Constructor>();\r\nexport const defaultGeneratorsByTypeId = new Map<string, TrackableTargetGenerator>();\r\n\r\nlet nextClientId = 0;\r\n\r\nexport type ObjectSyncClientSettings = {\r\n  clientId?: unknown;\r\n  objectPool?: TrackedObjectPool;\r\n  designation?: string;\r\n};\r\n\r\ntype ClientApplyResult = {\r\n  newTrackedObjects: object[];\r\n  methodExecuteResults: MethodExecuteResult[];\r\n};\r\n\r\nexport class ObjectSyncClient {\r\n  private _trackedObjectPool: TrackedObjectPool;\r\n  private _typeIdToConstructor = new Map<string, Constructor>();\r\n  private _typeIdToGenerator = new Map<string, TrackableTargetGenerator>();\r\n  private _pendingCreationMessages = new Map<unknown, CreateObjectMessage<any>>();\r\n\r\n  private _currentClientApplyResult: ClientApplyResult = { newTrackedObjects: [], methodExecuteResults: [] };\r\n\r\n  private readonly _clientId: unknown;\r\n\r\n  constructor(private readonly _settings: ObjectSyncClientSettings = {}) {\r\n    this._clientId = this._settings.clientId ?? nextClientId++;\r\n    this._trackedObjectPool = this._settings.objectPool ?? new TrackedObjectPool();\r\n\r\n    // register default constructors and generators\r\n    defaultConstructorsByTypeId.forEach((ctor, typeId) => this.registerConstructor(typeId, ctor));\r\n    defaultGeneratorsByTypeId.forEach((gen, typeId) => this.registerGenerator(typeId, gen));\r\n  }\r\n\r\n  get clientId(): unknown {\r\n    return this._clientId;\r\n  }\r\n\r\n  registerConstructorOrGenerator(typeId: string, constructorOrGenerator: Constructor | TrackableTargetGenerator): void {\r\n    if (typeof constructorOrGenerator === \"function\" && constructorOrGenerator.prototype) {\r\n      this.registerConstructor(typeId, constructorOrGenerator as Constructor);\r\n    } else {\r\n      this.registerGenerator(typeId, constructorOrGenerator as TrackableTargetGenerator);\r\n    }\r\n  }\r\n\r\n  registerConstructor(typeId: string, constructor: Constructor): void {\r\n    if (this._typeIdToConstructor.has(typeId)) {\r\n      throw new Error(`Constructor for typeId ${typeId} is already registered`);\r\n    }\r\n    this._typeIdToConstructor.set(typeId, constructor);\r\n  }\r\n\r\n  registerGenerator(typeId: string, generator: TrackableTargetGenerator): void {\r\n    if (this._typeIdToGenerator.has(typeId)) {\r\n      throw new Error(`Generator for typeId ${typeId} is already registered`);\r\n    }\r\n    this._typeIdToGenerator.set(typeId, generator);\r\n  }\r\n\r\n  apply(messages: Message<any>[]): ClientApplyResult {\r\n    // sort messages by type, first all creation messages, then update, then execute, then deletion\r\n    messages.sort((a, b) => {\r\n      if (a.type === b.type) return 0;\r\n      if (a.type === \"create\") return -1;\r\n      if (b.type === \"create\") return 1;\r\n      if (a.type === \"change\") return -1;\r\n      if (b.type === \"change\") return 1;\r\n      if (a.type === \"execute\") return -1;\r\n      if (b.type === \"execute\") return 1;\r\n      if (a.type === \"delete\") return 1;\r\n      if (b.type === \"delete\") return -1;\r\n      return 0;\r\n    });\r\n\r\n    // extract all creation messages and remove them from the main list\r\n    const creationMessages = messages.filter(isCreateObjectMessage);\r\n    messages = messages.filter((m) => !isCreateObjectMessage(m));\r\n\r\n    // Store all create messages in pending map for deferred resolution\r\n    for (const creationMessage of creationMessages) {\r\n      this._pendingCreationMessages.set(creationMessage.objectId, creationMessage);\r\n    }\r\n    while (this._pendingCreationMessages.size > 0) {\r\n      const creationMessage = this._pendingCreationMessages.values().next().value!;\r\n      this.createNewTrackedObject(creationMessage);\r\n    }\r\n\r\n    messages.forEach((message) => {\r\n      if (isChangeObjectMessage(message)) this.handleChanges(message);\r\n      else if (isDeleteObjectMessage(message)) this.deleteTrackedObject(message);\r\n      else if (isExecuteObjectMessage(message)) this.executeMethod(message);\r\n    });\r\n\r\n    const result = this._currentClientApplyResult!;\r\n    this._currentClientApplyResult = { newTrackedObjects: [], methodExecuteResults: [] };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Resolves a property value, returning the tracked object if objectId is present, or the value otherwise.\r\n   * If the object is not yet tracked, attempts to create it from pending messages.\r\n   */\r\n  getPropertyValue(property: { objectId?: unknown; value?: any }): any {\r\n    const { objectId, value } = property;\r\n    if (objectId !== undefined && objectId !== null) {\r\n      let tracked = this._trackedObjectPool.get(objectId);\r\n      if (!tracked) {\r\n        // Try to create from pending messages\r\n        const pendingMsg = this._pendingCreationMessages.get(objectId);\r\n        if (pendingMsg) {\r\n          this.createNewTrackedObject(pendingMsg);\r\n          tracked = this._trackedObjectPool.get(objectId);\r\n        }\r\n      }\r\n      if (!tracked) {\r\n        throw new Error(`Cannot find or create target with id ${objectId}`);\r\n      }\r\n      return tracked;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  findTrackedObject<T extends object>(constructor: Constructor<T>, objectId?: unknown) {\r\n    for (const tracked of this._trackedObjectPool.all) {\r\n      if (tracked instanceof constructor) {\r\n        const metaInfo = getObjectSyncMetaInfo(tracked)!;\r\n        if (objectId !== undefined && metaInfo.objectId !== objectId) continue;\r\n        return tracked;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  get allTrackedObjects(): object[] {\r\n    return Array.from(this._trackedObjectPool.all);\r\n  }\r\n\r\n  private deleteTrackedObject(data: Message<any>): void {\r\n    if (!isDeleteObjectMessage(data)) return;\r\n\r\n    if (!this._trackedObjectPool.hasById(data.objectId)) {\r\n      throw new Error(`Object with id ${data.objectId} is not being tracked`);\r\n    }\r\n\r\n    const tracked = this._trackedObjectPool.get(data.objectId)!;\r\n    this._trackedObjectPool.deleteById(data.objectId);\r\n\r\n    invokeOnDeleted(tracked);\r\n  }\r\n\r\n  private constructObject(data: CreateObjectMessage<any>) {\r\n    if (this._trackedObjectPool.hasById(data.objectId)) {\r\n      return;\r\n    }\r\n\r\n    const constructor = this._typeIdToConstructor.get(data.typeId);\r\n    let result: object;\r\n    if (constructor) {\r\n      if (!checkCanUseConstructor(constructor, this._settings.designation)) {\r\n        throw new Error(`Cannot construct ttype ${data.typeId}`);\r\n      }\r\n      result = new constructor();\r\n    } else {\r\n      const generator = this._typeIdToGenerator.get(data.typeId);\r\n      if (!generator) {\r\n        throw new Error(`No constructor or generator registered for typeId ${data.typeId}`);\r\n      }\r\n      const resolvablePropertyInfos = this.createResolvablePropertyInfos(data.properties);\r\n\r\n      const type = generator.getType(this, resolvablePropertyInfos, data.objectId, data.typeId);\r\n      if (!checkCanUseConstructor(type, this._settings.designation)) {\r\n        throw new Error(`Cannot construct ttype ${data.typeId}`);\r\n      }\r\n\r\n      result = generator.create(this, resolvablePropertyInfos, data.objectId, data.typeId);\r\n\r\n      resolvablePropertyInfos.deletedProperties.forEach((key) => {\r\n        delete (result as any)[key];\r\n      });\r\n    }\r\n\r\n    if (!result) return;\r\n\r\n    ensureObjectSyncMetaInfo({\r\n      object: result,\r\n      objectId: data.objectId,\r\n      typeId: data.typeId,\r\n    });\r\n\r\n    if (!this._trackedObjectPool.has(result)) {\r\n      this._trackedObjectPool.add(result);\r\n      this._currentClientApplyResult.newTrackedObjects.push(result);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  private createResolvablePropertyInfos<T extends object>(unresolvedProperties: PropertyInfos<T>): ResolvablePropertyInfos<T> {\r\n    const deletedProperties: Set<string> = new Set();\r\n    const properties: ResolvablePropertyInfos<any> = {\r\n      deleteProperty(key: string) {\r\n        deletedProperties.add(key);\r\n      },\r\n      get deletedProperties(): string[] {\r\n        return Array.from(deletedProperties);\r\n      },\r\n    };\r\n    Object.keys(unresolvedProperties).forEach((key) => {\r\n      const propertyInfo = unresolvedProperties[key as keyof T]!;\r\n      let resolvedValue: any = undefined;\r\n      let hasResolved = false;\r\n      Object.defineProperty(properties, key, {\r\n        get: () => {\r\n          if (!hasResolved) {\r\n            hasResolved = true;\r\n            resolvedValue = this.getPropertyValue(propertyInfo);\r\n          }\r\n          return resolvedValue;\r\n        },\r\n      });\r\n    });\r\n\r\n    return properties as ResolvablePropertyInfos<T>;\r\n  }\r\n\r\n  private createNewTrackedObject(data: Message<any>): void {\r\n    if (!isCreateObjectMessage(data)) return;\r\n    this._pendingCreationMessages.delete(data.objectId);\r\n\r\n    this.constructObject(data);\r\n    this.handleChanges(data);\r\n  }\r\n\r\n  private handleChanges(data: Message<any>): void {\r\n    const isCreate = isCreateObjectMessage(data);\r\n    const isChange = isChangeObjectMessage(data);\r\n\r\n    if (!isCreate && !isChange) return;\r\n\r\n    const tracked = this._trackedObjectPool.get(data.objectId) as any;\r\n    if (!tracked) {\r\n      throw new Error(`Cannot find target with id ${data.objectId}`);\r\n    }\r\n\r\n    Object.keys(data.properties).forEach((key) => {\r\n      if (!checkCanUseProperty(tracked.constructor as Constructor, key, this._settings.designation)) return;\r\n      const property = data.properties[key]!;\r\n      const finalValue = this.getPropertyValue(property);\r\n      if (!invokeOnUpdateProperty(tracked, key, finalValue, isCreate, this)) tracked[key] = finalValue;\r\n    });\r\n\r\n    if (isChange) invokeOnUpdated(tracked, data);\r\n    else if (isCreate) invokeOnCreated(tracked, data);\r\n  }\r\n\r\n  private executeMethod(data: Message<any>): void {\r\n    if (!isExecuteObjectMessage(data)) return;\r\n\r\n    const tracked = this._trackedObjectPool.get(data.objectId) as any;\r\n    if (!tracked) {\r\n      throw new Error(`Cannot find target with id ${data.objectId}`);\r\n    }\r\n\r\n    if (!checkCanUseMethod(tracked.constructor as Constructor, data.method, this._settings.designation)) {\r\n      this._currentClientApplyResult.methodExecuteResults.push({ id: data.id, result: null, status: \"sync\", error: \"Not allowed.\" });\r\n      return;\r\n    }\r\n\r\n    if (typeof tracked[data.method] !== \"function\") {\r\n      throw new Error(`Target with id ${data.objectId} has no method ${data.method}`);\r\n    }\r\n\r\n    const args = data.parameters.map((property) => this.getPropertyValue(property));\r\n    const result = tracked[data.method](...args);\r\n\r\n    // Store reply, handle Promise\r\n    if (result && typeof result.then === \"function\" && typeof result.catch === \"function\") {\r\n      // Promise result\r\n      result\r\n        .then((resolved: any) => {\r\n          this._currentClientApplyResult.methodExecuteResults.push({ id: data.id, result: resolved, status: \"resolved\", error: null });\r\n        })\r\n        .catch((error: any) => {\r\n          this._currentClientApplyResult.methodExecuteResults.push({ id: data.id, result: null, status: \"rejected\", error: error });\r\n        });\r\n    } else {\r\n      // Synchronous result\r\n      this._currentClientApplyResult.methodExecuteResults.push({ id: data.id, result, status: \"sync\", error: null });\r\n    }\r\n  }\r\n}\r\n\r\nfunction isDeleteObjectMessage<T extends object = any>(change: Message<T>): change is DeleteObjectMessage {\r\n  return change.type === \"delete\";\r\n}\r\n\r\nfunction isCreateObjectMessage<T extends object = any>(change: Message<T>): change is CreateObjectMessage<T> {\r\n  return change.type === \"create\";\r\n}\r\n\r\nfunction isChangeObjectMessage<T extends object = any>(change: Message<T>): change is ChangeObjectMessage<T> {\r\n  return change.type === \"change\";\r\n}\r\n\r\nfunction isExecuteObjectMessage<T extends object = any>(change: Message<T>): change is ExecuteObjectMessage<T> {\r\n  return change.type === \"execute\";\r\n}\r\n", "// Type which has only T or any iterable of T\r\nexport type OneOrMany<T> = T | Iterable<T>;\r\n\r\n// function which converts OneOrMany<T> to an iterable of T\r\nexport function toIterable<T>(input: OneOrMany<T>, preferSet = false): Iterable<T> {\r\n  if (Symbol.iterator in Object(input) && typeof input !== \"string\") {\r\n    return input as Iterable<T>;\r\n  }\r\n  return (preferSet ? new Set([input]) : [input]) as Iterable<T>;\r\n}\r\n\r\nexport function forEachIterable<T>(input: OneOrMany<T>, callback: (item: T) => void): void {\r\n  for (const item of toIterable(input)) {\r\n    callback(item);\r\n  }\r\n}\r\n\r\nexport function mapIterable<T, U>(input: OneOrMany<T>, mapper: (item: T) => U): U[] {\r\n  const result: U[] = [];\r\n  for (const item of toIterable(input)) {\r\n    result.push(mapper(item));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function filterIterable<T>(input: OneOrMany<T>, predicate: (item: T) => boolean): T[] {\r\n  const result: T[] = [];\r\n  for (const item of toIterable(input)) {\r\n    if (predicate(item)) {\r\n      result.push(item);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function findInIterable<T>(input: OneOrMany<T>, predicate: (item: T) => boolean): T | undefined {\r\n  for (const item of toIterable(input)) {\r\n    if (predicate(item)) {\r\n      return item;\r\n    }\r\n  }\r\n}\r\n\r\nexport function hasInIterable<T>(input: OneOrMany<T>, expected: T): boolean {\r\n  if (input instanceof Set) {\r\n    return input.has(expected);\r\n  }\r\n  for (const item of toIterable(input)) {\r\n    if (item === expected) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport type Constructor<T = any> = { new (...args: any[]): T };\r\n", "import { defaultConstructorsByTypeId, defaultGeneratorsByTypeId, TrackableTargetGenerator } from \"../client/client.js\";\r\nimport \"../shared/decorators.js\";\r\nimport { getHostObjectInfo, getObjectSyncMetaInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { hasInIterable, OneOrMany } from \"../shared/types.js\";\r\n\r\nconst TRACKABLE_CONSTRUCTOR_INFO = Symbol(\"trackableConstructor\");\r\n\r\ntype Constructor<T = any> = { new (...args: any[]): T };\r\n\r\ntype TrackedPropertySettings = {\r\n  designations?: string;\r\n};\r\n\r\ntype TrackableConstructorInfo = {\r\n  trackedProperties: Map<string, TrackedPropertySettings>;\r\n  trackedMethods: Map<string, TrackedPropertySettings>;\r\n  isAutoTrackable: boolean;\r\n  typeId?: string;\r\n  designations?: OneOrMany<string>;\r\n};\r\n\r\ntype TrackableObjectSettings<T extends object = any> = {\r\n  // The type ID for the trackable object\r\n  typeId?: string;\r\n  // The generator function for creating trackable instances, when not provided the default constructor will be used\r\n  generator?: TrackableTargetGenerator<T>;\r\n  // Designations for controlling access to the object\r\n  designations?: OneOrMany<string>;\r\n  // Additional settings for tracked properties\r\n  properties?: { [propertyKey: string]: TrackedPropertySettings };\r\n  // Additional settings for tracked methods\r\n  methods?: { [methodKey: string]: TrackedPropertySettings };\r\n};\r\n\r\n/**\r\n * Property accessor decorator for marking a property as trackable.\r\n * Registers the property and ensures changes are propagated to all TrackableObject instances.\r\n */\r\nexport function syncProperty<This, Return>(settings?: TrackedPropertySettings) {\r\n  settings ??= {};\r\n\r\n  return function syncProperty<This, Return>(target: ClassAccessorDecoratorTarget<This, Return>, context: ClassAccessorDecoratorContext<This, Return>) {\r\n    const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\r\n    trackableInfo.trackedProperties.set(context.name as string, settings);\r\n\r\n    const result: ClassAccessorDecoratorResult<This, Return> = {\r\n      set(value: any) {\r\n        target.set.call(this, value);\r\n\r\n        const host = getHostObjectInfo(this as any);\r\n        host?.onPropertyChanged(context.name as any, value);\r\n      },\r\n    };\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * Method decorator for marking a method as trackable.\r\n * Ensures method calls are recorded for all TrackableObject instances.\r\n */\r\nexport function syncMethod<This, Return>(settings?: TrackedPropertySettings) {\r\n  settings ??= {};\r\n\r\n  return function syncMethod(target: any, context: ClassMethodDecoratorContext) {\r\n    const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\r\n    trackableInfo.trackedMethods.set(context.name as string, settings);\r\n\r\n    const originalMethod = target;\r\n    return function (this: any, ...args: any[]) {\r\n      const result = originalMethod.apply(this, args);\r\n\r\n      const host = getObjectSyncMetaInfo(this)?.host;\r\n      host?.onMethodExecute(context.name as any, ...args);\r\n\r\n      return result;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Retrieves the TrackableConstructorInfo metadata for a class constructor, if present.\r\n */\r\nexport function getTrackableTypeInfo(ctor: Constructor): TrackableConstructorInfo | null {\r\n  const trackableInfo: TrackableConstructorInfo | undefined = (ctor as any)[Symbol.metadata]?.[TRACKABLE_CONSTRUCTOR_INFO] as TrackableConstructorInfo;\r\n  return trackableInfo ?? null;\r\n}\r\n\r\n/**\r\n * Class decorator for marking a class as auto-trackable by the host.\r\n * Can be used as @syncObject or @syncObject(\"typeId\").\r\n * Registers the class for automatic tracking and assigns a typeId if provided.\r\n */\r\nexport function syncObject<T extends object = any>(settings?: TrackableObjectSettings<T>): any {\r\n  return function syncObject(target: T, context: ClassDecoratorContext) {\r\n    settings ??= {};\r\n    settings.typeId ??= context.name!;\r\n    const trackableInfo = ensureTrackableConstructorInfo(context.metadata);\r\n    trackableInfo.isAutoTrackable = true;\r\n    trackableInfo.typeId = settings.typeId;\r\n    trackableInfo.designations = settings.designations;\r\n\r\n    if (settings.properties) {\r\n      for (const [propertyKey, propertySettings] of Object.entries(settings.properties)) {\r\n        trackableInfo.trackedProperties.set(propertyKey, propertySettings);\r\n      }\r\n    }\r\n    if (settings.methods) {\r\n      for (const [methodKey, methodSettings] of Object.entries(settings.methods)) {\r\n        trackableInfo.trackedMethods.set(methodKey, methodSettings);\r\n      }\r\n    }\r\n\r\n    if (settings.generator) {\r\n      defaultGeneratorsByTypeId.set(settings.typeId, settings.generator);\r\n    } else {\r\n      defaultConstructorsByTypeId.set(settings.typeId, target as any);\r\n    }\r\n  };\r\n}\r\n\r\nfunction ensureTrackableConstructorInfo(metadata: DecoratorMetadataObject): TrackableConstructorInfo {\r\n  let trackableInfo: TrackableConstructorInfo = metadata![TRACKABLE_CONSTRUCTOR_INFO] as TrackableConstructorInfo;\r\n  if (!trackableInfo) {\r\n    trackableInfo = {\r\n      trackedProperties: new Map<string, TrackedPropertySettings>(),\r\n      trackedMethods: new Map<string, TrackedPropertySettings>(),\r\n      isAutoTrackable: false,\r\n    };\r\n    metadata![TRACKABLE_CONSTRUCTOR_INFO] = trackableInfo;\r\n  }\r\n  return trackableInfo;\r\n}\r\n\r\nexport function checkCanUseProperty(constructor: Constructor, propertyKey: string, designation: string | undefined) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return false;\r\n  }\r\n  const propertyInfo = constructorInfo.trackedProperties.get(propertyKey);\r\n  if (!propertyInfo) {\r\n    return false;\r\n  }\r\n\r\n  if (propertyInfo.designations === undefined) return true;\r\n\r\n  if (designation === undefined) return true;\r\n\r\n  return hasInIterable(propertyInfo.designations, designation);\r\n}\r\n\r\nexport function checkCanUseMethod(constructor: Constructor, propertyKey: string, designation: string | undefined) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return false;\r\n  }\r\n  const propertyInfo = constructorInfo.trackedMethods.get(propertyKey);\r\n  if (!propertyInfo) {\r\n    return false;\r\n  }\r\n\r\n  if (propertyInfo.designations === undefined) return true;\r\n\r\n  if (designation === undefined) return true;\r\n\r\n  return hasInIterable(propertyInfo.designations, designation);\r\n}\r\n\r\nexport function checkCanUseObject(obj: object, designation: string | undefined) {\r\n  return checkCanUseConstructor(obj.constructor as Constructor, designation);\r\n}\r\n\r\nexport function checkCanUseConstructor(constructor: Constructor, designation: string | undefined) {\r\n  const constructorInfo = getTrackableTypeInfo(constructor);\r\n  if (!constructorInfo) {\r\n    return false;\r\n  }\r\n\r\n  if (constructorInfo.designations === undefined) return true;\r\n\r\n  if (designation === undefined) return true;\r\n\r\n  return hasInIterable(constructorInfo.designations, designation);\r\n}\r\n", "import { HostObjectInfo } from \"./hostObjectInfo.js\";\r\n\r\nexport const onConvertedToTrackable = Symbol(\"onConvertedToTrackable\");\r\nexport const onTick = Symbol(\"onTick\");\r\n\r\nexport interface ITrackedOnConvertedToTrackable<T extends object> {\r\n  [onConvertedToTrackable](info: HostObjectInfo<T>): void;\r\n}\r\n\r\nexport interface ITrackedOnTick<T extends object> {\r\n  [onTick](): void;\r\n}\r\n\r\nfunction hasOnConvertedToTrackable<T extends object>(obj: any): obj is ITrackedOnConvertedToTrackable<T> {\r\n  return onConvertedToTrackable in obj;\r\n}\r\n\r\nfunction hasOnTick<T extends object>(obj: any): obj is ITrackedOnTick<T> {\r\n  return onTick in obj;\r\n}\r\n\r\nexport function invokeOnConvertedToTrackable<T extends object>(obj: T, info: HostObjectInfo<T>) {\r\n  if (hasOnConvertedToTrackable<T>(obj)) {\r\n    obj[onConvertedToTrackable](info);\r\n  }\r\n}\r\n\r\nexport function invokeOnTick<T extends object>(obj: T) {\r\n  if (hasOnTick<T>(obj)) {\r\n    obj[onTick]();\r\n  }\r\n}\r\n", "import { ObjectSyncClient } from \"../client/client.js\";\r\nimport { ITrackableOnUpdateProperty, onUpdateProperty } from \"../client/trackableTarget.js\";\r\nimport { syncObject } from \"../host/decorators.js\";\r\nimport { HostObjectInfo } from \"../host/hostObjectInfo.js\";\r\nimport { ITrackedOnConvertedToTrackable, ITrackedOnTick, onConvertedToTrackable, onTick } from \"../host/trackedTarget.js\";\r\nimport { isPropertyInfoSymbol, PropertyInfo } from \"./messages.js\";\r\nimport { getHostObjectInfo } from \"./objectSyncMetaInfo.js\";\r\n\r\nexport type SyncableArrayChange<T> = { start: number; deleteCount: number; items: PropertyInfo<any, any>[] };\r\n\r\n@syncObject({\r\n  typeId: \"SyncableArray\",\r\n  properties: {\r\n    _changes: {},\r\n    _creation: {},\r\n  },\r\n})\r\nexport class SyncableArray<T> implements ITrackableOnUpdateProperty<any>, ITrackedOnConvertedToTrackable<SyncableArray<T>>, ITrackedOnTick<SyncableArray<T>> {\r\n  private _values: T[] = [];\r\n  private _changes: SyncableArrayChange<T>[] = [];\r\n  private _creation: PropertyInfo<any, any>[] = [];\r\n\r\n  constructor(initial: T[] = []) {\r\n    this.push(...initial);\r\n  }\r\n\r\n  get value(): T[] {\r\n    return this._values;\r\n  }\r\n\r\n  set value(value: T[]) {\r\n    this.clear();\r\n    this.push(...value);\r\n  }\r\n\r\n  clear() {\r\n    this.length = 0;\r\n  }\r\n\r\n  changeAt(index: number, value: T) {\r\n    this._values[index] = value;\r\n\r\n    this.onRemoved(index, [value]);\r\n    this.onAdded(index, [value]);\r\n\r\n    const hostObjectInfo = getHostObjectInfo(this);\r\n    if (hostObjectInfo) {\r\n      this._creation[index] = this.convertItemToPropertyInfo(hostObjectInfo, value);\r\n      this.addChange({ start: index, deleteCount: 1, items: this.convertItemsToPropertyInfos(hostObjectInfo, [value]) });\r\n    }\r\n  }\r\n\r\n  get length(): number {\r\n    return this._values.length;\r\n  }\r\n\r\n  set length(value: number) {\r\n    if (value < this._values.length) {\r\n      this.splice(value, this._values.length - value);\r\n    } else if (value > this._values.length) {\r\n      this.push(...(new globalThis.Array(value - this._values.length).fill(undefined) as T[]));\r\n    }\r\n  }\r\n\r\n  push(...items: T[]): number {\r\n    if (items.length === 0) return this._values.length;\r\n\r\n    const startIndex = this._values.length;\r\n    this._values.push(...items);\r\n\r\n    const hostObjectInfo = getHostObjectInfo(this);\r\n    if (hostObjectInfo) {\r\n      this._creation.push(...this.convertItemsToPropertyInfos(hostObjectInfo, items));\r\n      this.addChange({ start: startIndex, deleteCount: 0, items: this.convertItemsToPropertyInfos(hostObjectInfo, items) });\r\n    }\r\n\r\n    this.onAdded(startIndex, items);\r\n    return this._values.length;\r\n  }\r\n\r\n  private convertPropertyInfosToItems(items: PropertyInfo<any, any>[], client: ObjectSyncClient): T[] {\r\n    return items.map((item) => client.getPropertyValue(item));\r\n  }\r\n\r\n  splice(start: number, deleteCount?: number, ...items: T[]): T[] {\r\n    deleteCount ??= this._values.length - start;\r\n    if (deleteCount === 0 && items.length === 0) return [];\r\n\r\n    const removedItems = this._values.splice(start, deleteCount, ...items);\r\n    if (removedItems.length > 0) this.onRemoved(start, removedItems);\r\n    if (items.length > 0) this.onAdded(start, items);\r\n\r\n    const hostObjectInfo = getHostObjectInfo(this);\r\n    if (hostObjectInfo) {\r\n      const convertedItems = this.convertItemsToPropertyInfos(hostObjectInfo, items);\r\n      this._creation.splice(start, deleteCount, ...convertedItems);\r\n      this.addChange({ start, deleteCount, items: convertedItems });\r\n    }\r\n\r\n    return removedItems;\r\n  }\r\n\r\n  private addChange(pendingChange: SyncableArrayChange<T> | null) {\r\n    this.onPropertyChanged(\"_changes\", this._changes);\r\n\r\n    while (pendingChange) {\r\n      const lastChange = this._changes[this._changes.length - 1];\r\n      if (!lastChange) {\r\n        this._changes.push(pendingChange);\r\n        return;\r\n      }\r\n\r\n      // Try to merge consecutive pushes at the end\r\n      if (lastChange.deleteCount === 0 && pendingChange.deleteCount === 0 && lastChange.start + lastChange.items.length === pendingChange.start) {\r\n        // Merge pushes at the end\r\n        lastChange.items.push(...pendingChange.items);\r\n        // After merging, try to merge lastChange with the previous one\r\n        pendingChange = this._changes.pop()!;\r\n        continue;\r\n      }\r\n\r\n      // Try to merge a removal at the end with a previous push\r\n      if (\r\n        lastChange.deleteCount === 0 &&\r\n        pendingChange.deleteCount > 0 &&\r\n        pendingChange.items.length === 0 &&\r\n        lastChange.start + lastChange.items.length === pendingChange.start + pendingChange.deleteCount &&\r\n        pendingChange.start >= lastChange.start\r\n      ) {\r\n        // Only remove from the end of the last push\r\n        const removeCount = pendingChange.deleteCount;\r\n        const newLength = lastChange.items.length - removeCount;\r\n        if (newLength > 0) {\r\n          lastChange.items.length = newLength;\r\n          // After merging, try to merge lastChange with the previous one\r\n          pendingChange = this._changes.pop()!;\r\n          continue;\r\n        } else {\r\n          // If all items are removed, remove the last change\r\n          this._changes.pop();\r\n          // After removing, try to merge with the new last change\r\n          pendingChange = pendingChange;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Try to merge a removal inside a previous push\r\n      if (\r\n        lastChange.deleteCount === 0 &&\r\n        pendingChange.deleteCount > 0 &&\r\n        pendingChange.items.length === 0 &&\r\n        pendingChange.start >= lastChange.start &&\r\n        pendingChange.start < lastChange.start + lastChange.items.length &&\r\n        pendingChange.start + pendingChange.deleteCount <= lastChange.start + lastChange.items.length\r\n      ) {\r\n        // Remove items from inside the previous push\r\n        const relativeStart = pendingChange.start - lastChange.start;\r\n        lastChange.items.splice(relativeStart, pendingChange.deleteCount);\r\n        // After merging, try to merge lastChange with the previous one\r\n        pendingChange = this._changes.pop()!;\r\n        continue;\r\n      }\r\n\r\n      // No merge possible, just push\r\n      this._changes.push(pendingChange);\r\n      return;\r\n    }\r\n  }\r\n\r\n  private convertItemsToPropertyInfos(serverObjectInfo: HostObjectInfo<any>, items: T[]): PropertyInfo<any, any>[] {\r\n    return items.map((item) => this.convertItemToPropertyInfo(serverObjectInfo, item));\r\n  }\r\n\r\n  private convertItemToPropertyInfo(serverObjectInfo: HostObjectInfo<any>, item: T): PropertyInfo<any, any> {\r\n    const metaInfo = serverObjectInfo.convertToTrackableObjectReference(item as any);\r\n    const transformed: PropertyInfo<any, any> = {\r\n      value: item,\r\n      objectId: metaInfo?.objectId,\r\n      [isPropertyInfoSymbol]: true,\r\n    };\r\n\r\n    return transformed;\r\n  }\r\n\r\n  [Symbol.iterator]() {\r\n    return this._values[Symbol.iterator]();\r\n  }\r\n\r\n  private onPropertyChanged(property: string, value: any) {\r\n    const host = getHostObjectInfo(this);\r\n    if (!host) return;\r\n\r\n    host.onPropertyChanged(property as any, value);\r\n  }\r\n\r\n  [onTick](): void {\r\n    this._changes = [];\r\n  }\r\n\r\n  [onConvertedToTrackable](hostObjectInfo: HostObjectInfo<SyncableArray<T>>): void {\r\n    this._creation = [...this.convertItemsToPropertyInfos(hostObjectInfo, this._values)];\r\n    this.onPropertyChanged(\"_creation\", this._creation);\r\n    this.onPropertyChanged(\"_changes\", this._changes);\r\n  }\r\n\r\n  [onUpdateProperty](key: string | number | symbol, value: any, isForCreate: boolean, client: ObjectSyncClient): boolean {\r\n    if (isForCreate && key === \"_creation\") {\r\n      this.value = this.convertPropertyInfosToItems(value, client);\r\n    } else if (!isForCreate && key === \"_changes\") {\r\n      this.applyTrackableArrayChanges(this._values, value, client);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private applyTrackableArrayChanges(arr: T[], changes: SyncableArrayChange<T>[], client: ObjectSyncClient): T[] {\r\n    for (const change of changes) {\r\n      const newItems = this.convertPropertyInfosToItems(change.items, client);\r\n      const removedItems = arr.splice(change.start, change.deleteCount, ...newItems);\r\n      if (removedItems.length > 0) this.onRemoved(change.start, removedItems);\r\n      if (change.items.length > 0) this.onAdded(change.start, newItems);\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  // toJson and toValue\r\n  toJSON() {\r\n    return this._values;\r\n  }\r\n\r\n  toValue() {\r\n    return this._values;\r\n  }\r\n\r\n  protected onRemoved(start: number, items: T[]): void {\r\n    // Can be used in subclasses\r\n  }\r\n\r\n  protected onAdded(start: number, items: T[]): void {\r\n    // Can be used in subclasses\r\n  }\r\n}\r\n", "import { PropertyInfo, CreateObjectMessage, PropertyInfos, ChangeObjectMessage, Message, DeleteObjectMessage, ExecuteObjectMessage, isPropertyInfoSymbol } from \"../shared/index.js\";\r\nimport { checkCanUseMethod, checkCanUseProperty, getTrackableTypeInfo } from \"./decorators.js\";\r\nimport { ClientConnection } from \"./host.js\";\r\nimport { ensureObjectSyncMetaInfo, getObjectSyncMetaInfo, ObjectSyncMetaInfo, ObjectSyncMetaInfoCreateSettings, ObjectInfoBase } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { invokeOnConvertedToTrackable, invokeOnTick } from \"./trackedTarget.js\";\r\nimport { Constructor, hasInIterable, OneOrMany, toIterable } from \"../shared/types.js\";\r\n\r\nexport type AdditionalHostPropertyInfo = {\r\n  hasPendingChanges: boolean;\r\n};\r\n\r\nexport type HostChangeObjectMessage<T extends object = object> = ChangeObjectMessage<T, AdditionalHostPropertyInfo>;\r\nexport type HostMessage<T extends object = object> = Message<T, AdditionalHostPropertyInfo>;\r\n\r\nlet nextInvokeId = 0;\r\n\r\nexport type ClientFilter = {\r\n  /**\r\n   * Set of clients to include or exclude\r\n   */\r\n  clients?: OneOrMany<ClientConnection>;\r\n\r\n  /**\r\n   * Set of client designations to include or exclude\r\n   */\r\n  designations?: OneOrMany<string>;\r\n\r\n  /**\r\n   * If true, only the specified clients are included; if false, they are excluded, default is true\r\n   */\r\n  isExclusive?: boolean;\r\n};\r\n\r\nfunction isForClientConnection(clientConnection: ClientConnection, filter: ClientFilter): boolean {\r\n  let hasDesignation = filter.designations === undefined || clientConnection.designation === undefined;\r\n  if (!hasDesignation) {\r\n    hasDesignation = hasInIterable(filter.designations!, clientConnection.designation);\r\n  }\r\n\r\n  let hasClientConnection = filter.clients === undefined;\r\n  if (!hasClientConnection) {\r\n    hasClientConnection = hasInIterable(filter.clients!, clientConnection);\r\n  }\r\n\r\n  return filter.isExclusive === (hasDesignation && hasClientConnection);\r\n}\r\n\r\nexport type ClientSpecificView<T extends object> = {\r\n  /**\r\n   * Optional filter to restrict the view to specific clients\r\n   */\r\n  filter?: ClientFilter;\r\n\r\n  /**\r\n   * Callback to modify property info before sending to the client; return null to exclude the property\r\n   * @param client The client requesting the property info\r\n   * @param key The property key\r\n   * @param propertyInfo The current property info\r\n   */\r\n  onProperty?<TKey extends keyof T>(client: ClientConnection, key: TKey, propertyInfo: PropertyInfo<T, TKey>): PropertyInfo<T, TKey> | null;\r\n\r\n  /**\r\n   * Callback to modify the typeId before sending to the client; return null to exclude the object from beeing sent to the client\r\n   * @param client The client requesting the typeId\r\n   * @param typeId The current typeId of the object\r\n   */\r\n  onTypeId?(client: ClientConnection, typeId: string): string | null;\r\n};\r\n\r\nexport type ServerObjectSyncMetaInfoCreateSettings<T extends object> = ObjectSyncMetaInfoCreateSettings<T> & {\r\n  isRoot: boolean;\r\n  objectIdPrefix: string;\r\n};\r\n\r\n/**\r\n * TrackableObject wraps an object for change tracking and client synchronization on the host side.\r\n * It manages property changes, client-specific views, and message generation for create, change, delete, and execute operations.\r\n */\r\nexport class HostObjectInfo<T extends object> extends ObjectInfoBase {\r\n  /**\r\n   * Creates a TrackableObject from a plain object, optionally specifying typeId and objectId.\r\n   * Registers tracked properties and initializes their values.\r\n   */\r\n  static createFromObject<T extends object>(settings: ServerObjectSyncMetaInfoCreateSettings<T>): HostObjectInfo<T> {\r\n    const metaInfo = ensureObjectSyncMetaInfo(settings);\r\n    if (!metaInfo) {\r\n      throw new Error(\"Failed to create HostObjectInfo: unable to ensure ObjectSyncMetaInfo.\");\r\n    }\r\n    metaInfo.host = new HostObjectInfo<T>(metaInfo, settings.isRoot, settings.objectIdPrefix);\r\n    invokeOnConvertedToTrackable(metaInfo.object as T, metaInfo.host);\r\n\r\n    const trackableTypeInfo = getTrackableTypeInfo((settings.object as any).constructor);\r\n    if (trackableTypeInfo) {\r\n      trackableTypeInfo.trackedProperties.forEach((propertyInfo, key) => {\r\n        metaInfo.host!.onPropertyChanged(key as keyof T, (settings.object as any)[key]);\r\n      });\r\n    }\r\n    return metaInfo.host!;\r\n  }\r\n\r\n  /**\r\n   * Ensures an object is auto-trackable, returning a TrackableObject if possible.\r\n   * If the object is already trackable, returns the existing wrapper.\r\n   */\r\n  static tryEnsureAutoTrackable<T extends object>(settings: ServerObjectSyncMetaInfoCreateSettings<T>): HostObjectInfo<T> | null {\r\n    if (!settings.object || typeof settings.object !== \"object\") return null;\r\n\r\n    const trackableTypeInfo = getTrackableTypeInfo((settings.object as any).constructor);\r\n    if (trackableTypeInfo?.isAutoTrackable !== true) return null;\r\n\r\n    const metaInfo = ensureObjectSyncMetaInfo(settings);\r\n    if (!metaInfo) {\r\n      throw new Error(\"Failed to create HostObjectInfo: unable to ensure ObjectSyncMetaInfo.\");\r\n    }\r\n\r\n    return metaInfo.host ?? this.createFromObject(settings);\r\n  }\r\n\r\n  /** Holds the current set of property changes for this object. */\r\n  private readonly _changeSet: HostChangeObjectMessage<T>;\r\n  /** Holds pending method invocation messages for this object. */\r\n  private readonly _methodInvokeCalls: ExecuteObjectMessage<T>[] = [];\r\n  /** Holds client filter settings for restricting visibility. */\r\n  private _clientFilters: ClientFilter | null = null;\r\n  /** Holds all registered client-specific views for this object. */\r\n  private _views: ClientSpecificView<T>[] = [];\r\n  /** Holds the set of clients which know about this. */\r\n  private _clients: Set<ClientConnection> = new Set();\r\n\r\n  /**\r\n   * Constructs a TrackableObject with a typeId and optional objectId.\r\n   */\r\n  private constructor(objectSyncMetaInfo: ObjectSyncMetaInfo, private _isRootObject: boolean, private readonly _objectIdPrefix: string) {\r\n    super(objectSyncMetaInfo);\r\n\r\n    this._changeSet = {\r\n      type: \"change\",\r\n      objectId: this.objectId,\r\n      properties: {},\r\n    };\r\n  }\r\n\r\n  get clients(): Set<ClientConnection> {\r\n    return this._clients;\r\n  }\r\n\r\n  get isRootObject() {\r\n    return this._isRootObject;\r\n  }\r\n  set isRootObject(value: boolean) {\r\n    this._isRootObject = value;\r\n  }\r\n\r\n  get properties(): PropertyInfos<T, AdditionalHostPropertyInfo> {\r\n    return this._changeSet.properties;\r\n  }\r\n\r\n  /**\r\n   * Determines if this object is visible to a given client based on filters.\r\n   */\r\n  isForClient(client: ClientConnection): boolean {\r\n    if (!this._clientFilters) return true;\r\n\r\n    const filter = this._clientFilters;\r\n    return isForClientConnection(client, filter);\r\n  }\r\n\r\n  /**\r\n   * Adds a client-specific view to this object.\r\n   */\r\n  addView(view: ClientSpecificView<T>): void {\r\n    this._views.push(view);\r\n  }\r\n\r\n  /**\r\n   * Removes a client-specific view from this object.\r\n   * @returns true if the view was removed, false otherwise.\r\n   */\r\n  removeView(view: ClientSpecificView<T>): boolean {\r\n    const initialLength = this._views.length;\r\n    this._views = this._views.filter((v) => v !== view);\r\n    return this._views.length < initialLength;\r\n  }\r\n\r\n  /**\r\n   * Returns all registered client-specific views for this object.\r\n   */\r\n  get allRegisteredViews(): readonly ClientSpecificView<T>[] {\r\n    return this._views;\r\n  }\r\n\r\n  /**\r\n   * Returns all views that apply to a given client.\r\n   */\r\n  getViewsForClient(client: ClientConnection): ClientSpecificView<T>[] {\r\n    return this._views.filter((view) => !view.filter || hasInIterable(view.filter.clients, client) === view.filter.isExclusive);\r\n  }\r\n\r\n  /**\r\n   * Removes all client restrictions, making the object visible to all clients.\r\n   */\r\n  removeClientRestrictions(): void {\r\n    this._clientFilters = null;\r\n  }\r\n\r\n  /**\r\n   * Restricts the object to a set of clients (inclusive or exclusive).\r\n   */\r\n  setClientRestriction(filter: ClientFilter): void {\r\n    this._clientFilters = {\r\n      clients: filter.clients ? toIterable(filter.clients, true) : undefined,\r\n      designations: filter.designations ? toIterable(filter.designations, true) : undefined,\r\n      isExclusive: filter.isExclusive ?? true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Records a property change, converting values to trackable references if needed.\r\n   */\r\n  onPropertyChanged(key: keyof T, value: T[keyof T]) {\r\n    let current = this._changeSet.properties[key];\r\n    if (!current) {\r\n      current = { hasPendingChanges: true, [isPropertyInfoSymbol]: true };\r\n      this._changeSet.properties[key] = current;\r\n    }\r\n    else if (current.value === value) {\r\n      return;\r\n    }\r\n\r\n    this.convertToTrackableObjectReference(value as any);\r\n\r\n    const metaInfo = getObjectSyncMetaInfo(value as object);\r\n    const objectId: unknown = metaInfo?.objectId;\r\n    current.value = value as any;\r\n    current.objectId = objectId;\r\n    current.hasPendingChanges = true;\r\n  }\r\n\r\n  /**\r\n   * Records a method execution for this object, converting arguments to trackable references if needed.\r\n   */\r\n  onMethodExecute(method: keyof T, ...args: any[]) {\r\n    const parameters: PropertyInfos<any, any>[] = [];\r\n    args.forEach((arg, index) => {\r\n      const trackable = this.convertToTrackableObjectReference(arg);\r\n      const paramInfo: PropertyInfo<any, any> = {\r\n        value: trackable ?? arg,\r\n        objectId: trackable?.objectSyncMetaInfo.objectId,\r\n        [isPropertyInfoSymbol]: true,\r\n      };\r\n      parameters.push(paramInfo);\r\n    });\r\n    const message: ExecuteObjectMessage<T> = {\r\n      type: \"execute\",\r\n      id: nextInvokeId++,\r\n      objectId: this.objectId,\r\n      parameters: parameters as any,\r\n      method: method as any,\r\n    };\r\n    this._methodInvokeCalls.push(message);\r\n  }\r\n\r\n  /**\r\n   * Converts a value to a trackable object reference if possible.\r\n   */\r\n  public convertToTrackableObjectReference(target: object) {\r\n    if (target && typeof target === \"object\") {\r\n      return HostObjectInfo.tryEnsureAutoTrackable({\r\n        object: target,\r\n        isRoot: false,\r\n        objectIdPrefix: this._objectIdPrefix,\r\n      });\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Generates a create message for this object for a given client, applying any view-based typeId overrides.\r\n   * Returns null if the object should not be sent to the client.\r\n   */\r\n  getCreateMessage(client: ClientConnection): CreateObjectMessage<T> | null {\r\n    let typeId = this.typeId;\r\n    const views = this.getViewsForClient(client).filter((v) => v.onTypeId);\r\n    for (const view of views) {\r\n      const newTypeId = view.onTypeId!(client, typeId);\r\n      if (!newTypeId) return null;\r\n      typeId = newTypeId;\r\n    }\r\n    const result: CreateObjectMessage<T> = {\r\n      type: \"create\",\r\n      objectId: this.objectId,\r\n      typeId,\r\n      properties: this.getProperties(client, false),\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates a delete message for this object.\r\n   */\r\n  getDeleteMessage(): DeleteObjectMessage {\r\n    const result: DeleteObjectMessage = {\r\n      type: \"delete\",\r\n      objectId: this.objectId,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates a change message for this object for a given client, including only changed properties.\r\n   * Returns null if there are no changes.\r\n   */\r\n  getChangeMessage(client: ClientConnection): ChangeObjectMessage<T> | null {\r\n    const properties = this.getProperties(client, true);\r\n    if (Object.keys(properties).length === 0) return null;\r\n    const result: ChangeObjectMessage<T> = {\r\n      type: \"change\",\r\n      objectId: this.objectId,\r\n      properties,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns all pending execute messages for this object.\r\n   */\r\n  getExecuteMessages(client: ClientConnection): ExecuteObjectMessage<T>[] {\r\n    return this._methodInvokeCalls.filter((msg) => {\r\n      return checkCanUseMethod(this.object.constructor as Constructor, msg.method, client.designation);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gathers property info for this object for a given client, applying any view-based property overrides.\r\n   * If includeChangedOnly is true, only changed properties are included.\r\n   */\r\n  private getProperties(client: ClientConnection, includeChangedOnly: boolean): PropertyInfos<T> {\r\n    const views = this.getViewsForClient(client).filter((v) => v.onProperty);\r\n    const result: PropertyInfos<T> = {};\r\n    Object.keys(this._changeSet.properties).forEach((key) => {\r\n      const propertyInfo = this._changeSet.properties[key as keyof T]!;\r\n      if (includeChangedOnly && !propertyInfo.hasPendingChanges) return;\r\n\r\n      if (!checkCanUseProperty(this.object.constructor as Constructor, key, client.designation)) return;\r\n\r\n      let clientPropertyInfo: PropertyInfo<T, keyof T> = {\r\n        objectId: propertyInfo.objectId,\r\n        value: propertyInfo.value,\r\n        [isPropertyInfoSymbol]: true,\r\n      };\r\n\r\n      if (propertyInfo.objectId === undefined && propertyInfo.objectId === null) {\r\n        delete clientPropertyInfo.objectId;\r\n      }\r\n\r\n      for (const view of views) {\r\n        const newPropertyInfo = view.onProperty!(client, key as keyof T, clientPropertyInfo);\r\n        if (newPropertyInfo === null) {\r\n          return;\r\n        }\r\n        clientPropertyInfo = newPropertyInfo;\r\n      }\r\n      result[key as keyof T] = clientPropertyInfo;\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Resets the hasPendingChanges flag for all properties and clears pending method calls.\r\n   */\r\n  tick(): void {\r\n    Object.keys(this._changeSet.properties).forEach((key) => {\r\n      const propertyInfo = this._changeSet.properties[key as keyof T]!;\r\n      propertyInfo.hasPendingChanges = false;\r\n    });\r\n    this._methodInvokeCalls.length = 0;\r\n\r\n    invokeOnTick(this.objectSyncMetaInfo.object as T);\r\n  }\r\n}\r\n", "import { ChangeObjectMessage, CreateObjectMessage, DeleteObjectMessage, ExecuteObjectMessage, isPropertyInfo, Message, PropertyInfo, TrackedObjectPool } from \"../shared/index.js\";\r\nimport { getHostObjectInfo } from \"../shared/objectSyncMetaInfo.js\";\r\nimport { forEachIterable, OneOrMany } from \"../shared/types.js\";\r\nimport { checkCanUseObject } from \"./decorators.js\";\r\nimport { ClientFilter, ClientSpecificView, HostObjectInfo, ServerObjectSyncMetaInfoCreateSettings } from \"./hostObjectInfo.js\";\r\n\r\nexport type TrackSettings = {\r\n  /**\r\n   * Optional unique identifier for the object; if not provided, one will be generated.\r\n   */\r\n  objectId?: unknown;\r\n\r\n  /**\r\n   * If true, the object is considered a root object. Defaults to true.\r\n   */\r\n  isRoot?: boolean;\r\n\r\n  /**\r\n   * Settings for restricting client visibility of the object.\r\n   */\r\n  clientVisibility?: ClientFilter;\r\n\r\n  /**\r\n   * If true, tracking an already tracked object will be ignored instead of throwing an error.\r\n   * Defaults to false.\r\n   */\r\n  ignoreAlreadyTracked?: boolean;\r\n\r\n  knownClients?: OneOrMany<ClientConnection>;\r\n};\r\n\r\nexport type ObjectSyncHostSettings = {\r\n  objectIdPrefix?: string;\r\n  objectPool?: TrackedObjectPool;\r\n  designation?: string;\r\n};\r\n\r\nexport type ClientConnectionSettings = {\r\n  designation?: string;\r\n};\r\n\r\nexport type ClientConnection = ClientConnectionSettings;\r\n\r\n/**\r\n * The ChangeTrackerHost manages the lifecycle and visibility of trackable objects on the host/server side.\r\n * It tracks which objects are visible to which clients, manages object creation/deletion, and generates messages for clients.\r\n */\r\nexport class ObjectSyncHost {\r\n  /** Pool of all currently tracked objects and their info. */\r\n  private _trackedObjectPool: TrackedObjectPool;\r\n  /** Maps client IDs to lists of delete messages for objects that have been untracked. */\r\n  private _untrackedObjectInfosByClient = new Map<ClientConnection, DeleteObjectMessage[]>();\r\n\r\n  private _clients: Set<ClientConnectionSettings> = new Set();\r\n\r\n  constructor(private readonly _settings: ObjectSyncHostSettings = {}) {\r\n    if (!this._settings.objectIdPrefix) {\r\n      this._settings.objectIdPrefix = `host-${Date.now()}-`;\r\n    }\r\n    this._trackedObjectPool = this._settings.objectPool ?? new TrackedObjectPool();\r\n  }\r\n\r\n  /** Returns all currently tracked objects. */\r\n  get allTrackedObjects() {\r\n    return this._trackedObjectPool.all;\r\n  }\r\n\r\n  registerClient(settings: ClientConnectionSettings = {}): ClientConnection {\r\n    const clientToken = JSON.parse(JSON.stringify(settings));\r\n    this._clients.add(clientToken);\r\n    return clientToken;\r\n  }\r\n\r\n  /**\r\n   * Removes all client-specific state for a client (e.g., when disconnecting).\r\n   */\r\n  removeClient(client: ClientConnection): void {\r\n    if (!this._clients.has(client)) {\r\n      throw new Error(\"Unknown client token\");\r\n    }\r\n\r\n    this._trackedObjectPool.all.forEach((obj) => {\r\n      const hostObjectInfo = getHostObjectInfo(obj)!;\r\n      hostObjectInfo.clients.delete(client);\r\n    });\r\n    this._untrackedObjectInfosByClient.delete(client);\r\n\r\n    this._clients.delete(client);\r\n  }\r\n\r\n  /**\r\n   * Restricts the visibility of a tracked object to a set of clients.\r\n   * @param obj The object to restrict.\r\n   * @param clients The client(s) allowed or excluded.\r\n   * @param isExclusive If true, only the given clients can see the object; otherwise, all except these clients can see it.\r\n   */\r\n  setClientRestriction<T extends object>(obj: T, filter: ClientFilter): void {\r\n    const tracked = getHostObjectInfo(obj);\r\n    if (!tracked) throw new Error(\"Object is not tracked\");\r\n    tracked.setClientRestriction(filter);\r\n  }\r\n\r\n  /**\r\n   * Adds a client-specific view to a tracked object.\r\n   */\r\n  addView<T extends object>(obj: T, view: ClientSpecificView<T>): void {\r\n    const tracked = getHostObjectInfo(obj);\r\n    if (!tracked) throw new Error(\"Object is not tracked\");\r\n    tracked.addView(view);\r\n  }\r\n\r\n  /**\r\n   * Removes a client-specific view from a tracked object.\r\n   * @returns true if the view was removed, false otherwise.\r\n   */\r\n  removeView<T extends object>(obj: T, view: ClientSpecificView<T>): boolean {\r\n    const tracked = getHostObjectInfo(obj);\r\n    if (!tracked) return false;\r\n    return tracked.removeView(view);\r\n  }\r\n\r\n  /**\r\n   * Begins tracking an object, optionally with settings for object ID and client visibility.\r\n   * Throws if objectId is specified for an already-trackable object.\r\n   */\r\n  track<T extends object>(target: T, trackSettings?: TrackSettings): void {\r\n    this.trackInternal(target, trackSettings);\r\n  }\r\n\r\n  private trackInternal<T extends object>(target: T, trackSettings?: TrackSettings): HostObjectInfo<T> | null {\r\n    if (!target) return null;\r\n\r\n    const isRoot = trackSettings?.isRoot !== false;\r\n\r\n    if (this._trackedObjectPool.has(target) && getHostObjectInfo(target)) {\r\n      if (isRoot && (trackSettings?.ignoreAlreadyTracked ?? false) === false) {\r\n        throw new Error(\"Object is already tracked\");\r\n      }\r\n      return null;\r\n    }\r\n\r\n    const creationSettings: ServerObjectSyncMetaInfoCreateSettings<T> = {\r\n      objectId: trackSettings?.objectId,\r\n      isRoot,\r\n      object: target,\r\n      objectIdPrefix: this._settings.objectIdPrefix!,\r\n    };\r\n\r\n    const hostObjectInfo: HostObjectInfo<T> | null = getHostObjectInfo(target) ?? HostObjectInfo.tryEnsureAutoTrackable<T>(creationSettings) ?? HostObjectInfo.createFromObject(creationSettings);\r\n\r\n    if (!hostObjectInfo) return null;\r\n\r\n    if (!this._trackedObjectPool.has(target)) this._trackedObjectPool.add(target);\r\n\r\n    this._untrackedObjectInfosByClient.forEach((deleteMessages, client) => {\r\n      let deleteMessageIndex = deleteMessages.findIndex((m) => m.objectId === hostObjectInfo.objectId);\r\n      if (deleteMessageIndex === -1) return;\r\n      deleteMessages.splice(deleteMessageIndex, 1);\r\n      if (deleteMessages.length === 0) {\r\n        this._untrackedObjectInfosByClient.delete(client);\r\n      }\r\n    });\r\n    if (trackSettings?.clientVisibility) {\r\n      this.setClientRestriction(target, trackSettings.clientVisibility);\r\n    }\r\n\r\n    if (trackSettings?.knownClients) {\r\n      const clients = getHostObjectInfo(target)?.clients;\r\n      if (clients) {\r\n        forEachIterable(trackSettings.knownClients, (client) => {\r\n          clients.add(client);\r\n        });\r\n      }\r\n    }\r\n\r\n    return hostObjectInfo;\r\n  }\r\n\r\n  /**\r\n   * Stops tracking an object and queues delete messages for all clients that could see it.\r\n   * If an object is passed instead of a TrackableObject, it will first be looked up.\r\n   */\r\n  untrack<T extends object>(target: T): void {\r\n    if (this.untrackInternal(target, true)) this.removeUnusedObjects();\r\n  }\r\n\r\n  private untrackInternal<T extends object>(target: T, throwWhenNotTracked: boolean) {\r\n    const hostObjectInfo = getHostObjectInfo(target)!;\r\n    if (!this._trackedObjectPool.has(target) || !hostObjectInfo) {\r\n      if (throwWhenNotTracked) {\r\n        throw new Error(\"Object is not tracked\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    this._trackedObjectPool.delete(target);\r\n    const clients = Array.from(hostObjectInfo.clients);\r\n    const deleteMessage = hostObjectInfo.getDeleteMessage();\r\n    clients.forEach((client) => {\r\n      let deleteMessages = this._untrackedObjectInfosByClient.get(client);\r\n      if (!deleteMessages) {\r\n        deleteMessages = [];\r\n        this._untrackedObjectInfosByClient.set(client, deleteMessages);\r\n      }\r\n      deleteMessages.push(deleteMessage);\r\n    });\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * For a given message, finds and tracks any nested objects referenced by objectId/value pairs.\r\n   * Removes the value from the property after tracking.\r\n   * @returns Array of HostTrackableObjectInfo for any new objects tracked.\r\n   */\r\n  private gatherUntrackedObjectInfos(data: ChangeObjectMessage<any> | CreateObjectMessage<any>) {\r\n    return this.gatherUntrackedObjectInfosFromRaw(data.properties);\r\n  }\r\n\r\n  private gatherUntrackedObjectInfosFromRaw(data: object | Array<any>, tracked: Set<object> = new Set()): object[] {\r\n    if (tracked.has(data)) {\r\n      return [];\r\n    }\r\n    tracked.add(data);\r\n\r\n    const result: object[] = [];\r\n\r\n    if (isPropertyInfo(data)) {\r\n      const propertyInfo = data as PropertyInfo<any, any>;\r\n      if (propertyInfo.objectId && propertyInfo.value) {\r\n        const newTrackable = this.trackInternal(propertyInfo.value, { isRoot: false });\r\n        delete propertyInfo.value;\r\n        if (newTrackable) {\r\n          result.push(newTrackable.object);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (Array.isArray(data)) {\r\n      data.forEach((value) => {\r\n        if (!value || typeof value !== \"object\") return;\r\n\r\n        result.push(...this.gatherUntrackedObjectInfosFromRaw(value, tracked));\r\n      });\r\n      return result;\r\n    }\r\n\r\n    Object.keys(data).forEach((key) => {\r\n      const value = (data as any)[key];\r\n\r\n      if (!value || typeof value !== \"object\") return;\r\n\r\n      if (!isPropertyInfo(value)) {\r\n        result.push(...this.gatherUntrackedObjectInfosFromRaw(value, tracked));\r\n        return;\r\n      }\r\n\r\n      const propertyInfo = value as PropertyInfo<any, any>;\r\n      if (propertyInfo.objectId && propertyInfo.value) {\r\n        const newTrackable = this.trackInternal(propertyInfo.value, { isRoot: false });\r\n        delete propertyInfo.value;\r\n        if (newTrackable) {\r\n          result.push(newTrackable.object);\r\n        }\r\n      }\r\n\r\n      if (propertyInfo.value && typeof propertyInfo.value === \"object\") {\r\n        result.push(...this.gatherUntrackedObjectInfosFromRaw(propertyInfo.value, tracked));\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  getMessages(tick: boolean = true): Map<ClientConnection, Message[]> {\r\n    const result = new Map<ClientConnection, Message[]>();\r\n    for (const client of this._clients) {\r\n      result.set(client, this.getMessagesForClientInternal(client));\r\n    }\r\n    if (tick) this.tick();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Internal: Gathers all messages for a client.\r\n   */\r\n  private getMessagesForClientInternal(client: ClientConnection): Message[] {\r\n    const messages: Message[] = [];\r\n    let all = this._trackedObjectPool.all;\r\n    let newTrackableObjects: object[] = [];\r\n    while (all.length > 0) {\r\n      newTrackableObjects = [];\r\n      all.forEach((obj) => {\r\n        this.getMessagesForTrackableObjectInfo(obj, client, messages, newTrackableObjects);\r\n      });\r\n      all = newTrackableObjects;\r\n    }\r\n\r\n    this._untrackedObjectInfosByClient.forEach((deleteMessages, c) => {\r\n      if (c === client) {\r\n        messages.push(...deleteMessages);\r\n        this._untrackedObjectInfosByClient.delete(client);\r\n      }\r\n    });\r\n    return messages;\r\n  }\r\n\r\n  /**\r\n   * Internal: Adds create/change/execute messages for a tracked object to the outgoing message list for a client.\r\n   * Also tracks any nested objects referenced in the message.\r\n   */\r\n  private getMessagesForTrackableObjectInfo(syncObject: object, client: ClientConnection, messages: Message[], newTrackableObjects: object[]): void {\r\n    if (!checkCanUseObject(syncObject, client.designation)) return;\r\n    if (!checkCanUseObject(syncObject, this._settings.designation)) return;\r\n\r\n    const hostObjectInfo = getHostObjectInfo(syncObject);\r\n    if (!hostObjectInfo?.isForClient(client)) return;\r\n\r\n    const hasClient = hostObjectInfo.clients.has(client);\r\n    let message: Message | null;\r\n    if (!hasClient) {\r\n      message = hostObjectInfo.getCreateMessage(client);\r\n      if (message !== null) {\r\n        hostObjectInfo.clients.add(client);\r\n      }\r\n    } else {\r\n      message = hostObjectInfo.getChangeMessage(client);\r\n    }\r\n    if (message !== null) {\r\n      newTrackableObjects.push(...this.gatherUntrackedObjectInfos(message));\r\n      messages.push(message);\r\n    }\r\n\r\n    const executeMessages = hostObjectInfo.getExecuteMessages(client) as ExecuteObjectMessage<object>[];\r\n    messages.push(...executeMessages);\r\n  }\r\n\r\n  private tick(): void {\r\n    this._trackedObjectPool.all.forEach((obj) => {\r\n      const hostObjectInfo = getHostObjectInfo(obj)!;\r\n      hostObjectInfo?.tick();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes all tracked objects that are not reachable from any of the provided root objects.\r\n   * Traverses the object graph starting from the roots and untracks all unreachable objects.\r\n   */\r\n  private removeUnusedObjects(): void {\r\n    // Set of reachable TrackableObjects\r\n    const reachable = new Set<object>();\r\n    const stack: object[] = [];\r\n\r\n    // Helper to add an object to the stack if not already visited\r\n    const visit = (obj: object) => {\r\n      if (!reachable.has(obj)) {\r\n        reachable.add(obj);\r\n        stack.push(obj);\r\n      }\r\n    };\r\n\r\n    // Initialize stack with all root objects\r\n    const allRootObjects = this._trackedObjectPool.all.filter((info) => {\r\n      const hostObjectInfo = getHostObjectInfo(info)!;\r\n      return hostObjectInfo.isRootObject;\r\n    });\r\n    for (const root of allRootObjects) {\r\n      visit(root);\r\n    }\r\n\r\n    // Traverse the object graph\r\n    while (stack.length > 0) {\r\n      const current = stack.pop()!;\r\n      const hostObjectInfo = getHostObjectInfo(current)!;\r\n\r\n      const properties = hostObjectInfo.properties;\r\n      // Check all properties of the current object for references to other trackable objects\r\n      for (const key of Object.keys(properties)) {\r\n        const value = (properties as any)[key]!.value;\r\n        if (value && typeof value === \"object\") {\r\n          visit(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Untrack all objects that are not reachable\r\n    for (const tracked of this._trackedObjectPool.all) {\r\n      if (!reachable.has(tracked)) {\r\n        this.untrackInternal(tracked, false);\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import { ClientConnection, ObjectSyncHost } from \"../host/host.js\";\r\nimport { ObjectSyncClient } from \"../client/client.js\";\r\nimport { Message } from \"./messages.js\";\r\nimport { TrackedObjectPool } from \"./trackedObjectPool.js\";\r\n\r\nexport type ObjectSyncSettings = {\r\n  objectIdPrefix?: string;\r\n  designation?: string;\r\n};\r\n\r\nexport class ObjectSync {\r\n  private readonly _host: ObjectSyncHost;\r\n  private readonly _client: ObjectSyncClient;\r\n\r\n  constructor(private _settings: ObjectSyncSettings) {\r\n    const objectPool = new TrackedObjectPool();\r\n\r\n    this._host = new ObjectSyncHost({\r\n      objectPool,\r\n      ...this._settings,\r\n    });\r\n    this._client = new ObjectSyncClient({\r\n      objectPool,\r\n    });\r\n  }\r\n\r\n  get host(): ObjectSyncHost {\r\n    return this._host;\r\n  }\r\n\r\n  get client(): ObjectSyncClient {\r\n    return this._client;\r\n  }\r\n\r\n  getMessages(): Map<ClientConnection, Message[]> {\r\n    return this._host.getMessages();\r\n  }\r\n\r\n  applyMessages(messagesByClient: Map<ClientConnection, Message[]>): void {\r\n    for (const [clientToken, messages] of messagesByClient) {\r\n      const results = this._client.apply(messages);\r\n      for (const obj of results.newTrackedObjects) {\r\n        this._host.track(obj, {\r\n          ignoreAlreadyTracked: true,\r\n          knownClients: clientToken,\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["syncProperty", "syncMethod", "syncObject", "syncObject"]
}
